"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/effect";
exports.ids = ["vendor-chunks/effect"];
exports.modules = {

/***/ "(ssr)/./node_modules/effect/dist/esm/Context.js":
/*!*************************************************!*\
  !*** ./node_modules/effect/dist/esm/Context.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenericTag: () => (/* binding */ GenericTag),\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getOption: () => (/* binding */ getOption),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   isContext: () => (/* binding */ isContext),\n/* harmony export */   isTag: () => (/* binding */ isTag),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   unsafeGet: () => (/* binding */ unsafeGet),\n/* harmony export */   unsafeMake: () => (/* binding */ unsafeMake)\n/* harmony export */ });\n/* harmony import */ var _internal_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/context.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/context.js\");\n\nconst TagTypeId = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.TagTypeId;\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * @param key - A key that will be used to compare tags.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n *\n * @since 2.0.0\n * @category constructors\n */\nconst GenericTag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.makeGenericTag;\nconst TypeId = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.TypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst unsafeMake = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.makeContext;\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @param input - The value to be checked if it is a `Context`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category guards\n */\nconst isContext = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.isContext;\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @param input - The value to be checked if it is a `Tag`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n *\n * @since 2.0.0\n * @category guards\n */\nconst isTag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.isTag;\n/**\n * Returns an empty `Context`.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 2.0.0\n * @category constructors\n */\nconst empty = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.empty;\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n *\n * @since 2.0.0\n * @category constructors\n */\nconst make = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.make;\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * import { Context, pipe } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nconst add = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.add;\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { pipe, Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n * @category getters\n */\nconst get = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.get;\n/**\n * Get a service from the context that corresponds to the given tag, or\n * use the fallback value.\n *\n * @since 3.7.0\n * @category getters\n */\nconst getOrElse = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.getOrElse;\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n *\n * @since 2.0.0\n * @category unsafe\n */\nconst unsafeGet = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.unsafeGet;\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import { Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n *\n * @since 2.0.0\n * @category getters\n */\nconst getOption = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.getOption;\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @param self - The first `Context` to merge.\n * @param that - The second `Context` to merge.\n *\n * @example\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 2.0.0\n */\nconst merge = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.merge;\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @param self - The `Context` to prune services from.\n * @param tags - The list of `Tag`s to be included in the new `Context`.\n *\n * @example\n * import { pipe, Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n *\n * @since 2.0.0\n */\nconst pick = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.pick;\n/**\n * @since 2.0.0\n */\nconst omit = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.omit;\n/**\n * @since 2.0.0\n * @category constructors\n */\nconst Tag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.Tag;\n//# sourceMappingURL=Context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDtBQUNsRCxrQkFBa0IsMkRBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsZ0VBQXVCO0FBQ2pELGVBQWUsd0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsNkRBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsMkRBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxjQUFjLHVEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGNBQWMsdURBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRCx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNPLFlBQVkscURBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLHFDQUFxQyxjQUFjO0FBQ25ELHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSw0REFBNEQsZUFBZTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFlBQVkscURBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsMkRBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtCQUFrQiwyREFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsMkVBQTJFLFlBQVk7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtCQUFrQiwyREFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRCx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckUsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ08sY0FBYyx1REFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsWUFBWTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ08sYUFBYSxzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNPLFlBQVkscURBQVk7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vQ29udGV4dC5qcz9kYTM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGludGVybmFsIGZyb20gXCIuL2ludGVybmFsL2NvbnRleHQuanNcIjtcbmNvbnN0IFRhZ1R5cGVJZCA9IGludGVybmFsLlRhZ1R5cGVJZDtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgVGFnYCBpbnN0YW5jZSB3aXRoIGFuIG9wdGlvbmFsIGtleSBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIGtleSAtIEEga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbXBhcmUgdGFncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChDb250ZXh0LkdlbmVyaWNUYWcoXCJQT1JUXCIpLmtleSA9PT0gQ29udGV4dC5HZW5lcmljVGFnKFwiUE9SVFwiKS5rZXksIHRydWUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBHZW5lcmljVGFnID0gaW50ZXJuYWwubWFrZUdlbmVyaWNUYWc7XG5jb25zdCBUeXBlSWQgPSBpbnRlcm5hbC5UeXBlSWQ7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgdW5zYWZlTWFrZSA9IGludGVybmFsLm1ha2VDb250ZXh0O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIGEgYENvbnRleHRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkIGlmIGl0IGlzIGEgYENvbnRleHRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKENvbnRleHQuaXNDb250ZXh0KENvbnRleHQuZW1wdHkoKSksIHRydWUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0NvbnRleHQgPSBpbnRlcm5hbC5pc0NvbnRleHQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnQgaXMgYSBgVGFnYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBhIGBUYWdgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKENvbnRleHQuaXNUYWcoQ29udGV4dC5HZW5lcmljVGFnKFwiVGFnXCIpKSwgdHJ1ZSlcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGFnID0gaW50ZXJuYWwuaXNUYWc7XG4vKipcbiAqIFJldHVybnMgYW4gZW1wdHkgYENvbnRleHRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKENvbnRleHQuaXNDb250ZXh0KENvbnRleHQuZW1wdHkoKSksIHRydWUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBlbXB0eSA9IGludGVybmFsLmVtcHR5O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBDb250ZXh0YCB3aXRoIGEgc2luZ2xlIHNlcnZpY2UgYXNzb2NpYXRlZCB0byB0aGUgdGFnLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gaW50ZXJuYWwubWFrZTtcbi8qKlxuICogQWRkcyBhIHNlcnZpY2UgdG8gYSBnaXZlbiBgQ29udGV4dGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IENvbnRleHQsIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBzb21lQ29udGV4dCA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IHBpcGUoXG4gKiAgIHNvbWVDb250ZXh0LFxuICogICBDb250ZXh0LmFkZChUaW1lb3V0LCB7IFRJTUVPVVQ6IDUwMDAgfSlcbiAqIClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSBpbnRlcm5hbC5hZGQ7XG4vKipcbiAqIEdldCBhIHNlcnZpY2UgZnJvbSB0aGUgY29udGV4dCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiB0YWcuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYENvbnRleHRgIHRvIHNlYXJjaCBmb3IgdGhlIHNlcnZpY2UuXG4gKiBAcGFyYW0gdGFnIC0gVGhlIGBUYWdgIG9mIHRoZSBzZXJ2aWNlIHRvIHJldHJpZXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqIGNvbnN0IFRpbWVvdXQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBUSU1FT1VUOiBudW1iZXIgfT4oXCJUaW1lb3V0XCIpXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBwaXBlKFxuICogICBDb250ZXh0Lm1ha2UoUG9ydCwgeyBQT1JUOiA4MDgwIH0pLFxuICogICBDb250ZXh0LmFkZChUaW1lb3V0LCB7IFRJTUVPVVQ6IDUwMDAgfSlcbiAqIClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICovXG5leHBvcnQgY29uc3QgZ2V0ID0gaW50ZXJuYWwuZ2V0O1xuLyoqXG4gKiBHZXQgYSBzZXJ2aWNlIGZyb20gdGhlIGNvbnRleHQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gdGFnLCBvclxuICogdXNlIHRoZSBmYWxsYmFjayB2YWx1ZS5cbiAqXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSBpbnRlcm5hbC5nZXRPckVsc2U7XG4vKipcbiAqIEdldCBhIHNlcnZpY2UgZnJvbSB0aGUgY29udGV4dCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiB0YWcuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGlmIHRoZSB0YWcgaXMgbm90IHByZXNlbnQgaW4gdGhlIGNvbnRleHQsIGEgcnVudGltZSBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBGb3IgYSBzYWZlciB2ZXJzaW9uIHNlZSB7QGxpbmsgZ2V0T3B0aW9ufS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgQ29udGV4dGAgdG8gc2VhcmNoIGZvciB0aGUgc2VydmljZS5cbiAqIEBwYXJhbSB0YWcgLSBUaGUgYFRhZ2Agb2YgdGhlIHNlcnZpY2UgdG8gcmV0cmlldmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQudW5zYWZlR2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQudGhyb3dzKCgpID0+IENvbnRleHQudW5zYWZlR2V0KFNlcnZpY2VzLCBUaW1lb3V0KSlcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSB1bnNhZmVcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUdldCA9IGludGVybmFsLnVuc2FmZUdldDtcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0YWcgZnJvbSB0aGUgY29udGV4dCB3cmFwcGVkIGluIGFuIGBPcHRpb25gIG9iamVjdC4gSWYgdGhlIHRhZyBpcyBub3RcbiAqIGZvdW5kLCB0aGUgYE9wdGlvbmAgb2JqZWN0IHdpbGwgYmUgYE5vbmVgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBDb250ZXh0YCB0byBzZWFyY2ggZm9yIHRoZSBzZXJ2aWNlLlxuICogQHBhcmFtIHRhZyAtIFRoZSBgVGFnYCBvZiB0aGUgc2VydmljZSB0byByZXRyaWV2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29udGV4dCwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqIGNvbnN0IFRpbWVvdXQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBUSU1FT1VUOiBudW1iZXIgfT4oXCJUaW1lb3V0XCIpXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBDb250ZXh0Lm1ha2UoUG9ydCwgeyBQT1JUOiA4MDgwIH0pXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChDb250ZXh0LmdldE9wdGlvbihTZXJ2aWNlcywgUG9ydCksIE9wdGlvbi5zb21lKHsgUE9SVDogODA4MCB9KSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXRPcHRpb24oU2VydmljZXMsIFRpbWVvdXQpLCBPcHRpb24ubm9uZSgpKVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9wdGlvbiA9IGludGVybmFsLmdldE9wdGlvbjtcbi8qKlxuICogTWVyZ2VzIHR3byBgQ29udGV4dGBzLCByZXR1cm5pbmcgYSBuZXcgYENvbnRleHRgIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2VzIG9mIGJvdGguXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgYENvbnRleHRgIHRvIG1lcmdlLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgc2Vjb25kIGBDb250ZXh0YCB0byBtZXJnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IFBvcnQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBQT1JUOiBudW1iZXIgfT4oXCJQb3J0XCIpXG4gKiBjb25zdCBUaW1lb3V0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgVElNRU9VVDogbnVtYmVyIH0+KFwiVGltZW91dFwiKVxuICpcbiAqIGNvbnN0IGZpcnN0Q29udGV4dCA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqIGNvbnN0IHNlY29uZENvbnRleHQgPSBDb250ZXh0Lm1ha2UoVGltZW91dCwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBDb250ZXh0Lm1lcmdlKGZpcnN0Q29udGV4dCwgc2Vjb25kQ29udGV4dClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZSA9IGludGVybmFsLm1lcmdlO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBDb250ZXh0YCB0aGF0IGNvbnRhaW5zIG9ubHkgdGhlIHNwZWNpZmllZCBzZXJ2aWNlcy5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgQ29udGV4dGAgdG8gcHJ1bmUgc2VydmljZXMgZnJvbS5cbiAqIEBwYXJhbSB0YWdzIC0gVGhlIGxpc3Qgb2YgYFRhZ2BzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgYENvbnRleHRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBDb250ZXh0LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBzb21lQ29udGV4dCA9IHBpcGUoXG4gKiAgIENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSksXG4gKiAgIENvbnRleHQuYWRkKFRpbWVvdXQsIHsgVElNRU9VVDogNTAwMCB9KVxuICogKVxuICpcbiAqIGNvbnN0IFNlcnZpY2VzID0gcGlwZShzb21lQ29udGV4dCwgQ29udGV4dC5waWNrKFBvcnQpKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXRPcHRpb24oU2VydmljZXMsIFBvcnQpLCBPcHRpb24uc29tZSh7IFBPUlQ6IDgwODAgfSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0T3B0aW9uKFNlcnZpY2VzLCBUaW1lb3V0KSwgT3B0aW9uLm5vbmUoKSlcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHBpY2sgPSBpbnRlcm5hbC5waWNrO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9taXQgPSBpbnRlcm5hbC5vbWl0O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IFRhZyA9IGludGVybmFsLlRhZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Effectable.js":
/*!****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Effectable.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelTypeId: () => (/* binding */ ChannelTypeId),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   CommitPrototype: () => (/* binding */ CommitPrototype),\n/* harmony export */   EffectPrototype: () => (/* binding */ EffectPrototype),\n/* harmony export */   EffectTypeId: () => (/* binding */ EffectTypeId),\n/* harmony export */   SinkTypeId: () => (/* binding */ SinkTypeId),\n/* harmony export */   StreamTypeId: () => (/* binding */ StreamTypeId),\n/* harmony export */   StructuralClass: () => (/* binding */ StructuralClass),\n/* harmony export */   StructuralCommitPrototype: () => (/* binding */ StructuralCommitPrototype)\n/* harmony export */ });\n/* harmony import */ var _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst EffectTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst StreamTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StreamTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst SinkTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.SinkTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */\nconst ChannelTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.ChannelTypeId;\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst EffectPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype;\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst CommitPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.CommitPrototype;\n/**\n * @since 2.0.0\n * @category prototypes\n */\nconst StructuralCommitPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StructuralCommitPrototype;\nconst Base = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.Base;\nconst StructuralBase = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StructuralBase;\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass Class extends Base {}\n/**\n * @since 2.0.0\n * @category constructors\n */\nclass StructuralClass extends StructuralBase {}\n//# sourceMappingURL=Effectable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VmZmVjdGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQixpRUFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsaUVBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLCtEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQixrRUFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0Isb0VBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLG9FQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyw4RUFBa0M7QUFDM0UsYUFBYSx5REFBYTtBQUMxQix1QkFBdUIsbUVBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vRWZmZWN0YWJsZS5qcz8xM2IyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGludGVybmFsIGZyb20gXCIuL2ludGVybmFsL2VmZmVjdGFibGUuanNcIjtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgdHlwZSBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IEVmZmVjdFR5cGVJZCA9IGludGVybmFsLkVmZmVjdFR5cGVJZDtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgdHlwZSBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVR5cGVJZCA9IGludGVybmFsLlN0cmVhbVR5cGVJZDtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgdHlwZSBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IFNpbmtUeXBlSWQgPSBpbnRlcm5hbC5TaW5rVHlwZUlkO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSB0eXBlIGlkc1xuICovXG5leHBvcnQgY29uc3QgQ2hhbm5lbFR5cGVJZCA9IGludGVybmFsLkNoYW5uZWxUeXBlSWQ7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHByb3RvdHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IEVmZmVjdFByb3RvdHlwZSA9IGludGVybmFsLkVmZmVjdFByb3RvdHlwZTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgcHJvdG90eXBlc1xuICovXG5leHBvcnQgY29uc3QgQ29tbWl0UHJvdG90eXBlID0gaW50ZXJuYWwuQ29tbWl0UHJvdG90eXBlO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBwcm90b3R5cGVzXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJ1Y3R1cmFsQ29tbWl0UHJvdG90eXBlID0gaW50ZXJuYWwuU3RydWN0dXJhbENvbW1pdFByb3RvdHlwZTtcbmNvbnN0IEJhc2UgPSBpbnRlcm5hbC5CYXNlO1xuY29uc3QgU3RydWN0dXJhbEJhc2UgPSBpbnRlcm5hbC5TdHJ1Y3R1cmFsQmFzZTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGFzcyBleHRlbmRzIEJhc2Uge31cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3R1cmFsQ2xhc3MgZXh0ZW5kcyBTdHJ1Y3R1cmFsQmFzZSB7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWZmZWN0YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Effectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Either.js":
/*!************************************************!*\
  !*** ./node_modules/effect/dist/esm/Either.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   ap: () => (/* binding */ ap),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   filterOrLeft: () => (/* binding */ filterOrLeft),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   fromNullable: () => (/* binding */ fromNullable),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   getOrNull: () => (/* binding */ getOrNull),\n/* harmony export */   getOrThrow: () => (/* binding */ getOrThrow),\n/* harmony export */   getOrThrowWith: () => (/* binding */ getOrThrowWith),\n/* harmony export */   getOrUndefined: () => (/* binding */ getOrUndefined),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isEither: () => (/* binding */ isEither),\n/* harmony export */   isLeft: () => (/* binding */ isLeft),\n/* harmony export */   isRight: () => (/* binding */ isRight),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   liftPredicate: () => (/* binding */ liftPredicate),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapBoth: () => (/* binding */ mapBoth),\n/* harmony export */   mapLeft: () => (/* binding */ mapLeft),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   orElse: () => (/* binding */ orElse),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   \"try\": () => (/* binding */ try_),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/either.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/either.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/**\n * @since 2.0.0\n */\n\n\n\n\n\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst TypeId = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.TypeId;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst right = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.right;\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst left = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.left;\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n *\n * @category constructors\n * @since 2.0.0\n */\nconst fromNullable = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNullable) => self == null ? left(onNullable(self)) : right(self));\n/**\n * @example\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n *\n * @category constructors\n * @since 2.0.0\n */\nconst fromOption = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.fromOption;\nconst try_ = evaluate => {\n  if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isFunction)(evaluate)) {\n    try {\n      return right(evaluate());\n    } catch (e) {\n      return left(e);\n    }\n  } else {\n    try {\n      return right(evaluate.try());\n    } catch (e) {\n      return left(evaluate.catch(e));\n    }\n  }\n};\n\n/**\n * Tests if a value is a `Either`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\n * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isEither = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isEither;\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\n * assert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isLeft;\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isRight;\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * Alias of {@link toOption}.\n *\n * @example\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n *\n * @category getters\n * @since 2.0.0\n */\nconst getRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\n * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.getLeft;\n/**\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = ({\n  left,\n  right\n}) => _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__.make((x, y) => isLeft(x) ? isLeft(y) && left(x.left, y.left) : isRight(y) && right(x.right, y.right));\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst mapBoth = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right)));\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @param self - The input `Either` value to map.\n * @param f - A transformation function to apply to the `Left` value of the input `Either`.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst mapLeft = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @param self - An `Either` to map\n * @param f - The function to map over the value of the `Either`\n *\n * @category mapping\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * import { pipe, Either } from \"effect\"\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nconst match = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? onLeft(self.left) : onRight(self.right));\n/**\n * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n * or `Left` of the result of the provided function if the predicate returns false\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     0,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n *\n * @category lifting\n * @since 3.4.0\n */\nconst liftPredicate = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (a, predicate, orLeftWith) => predicate(a) ? right(a) : left(orLeftWith(a)));\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(1),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(0),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nconst filterOrLeft = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, orLeftWith) => flatMap(self, r => predicate(r) ? right(r) : left(orLeftWith(r))));\n/**\n * @category getters\n * @since 2.0.0\n */\nconst merge = /*#__PURE__*/match({\n  onLeft: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n  onRight: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n});\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onLeft) => isLeft(self) ? onLeft(self.left) : self.right);\n/**\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrNull = /*#__PURE__*/getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constNull);\n/**\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrUndefined = /*#__PURE__*/getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constUndefined);\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Either` to extract the value from.\n * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrThrowWith = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onLeft) => {\n  if (isRight(self)) {\n    return self.right;\n  }\n  throw onLeft(self.left);\n});\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Either` to extract the value from.\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\n * assert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a Left\"));\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @param self - The input `Either` value to check and potentially return.\n * @param that - A function that takes the error value from `self` (if it's a `Left`) and returns a new `Either` value.\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => isLeft(self) ? that(self.left) : right(self.right));\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isLeft(self) ? left(self.left) : f(self.right));\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nconst andThen = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => flatMap(self, a => {\n  const b = (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isFunction)(f) ? f(a) : f;\n  return isEither(b) ? b : right(b);\n}));\n/**\n * @category zipping\n * @since 2.0.0\n */\nconst zipWith = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, that, f) => flatMap(self, r => map(that, r2 => f(r, r2))));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst ap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @param fields - the struct of `Either`s to be sequenced.\n *\n * @example\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nconst all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const e of input) {\n      if (isLeft(e)) {\n        return e;\n      }\n      out.push(e.right);\n    }\n    return right(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const e = input[key];\n    if (isLeft(e)) {\n      return e;\n    }\n    out[key] = e.right;\n  }\n  return right(out);\n};\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nconst flip = self => isLeft(self) ? right(self.left) : left(self.right);\nconst adapter = /*#__PURE__*/_Utils_js__WEBPACK_IMPORTED_MODULE_4__.adapter();\n/**\n * @category generators\n * @since 2.0.0\n */\nconst gen = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);\n  const iterator = f(adapter);\n  let state = iterator.next();\n  if (state.done) {\n    return right(state.value);\n  } else {\n    let current = state.value;\n    if (_Utils_js__WEBPACK_IMPORTED_MODULE_4__.isGenKind(current)) {\n      current = current.value;\n    } else {\n      current = _Utils_js__WEBPACK_IMPORTED_MODULE_4__.yieldWrapGet(current);\n    }\n    if (isLeft(current)) {\n      return current;\n    }\n    while (!state.done) {\n      state = iterator.next(current.right);\n      if (!state.done) {\n        current = state.value;\n        if (_Utils_js__WEBPACK_IMPORTED_MODULE_4__.isGenKind(current)) {\n          current = current.value;\n        } else {\n          current = _Utils_js__WEBPACK_IMPORTED_MODULE_4__.yieldWrapGet(current);\n        }\n        if (isLeft(current)) {\n          return current;\n        }\n      }\n    }\n    return right(state.value);\n  }\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst Do = /*#__PURE__*/right({});\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst bind = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst bindTo = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.bindTo(map);\nconst let_ = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.let_(map);\n\n//# sourceMappingURL=Either.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VpdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDMEI7QUFDbkI7QUFDUjtBQUNIO0FBQ1Y7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLHVEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sY0FBYyxzREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEscURBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxrREFBSTtBQUM3QztBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkRBQWlCO0FBQzNDO0FBQ0EsTUFBTSx5REFBVTtBQUNoQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQVNjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUJBQWlCLHlEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsdURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLGlEQUFpRCxvQkFBb0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIseURBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLGlEQUFpRCxvQkFBb0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsMkRBQWlCO0FBQ3BELDBCQUEwQix5REFBZTtBQThCM0I7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9FaXRoZXIuanM/YjQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgKiBhcyBFcXVpdmFsZW5jZSBmcm9tIFwiLi9FcXVpdmFsZW5jZS5qc1wiO1xuaW1wb3J0IHsgY29uc3ROdWxsLCBjb25zdFVuZGVmaW5lZCwgZHVhbCwgaWRlbnRpdHkgfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgZG9Ob3RhdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9kb05vdGF0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBlaXRoZXIgZnJvbSBcIi4vaW50ZXJuYWwvZWl0aGVyLmpzXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgKiBhcyBHZW4gZnJvbSBcIi4vVXRpbHMuanNcIjtcbi8qKlxuICogQGNhdGVnb3J5IHN5bWJvbHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgVHlwZUlkID0gZWl0aGVyLlR5cGVJZDtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRWl0aGVyYCBob2xkaW5nIGEgYFJpZ2h0YCB2YWx1ZS4gVGhpcyB1c3VhbGx5IHJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIHZhbHVlIGR1ZSB0byB0aGUgcmlnaHQgYmlhc1xuICogb2YgdGhpcyBzdHJ1Y3R1cmUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByaWdodCA9IGVpdGhlci5yaWdodDtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRWl0aGVyYCBob2xkaW5nIGEgYExlZnRgIHZhbHVlLiBUaGlzIHVzdWFsbHkgcmVwcmVzZW50cyBhIGZhaWx1cmUsIGR1ZSB0byB0aGUgcmlnaHQtYmlhcyBvZiB0aGlzXG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZWZ0ID0gZWl0aGVyLmxlZnQ7XG4vKipcbiAqIFRha2VzIGEgbGF6eSBkZWZhdWx0IGFuZCBhIG51bGxhYmxlIHZhbHVlLCBpZiB0aGUgdmFsdWUgaXMgbm90IG51bGx5IChgbnVsbGAgb3IgYHVuZGVmaW5lZGApLCB0dXJuIGl0IGludG8gYSBgUmlnaHRgLCBpZiB0aGUgdmFsdWUgaXMgbnVsbHkgdXNlXG4gKiB0aGUgcHJvdmlkZWQgZGVmYXVsdCBhcyBhIGBMZWZ0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZnJvbU51bGxhYmxlKDEsICgpID0+ICdmYWxsYmFjaycpLCBFaXRoZXIucmlnaHQoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5mcm9tTnVsbGFibGUobnVsbCwgKCkgPT4gJ2ZhbGxiYWNrJyksIEVpdGhlci5sZWZ0KCdmYWxsYmFjaycpKVxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbU51bGxhYmxlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9uTnVsbGFibGUpID0+IHNlbGYgPT0gbnVsbCA/IGxlZnQob25OdWxsYWJsZShzZWxmKSkgOiByaWdodChzZWxmKSk7XG4vKipcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBFaXRoZXIsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmZyb21PcHRpb24oT3B0aW9uLnNvbWUoMSksICgpID0+ICdlcnJvcicpLCBFaXRoZXIucmlnaHQoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5mcm9tT3B0aW9uKE9wdGlvbi5ub25lKCksICgpID0+ICdlcnJvcicpLCBFaXRoZXIubGVmdCgnZXJyb3InKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21PcHRpb24gPSBlaXRoZXIuZnJvbU9wdGlvbjtcbmNvbnN0IHRyeV8gPSBldmFsdWF0ZSA9PiB7XG4gIGlmIChpc0Z1bmN0aW9uKGV2YWx1YXRlKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmlnaHQoZXZhbHVhdGUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxlZnQoZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmlnaHQoZXZhbHVhdGUudHJ5KCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsZWZ0KGV2YWx1YXRlLmNhdGNoKGUpKTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuLyoqXG4gKiBJbXBvcnRzIGEgc3luY2hyb25vdXMgc2lkZS1lZmZlY3QgaW50byBhIHB1cmUgYEVpdGhlcmAgdmFsdWUsIHRyYW5zbGF0aW5nIGFueVxuICogdGhyb3duIGV4Y2VwdGlvbnMgaW50byB0eXBlZCBmYWlsZWQgZWl0aGVycyBjcmVhdGluZyB3aXRoIGBFaXRoZXIubGVmdGAuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnRyeV8gYXMgdHJ5IH07XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgRWl0aGVyYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuaXNFaXRoZXIoRWl0aGVyLnJpZ2h0KDEpKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzRWl0aGVyKEVpdGhlci5sZWZ0KFwiYVwiKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5pc0VpdGhlcih7IHJpZ2h0OiAxIH0pLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRWl0aGVyID0gZWl0aGVyLmlzRWl0aGVyO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgRWl0aGVyYCBpcyBhIGBMZWZ0YC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgRWl0aGVyYCB0byBjaGVjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuaXNMZWZ0KEVpdGhlci5yaWdodCgxKSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuaXNMZWZ0KEVpdGhlci5sZWZ0KFwiYVwiKSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0xlZnQgPSBlaXRoZXIuaXNMZWZ0O1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgRWl0aGVyYCBpcyBhIGBSaWdodGAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEVpdGhlcmAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzUmlnaHQoRWl0aGVyLnJpZ2h0KDEpKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzUmlnaHQoRWl0aGVyLmxlZnQoXCJhXCIpKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1JpZ2h0ID0gZWl0aGVyLmlzUmlnaHQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEVpdGhlcmAgdG8gYW4gYE9wdGlvbmAgZGlzY2FyZGluZyB0aGUgYExlZnRgLlxuICpcbiAqIEFsaWFzIG9mIHtAbGluayB0b09wdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0UmlnaHQoRWl0aGVyLnJpZ2h0KCdvaycpKSwgT3B0aW9uLnNvbWUoJ29rJykpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRSaWdodChFaXRoZXIubGVmdCgnZXJyJykpLCBPcHRpb24ubm9uZSgpKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJpZ2h0ID0gZWl0aGVyLmdldFJpZ2h0O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBFaXRoZXJgIHRvIGFuIGBPcHRpb25gIGRpc2NhcmRpbmcgdGhlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBFaXRoZXIsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldExlZnQoRWl0aGVyLnJpZ2h0KCdvaycpKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldExlZnQoRWl0aGVyLmxlZnQoJ2VycicpKSwgT3B0aW9uLnNvbWUoJ2VycicpKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldExlZnQgPSBlaXRoZXIuZ2V0TGVmdDtcbi8qKlxuICogQGNhdGVnb3J5IGVxdWl2YWxlbmNlXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVxdWl2YWxlbmNlID0gKHtcbiAgbGVmdCxcbiAgcmlnaHRcbn0pID0+IEVxdWl2YWxlbmNlLm1ha2UoKHgsIHkpID0+IGlzTGVmdCh4KSA/IGlzTGVmdCh5KSAmJiBsZWZ0KHgubGVmdCwgeS5sZWZ0KSA6IGlzUmlnaHQoeSkgJiYgcmlnaHQoeC5yaWdodCwgeS5yaWdodCkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBCb3RoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHtcbiAgb25MZWZ0LFxuICBvblJpZ2h0XG59KSA9PiBpc0xlZnQoc2VsZikgPyBsZWZ0KG9uTGVmdChzZWxmLmxlZnQpKSA6IHJpZ2h0KG9uUmlnaHQoc2VsZi5yaWdodCkpKTtcbi8qKlxuICogTWFwcyB0aGUgYExlZnRgIHNpZGUgb2YgYW4gYEVpdGhlcmAgdmFsdWUgdG8gYSBuZXcgYEVpdGhlcmAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgaW5wdXQgYEVpdGhlcmAgdmFsdWUgdG8gbWFwLlxuICogQHBhcmFtIGYgLSBBIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBgTGVmdGAgdmFsdWUgb2YgdGhlIGlucHV0IGBFaXRoZXJgLlxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcExlZnQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gaXNMZWZ0KHNlbGYpID8gbGVmdChmKHNlbGYubGVmdCkpIDogcmlnaHQoc2VsZi5yaWdodCkpO1xuLyoqXG4gKiBNYXBzIHRoZSBgUmlnaHRgIHNpZGUgb2YgYW4gYEVpdGhlcmAgdmFsdWUgdG8gYSBuZXcgYEVpdGhlcmAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBbiBgRWl0aGVyYCB0byBtYXBcbiAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIG1hcCBvdmVyIHRoZSB2YWx1ZSBvZiB0aGUgYEVpdGhlcmBcbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gaXNSaWdodChzZWxmKSA/IHJpZ2h0KGYoc2VsZi5yaWdodCkpIDogbGVmdChzZWxmLmxlZnQpKTtcbi8qKlxuICogVGFrZXMgdHdvIGZ1bmN0aW9ucyBhbmQgYW4gYEVpdGhlcmAgdmFsdWUsIGlmIHRoZSB2YWx1ZSBpcyBhIGBMZWZ0YCB0aGUgaW5uZXIgdmFsdWUgaXMgYXBwbGllZCB0byB0aGUgYG9uTGVmdCBmdW5jdGlvbixcbiAqIGlmIHRoZSB2YWx1ZSBpcyBhIGBSaWdodGAgdGhlIGlubmVyIHZhbHVlIGlzIGFwcGxpZWQgdG8gdGhlIGBvblJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcGlwZSwgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3Qgb25MZWZ0ICA9IChzdHJpbmdzOiBSZWFkb25seUFycmF5PHN0cmluZz4pOiBzdHJpbmcgPT4gYHN0cmluZ3M6ICR7c3RyaW5ncy5qb2luKCcsICcpfWBcbiAqXG4gKiBjb25zdCBvblJpZ2h0ID0gKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgPT4gYE9rOiAke3ZhbHVlfWBcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoRWl0aGVyLnJpZ2h0KDEpLCBFaXRoZXIubWF0Y2goeyBvbkxlZnQsIG9uUmlnaHQgfSkpLCAnT2s6IDEnKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShFaXRoZXIubGVmdChbJ3N0cmluZyAxJywgJ3N0cmluZyAyJ10pLCBFaXRoZXIubWF0Y2goeyBvbkxlZnQsIG9uUmlnaHQgfSkpLFxuICogICAnc3RyaW5nczogc3RyaW5nIDEsIHN0cmluZyAyJ1xuICogKVxuICpcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHtcbiAgb25MZWZ0LFxuICBvblJpZ2h0XG59KSA9PiBpc0xlZnQoc2VsZikgPyBvbkxlZnQoc2VsZi5sZWZ0KSA6IG9uUmlnaHQoc2VsZi5yaWdodCkpO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgYFByZWRpY2F0ZWAgZnVuY3Rpb24gaW50byBhIGBSaWdodGAgb2YgdGhlIGlucHV0IHZhbHVlIGlmIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBgdHJ1ZWBcbiAqIG9yIGBMZWZ0YCBvZiB0aGUgcmVzdWx0IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpZiB0aGUgcHJlZGljYXRlIHJldHVybnMgZmFsc2VcbiAqXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gQSBgUHJlZGljYXRlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGluIGEgdmFsdWUgb2YgdHlwZSBgQWAgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBpc1Bvc2l0aXZlID0gKG46IG51bWJlcik6IGJvb2xlYW4gPT4gbiA+IDBcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIDEsXG4gKiAgICAgRWl0aGVyLmxpZnRQcmVkaWNhdGUoaXNQb3NpdGl2ZSwgbiA9PiBgJHtufSBpcyBub3QgcG9zaXRpdmVgKVxuICogICApLFxuICogICBFaXRoZXIucmlnaHQoMSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgMCxcbiAqICAgICBFaXRoZXIubGlmdFByZWRpY2F0ZShpc1Bvc2l0aXZlLCBuID0+IGAke259IGlzIG5vdCBwb3NpdGl2ZWApXG4gKiAgICksXG4gKiAgIEVpdGhlci5sZWZ0KFwiMCBpcyBub3QgcG9zaXRpdmVcIilcbiAqIClcbiAqXG4gKiBAY2F0ZWdvcnkgbGlmdGluZ1xuICogQHNpbmNlIDMuNC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0UHJlZGljYXRlID0gLyojX19QVVJFX18qL2R1YWwoMywgKGEsIHByZWRpY2F0ZSwgb3JMZWZ0V2l0aCkgPT4gcHJlZGljYXRlKGEpID8gcmlnaHQoYSkgOiBsZWZ0KG9yTGVmdFdpdGgoYSkpKTtcbi8qKlxuICogRmlsdGVyIHRoZSByaWdodCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIElmIHRoZSBwcmVkaWNhdGUgZmFpbHMsIHNldCB0aGUgbGVmdCB2YWx1ZSB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBpc1Bvc2l0aXZlID0gKG46IG51bWJlcik6IGJvb2xlYW4gPT4gbiA+IDBcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIEVpdGhlci5yaWdodCgxKSxcbiAqICAgICBFaXRoZXIuZmlsdGVyT3JMZWZ0KGlzUG9zaXRpdmUsIG4gPT4gYCR7bn0gaXMgbm90IHBvc2l0aXZlYClcbiAqICAgKSxcbiAqICAgRWl0aGVyLnJpZ2h0KDEpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIEVpdGhlci5yaWdodCgwKSxcbiAqICAgICBFaXRoZXIuZmlsdGVyT3JMZWZ0KGlzUG9zaXRpdmUsIG4gPT4gYCR7bn0gaXMgbm90IHBvc2l0aXZlYClcbiAqICAgKSxcbiAqICAgRWl0aGVyLmxlZnQoXCIwIGlzIG5vdCBwb3NpdGl2ZVwiKVxuICogKVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGZpbHRlcmluZyAmIGNvbmRpdGlvbmFsc1xuICovXG5leHBvcnQgY29uc3QgZmlsdGVyT3JMZWZ0ID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHByZWRpY2F0ZSwgb3JMZWZ0V2l0aCkgPT4gZmxhdE1hcChzZWxmLCByID0+IHByZWRpY2F0ZShyKSA/IHJpZ2h0KHIpIDogbGVmdChvckxlZnRXaXRoKHIpKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZSA9IC8qI19fUFVSRV9fKi9tYXRjaCh7XG4gIG9uTGVmdDogaWRlbnRpdHksXG4gIG9uUmlnaHQ6IGlkZW50aXR5XG59KTtcbi8qKlxuICogUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBpdCdzIGEgYFJpZ2h0YCBvciBhIGRlZmF1bHQgdmFsdWUgaWYgaXMgYSBgTGVmdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yRWxzZShFaXRoZXIucmlnaHQoMSksIChlcnJvcikgPT4gZXJyb3IgKyBcIiFcIiksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRPckVsc2UoRWl0aGVyLmxlZnQoXCJub3QgYSBudW1iZXJcIiksIChlcnJvcikgPT4gZXJyb3IgKyBcIiFcIiksIFwibm90IGEgbnVtYmVyIVwiKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yRWxzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbkxlZnQpID0+IGlzTGVmdChzZWxmKSA/IG9uTGVmdChzZWxmLmxlZnQpIDogc2VsZi5yaWdodCk7XG4vKipcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRPck51bGwoRWl0aGVyLnJpZ2h0KDEpKSwgMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yTnVsbChFaXRoZXIubGVmdChcImFcIikpLCBudWxsKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yTnVsbCA9IC8qI19fUFVSRV9fKi9nZXRPckVsc2UoY29uc3ROdWxsKTtcbi8qKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yVW5kZWZpbmVkKEVpdGhlci5yaWdodCgxKSksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRPclVuZGVmaW5lZChFaXRoZXIubGVmdChcImFcIikpLCB1bmRlZmluZWQpXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JVbmRlZmluZWQgPSAvKiNfX1BVUkVfXyovZ2V0T3JFbHNlKGNvbnN0VW5kZWZpbmVkKTtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG9mIGFuIGBFaXRoZXJgIG9yIHRocm93cyBpZiB0aGUgYEVpdGhlcmAgaXMgYExlZnRgLlxuICpcbiAqIElmIGEgZGVmYXVsdCBlcnJvciBpcyBzdWZmaWNpZW50IGZvciB5b3VyIHVzZSBjYXNlIGFuZCB5b3UgZG9uJ3QgbmVlZCB0byBjb25maWd1cmUgdGhlIHRocm93biBlcnJvciwgc2VlIHtAbGluayBnZXRPclRocm93fS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgRWl0aGVyYCB0byBleHRyYWN0IHRoZSB2YWx1ZSBmcm9tLlxuICogQHBhcmFtIG9uTGVmdCAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgYEVpdGhlcmAgaXMgYExlZnRgLiBJdCByZXR1cm5zIHRoZSBlcnJvciB0byBiZSB0aHJvd24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIEVpdGhlci5nZXRPclRocm93V2l0aChFaXRoZXIucmlnaHQoMSksICgpID0+IG5ldyBFcnJvcignVW5leHBlY3RlZCBMZWZ0JykpLFxuICogICAxXG4gKiApXG4gKiBhc3NlcnQudGhyb3dzKCgpID0+IEVpdGhlci5nZXRPclRocm93V2l0aChFaXRoZXIubGVmdChcImVycm9yXCIpLCAoKSA9PiBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgTGVmdCcpKSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPclRocm93V2l0aCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbkxlZnQpID0+IHtcbiAgaWYgKGlzUmlnaHQoc2VsZikpIHtcbiAgICByZXR1cm4gc2VsZi5yaWdodDtcbiAgfVxuICB0aHJvdyBvbkxlZnQoc2VsZi5sZWZ0KTtcbn0pO1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdmFsdWUgb2YgYW4gYEVpdGhlcmAgb3IgdGhyb3dzIGlmIHRoZSBgRWl0aGVyYCBpcyBgTGVmdGAuXG4gKlxuICogVGhlIHRocm93biBlcnJvciBpcyBhIGRlZmF1bHQgZXJyb3IuIFRvIGNvbmZpZ3VyZSB0aGUgZXJyb3IgdGhyb3duLCBzZWUgIHtAbGluayBnZXRPclRocm93V2l0aH0uXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEVpdGhlcmAgdG8gZXh0cmFjdCB0aGUgdmFsdWUgZnJvbS5cbiAqIEB0aHJvd3MgYEVycm9yKFwiZ2V0T3JUaHJvdyBjYWxsZWQgb24gYSBMZWZ0XCIpYFxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRPclRocm93KEVpdGhlci5yaWdodCgxKSksIDEpXG4gKiBhc3NlcnQudGhyb3dzKCgpID0+IEVpdGhlci5nZXRPclRocm93KEVpdGhlci5sZWZ0KFwiZXJyb3JcIikpKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yVGhyb3cgPSAvKiNfX1BVUkVfXyovZ2V0T3JUaHJvd1dpdGgoKCkgPT4gbmV3IEVycm9yKFwiZ2V0T3JUaHJvdyBjYWxsZWQgb24gYSBMZWZ0XCIpKTtcbi8qKlxuICogUmV0dXJucyBgc2VsZmAgaWYgaXQgaXMgYSBgUmlnaHRgIG9yIGB0aGF0YCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgaW5wdXQgYEVpdGhlcmAgdmFsdWUgdG8gY2hlY2sgYW5kIHBvdGVudGlhbGx5IHJldHVybi5cbiAqIEBwYXJhbSB0aGF0IC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBlcnJvciB2YWx1ZSBmcm9tIGBzZWxmYCAoaWYgaXQncyBhIGBMZWZ0YCkgYW5kIHJldHVybnMgYSBuZXcgYEVpdGhlcmAgdmFsdWUuXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRWxzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBpc0xlZnQoc2VsZikgPyB0aGF0KHNlbGYubGVmdCkgOiByaWdodChzZWxmLnJpZ2h0KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXRNYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gaXNMZWZ0KHNlbGYpID8gbGVmdChzZWxmLmxlZnQpIDogZihzZWxmLnJpZ2h0KSk7XG4vKipcbiAqIEV4ZWN1dGVzIGEgc2VxdWVuY2Ugb2YgdHdvIGBFaXRoZXJgcy4gVGhlIHNlY29uZCBgRWl0aGVyYCBjYW4gYmUgZGVwZW5kZW50IG9uIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGBFaXRoZXJgLlxuICpcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFuZFRoZW4gPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gZmxhdE1hcChzZWxmLCBhID0+IHtcbiAgY29uc3QgYiA9IGlzRnVuY3Rpb24oZikgPyBmKGEpIDogZjtcbiAgcmV0dXJuIGlzRWl0aGVyKGIpID8gYiA6IHJpZ2h0KGIpO1xufSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB6aXBXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRoYXQsIGYpID0+IGZsYXRNYXAoc2VsZiwgciA9PiBtYXAodGhhdCwgcjIgPT4gZihyLCByMikpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gemlwV2l0aChzZWxmLCB0aGF0LCAoZiwgYSkgPT4gZihhKSkpO1xuLyoqXG4gKiBUYWtlcyBhIHN0cnVjdHVyZSBvZiBgRWl0aGVyYHMgYW5kIHJldHVybnMgYW4gYEVpdGhlcmAgb2YgdmFsdWVzIHdpdGggdGhlIHNhbWUgc3RydWN0dXJlLlxuICpcbiAqIC0gSWYgYSB0dXBsZSBpcyBzdXBwbGllZCwgdGhlbiB0aGUgcmV0dXJuZWQgYEVpdGhlcmAgd2lsbCBjb250YWluIGEgdHVwbGUgd2l0aCB0aGUgc2FtZSBsZW5ndGguXG4gKiAtIElmIGEgc3RydWN0IGlzIHN1cHBsaWVkLCB0aGVuIHRoZSByZXR1cm5lZCBgRWl0aGVyYCB3aWxsIGNvbnRhaW4gYSBzdHJ1Y3Qgd2l0aCB0aGUgc2FtZSBrZXlzLlxuICogLSBJZiBhbiBpdGVyYWJsZSBpcyBzdXBwbGllZCwgdGhlbiB0aGUgcmV0dXJuZWQgYEVpdGhlcmAgd2lsbCBjb250YWluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgLSB0aGUgc3RydWN0IG9mIGBFaXRoZXJgcyB0byBiZSBzZXF1ZW5jZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmFsbChbRWl0aGVyLnJpZ2h0KDEpLCBFaXRoZXIucmlnaHQoMildKSwgRWl0aGVyLnJpZ2h0KFsxLCAyXSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5hbGwoeyByaWdodDogRWl0aGVyLnJpZ2h0KDEpLCBiOiBFaXRoZXIucmlnaHQoXCJoZWxsb1wiKSB9KSwgRWl0aGVyLnJpZ2h0KHsgcmlnaHQ6IDEsIGI6IFwiaGVsbG9cIiB9KSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmFsbCh7IHJpZ2h0OiBFaXRoZXIucmlnaHQoMSksIGI6IEVpdGhlci5sZWZ0KFwiZXJyb3JcIikgfSksIEVpdGhlci5sZWZ0KFwiZXJyb3JcIikpXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmV4cG9ydCBjb25zdCBhbGwgPSBpbnB1dCA9PiB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgaW5wdXQpIHtcbiAgICAgIGlmIChpc0xlZnQoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChlLnJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0KG91dCk7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGlucHV0KSkge1xuICAgIGNvbnN0IGUgPSBpbnB1dFtrZXldO1xuICAgIGlmIChpc0xlZnQoZSkpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBvdXRba2V5XSA9IGUucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIHJpZ2h0KG91dCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGBFaXRoZXJgIHRoYXQgc3dhcHMgdGhlIGVycm9yL3N1Y2Nlc3MgY2FzZXMuIFRoaXMgYWxsb3dzIHlvdSB0b1xuICogdXNlIGFsbCBtZXRob2RzIG9uIHRoZSBlcnJvciBjaGFubmVsLCBwb3NzaWJseSBiZWZvcmUgZmxpcHBpbmcgYmFjay5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwID0gc2VsZiA9PiBpc0xlZnQoc2VsZikgPyByaWdodChzZWxmLmxlZnQpIDogbGVmdChzZWxmLnJpZ2h0KTtcbmNvbnN0IGFkYXB0ZXIgPSAvKiNfX1BVUkVfXyovR2VuLmFkYXB0ZXIoKTtcbi8qKlxuICogQGNhdGVnb3J5IGdlbmVyYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2VuID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgZiA9IGFyZ3MubGVuZ3RoID09PSAxID8gYXJnc1swXSA6IGFyZ3NbMV0uYmluZChhcmdzWzBdKTtcbiAgY29uc3QgaXRlcmF0b3IgPSBmKGFkYXB0ZXIpO1xuICBsZXQgc3RhdGUgPSBpdGVyYXRvci5uZXh0KCk7XG4gIGlmIChzdGF0ZS5kb25lKSB7XG4gICAgcmV0dXJuIHJpZ2h0KHN0YXRlLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VycmVudCA9IHN0YXRlLnZhbHVlO1xuICAgIGlmIChHZW4uaXNHZW5LaW5kKGN1cnJlbnQpKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCA9IEdlbi55aWVsZFdyYXBHZXQoY3VycmVudCk7XG4gICAgfVxuICAgIGlmIChpc0xlZnQoY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICB3aGlsZSAoIXN0YXRlLmRvbmUpIHtcbiAgICAgIHN0YXRlID0gaXRlcmF0b3IubmV4dChjdXJyZW50LnJpZ2h0KTtcbiAgICAgIGlmICghc3RhdGUuZG9uZSkge1xuICAgICAgICBjdXJyZW50ID0gc3RhdGUudmFsdWU7XG4gICAgICAgIGlmIChHZW4uaXNHZW5LaW5kKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IEdlbi55aWVsZFdyYXBHZXQoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGVmdChjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaWdodChzdGF0ZS52YWx1ZSk7XG4gIH1cbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkbyBub3RhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgRWl0aGVyYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kfVxuICogQHNlZSB7QGxpbmsgYmluZFRvfVxuICogQHNlZSB7QGxpbmsgbGV0XyBsZXR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciwgcGlwZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpcGUoXG4gKiAgIEVpdGhlci5EbyxcbiAqICAgRWl0aGVyLmJpbmQoXCJ4XCIsICgpID0+IEVpdGhlci5yaWdodCgyKSksXG4gKiAgIEVpdGhlci5iaW5kKFwieVwiLCAoKSA9PiBFaXRoZXIucmlnaHQoMykpLFxuICogICBFaXRoZXIubGV0KFwic3VtXCIsICh7IHgsIHkgfSkgPT4geCArIHkpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgRWl0aGVyLnJpZ2h0KHsgeDogMiwgeTogMywgc3VtOiA1IH0pKVxuICpcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBEbyA9IC8qI19fUFVSRV9fKi9yaWdodCh7fSk7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBpbiBFZmZlY3QgYWxsb3dzIHlvdSB0byB3cml0ZSBjb2RlIGluIGEgbW9yZSBkZWNsYXJhdGl2ZSBzdHlsZSwgc2ltaWxhciB0byB0aGUgXCJkbyBub3RhdGlvblwiIGluIG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcy4gSXQgcHJvdmlkZXMgYSB3YXkgdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYGJpbmRgIGFuZCBgbGV0YC5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBFaXRoZXJgIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICpcbiAqIEBzZWUge0BsaW5rIERvfVxuICogQHNlZSB7QGxpbmsgYmluZFRvfVxuICogQHNlZSB7QGxpbmsgbGV0XyBsZXR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEVpdGhlciwgcGlwZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpcGUoXG4gKiAgIEVpdGhlci5EbyxcbiAqICAgRWl0aGVyLmJpbmQoXCJ4XCIsICgpID0+IEVpdGhlci5yaWdodCgyKSksXG4gKiAgIEVpdGhlci5iaW5kKFwieVwiLCAoKSA9PiBFaXRoZXIucmlnaHQoMykpLFxuICogICBFaXRoZXIubGV0KFwic3VtXCIsICh7IHgsIHkgfSkgPT4geCArIHkpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgRWl0aGVyLnJpZ2h0KHsgeDogMiwgeTogMywgc3VtOiA1IH0pKVxuICpcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kID0gLyojX19QVVJFX18qL2RvTm90YXRpb24uYmluZChtYXAsIGZsYXRNYXApO1xuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgRWl0aGVyYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqXG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGJpbmR9XG4gKiBAc2VlIHtAbGluayBsZXRfIGxldH1cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgRWl0aGVyLkRvLFxuICogICBFaXRoZXIuYmluZChcInhcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDIpKSxcbiAqICAgRWl0aGVyLmJpbmQoXCJ5XCIsICgpID0+IEVpdGhlci5yaWdodCgzKSksXG4gKiAgIEVpdGhlci5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBFaXRoZXIucmlnaHQoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRUbyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmJpbmRUbyhtYXApO1xuY29uc3QgbGV0XyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmxldF8obWFwKTtcbmV4cG9ydCB7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBpbiBFZmZlY3QgYWxsb3dzIHlvdSB0byB3cml0ZSBjb2RlIGluIGEgbW9yZSBkZWNsYXJhdGl2ZSBzdHlsZSwgc2ltaWxhciB0byB0aGUgXCJkbyBub3RhdGlvblwiIGluIG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcy4gSXQgcHJvdmlkZXMgYSB3YXkgdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYGJpbmRgIGFuZCBgbGV0YC5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBFaXRoZXJgIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICpcbiAqIEBzZWUge0BsaW5rIERvfVxuICogQHNlZSB7QGxpbmsgYmluZFRvfVxuICogQHNlZSB7QGxpbmsgYmluZH1cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgRWl0aGVyLkRvLFxuICogICBFaXRoZXIuYmluZChcInhcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDIpKSxcbiAqICAgRWl0aGVyLmJpbmQoXCJ5XCIsICgpID0+IEVpdGhlci5yaWdodCgzKSksXG4gKiAgIEVpdGhlci5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBFaXRoZXIucmlnaHQoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xubGV0XyBhcyBsZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVpdGhlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Either.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Encoding.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Encoding.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeException: () => (/* binding */ DecodeException),\n/* harmony export */   DecodeExceptionTypeId: () => (/* binding */ DecodeExceptionTypeId),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   decodeBase64String: () => (/* binding */ decodeBase64String),\n/* harmony export */   decodeBase64Url: () => (/* binding */ decodeBase64Url),\n/* harmony export */   decodeBase64UrlString: () => (/* binding */ decodeBase64UrlString),\n/* harmony export */   decodeHex: () => (/* binding */ decodeHex),\n/* harmony export */   decodeHexString: () => (/* binding */ decodeHexString),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   encodeBase64Url: () => (/* binding */ encodeBase64Url),\n/* harmony export */   encodeHex: () => (/* binding */ encodeHex),\n/* harmony export */   isDecodeException: () => (/* binding */ isDecodeException)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/encoding/base64.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\");\n/* harmony import */ var _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/encoding/base64Url.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js\");\n/* harmony import */ var _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/encoding/common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n/* harmony import */ var _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/encoding/hex.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js\");\n/**\n * This module provides encoding & decoding functionality for:\n *\n * - base64 (RFC4648)\n * - base64 (URL)\n * - hex\n *\n * @since 2.0.0\n */\n\n\n\n\n\n/**\n * Encodes the given value into a base64 (RFC4648) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nconst encodeBase64 = input => typeof input === \"string\" ? _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(input);\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeBase64 = str => _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.decode(str);\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeBase64String = str => _Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeBase64(str), _ => _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * Encodes the given value into a base64 (URL) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nconst encodeBase64Url = input => typeof input === \"string\" ? _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.encode(input);\n/**\n * Decodes a base64 (URL) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeBase64Url = str => _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.decode(str);\n/**\n * Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeBase64UrlString = str => _Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeBase64Url(str), _ => _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * Encodes the given value into a hex `string`.\n *\n * @category encoding\n * @since 2.0.0\n */\nconst encodeHex = input => typeof input === \"string\" ? _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.encode(input);\n/**\n * Decodes a hex encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeHex = str => _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.decode(str);\n/**\n * Decodes a hex encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */\nconst decodeHexString = str => _Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeHex(str), _ => _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst DecodeExceptionTypeId = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeExceptionTypeId;\n/**\n * Creates a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category errors\n */\nconst DecodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException;\n/**\n * Returns `true` if the specified value is an `DecodeException`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nconst isDecodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.isDecodeException;\n//# sourceMappingURL=Encoding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ2tCO0FBQ007QUFDTjtBQUNOO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBEQUEwRCxnRUFBYSxDQUFDLGlFQUFjLGtCQUFrQixnRUFBYTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsZ0VBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLDJDQUFVLHlCQUF5QixpRUFBYztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2REFBNkQsbUVBQWdCLENBQUMsaUVBQWMsa0JBQWtCLG1FQUFnQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsbUVBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQywyQ0FBVSw0QkFBNEIsaUVBQWM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdURBQXVELDZEQUFVLENBQUMsaUVBQWMsa0JBQWtCLDZEQUFVO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw2REFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMkNBQVUsc0JBQXNCLGlFQUFjO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLCtFQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IseUVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQiwyRUFBd0I7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vRW5jb2RpbmcuanM/NGI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGVuY29kaW5nICYgZGVjb2RpbmcgZnVuY3Rpb25hbGl0eSBmb3I6XG4gKlxuICogLSBiYXNlNjQgKFJGQzQ2NDgpXG4gKiAtIGJhc2U2NCAoVVJMKVxuICogLSBoZXhcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgRWl0aGVyIGZyb20gXCIuL0VpdGhlci5qc1wiO1xuaW1wb3J0ICogYXMgQmFzZTY0IGZyb20gXCIuL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NC5qc1wiO1xuaW1wb3J0ICogYXMgQmFzZTY0VXJsIGZyb20gXCIuL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NFVybC5qc1wiO1xuaW1wb3J0ICogYXMgQ29tbW9uIGZyb20gXCIuL2ludGVybmFsL2VuY29kaW5nL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gXCIuL2ludGVybmFsL2VuY29kaW5nL2hleC5qc1wiO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgYmFzZTY0IChSRkM0NjQ4KSBgc3RyaW5nYC5cbiAqXG4gKiBAY2F0ZWdvcnkgZW5jb2RpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQmFzZTY0ID0gaW5wdXQgPT4gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gQmFzZTY0LmVuY29kZShDb21tb24uZW5jb2Rlci5lbmNvZGUoaW5wdXQpKSA6IEJhc2U2NC5lbmNvZGUoaW5wdXQpO1xuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0IChSRkM0NjQ4KSBlbmNvZGVkIGBzdHJpbmdgIGludG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUJhc2U2NCA9IHN0ciA9PiBCYXNlNjQuZGVjb2RlKHN0cik7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgKFJGQzQ2NDgpIGVuY29kZWQgYHN0cmluZ2AgaW50byBhIFVURi04IGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVCYXNlNjRTdHJpbmcgPSBzdHIgPT4gRWl0aGVyLm1hcChkZWNvZGVCYXNlNjQoc3RyKSwgXyA9PiBDb21tb24uZGVjb2Rlci5kZWNvZGUoXykpO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgYmFzZTY0IChVUkwpIGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBlbmNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVCYXNlNjRVcmwgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBCYXNlNjRVcmwuZW5jb2RlKENvbW1vbi5lbmNvZGVyLmVuY29kZShpbnB1dCkpIDogQmFzZTY0VXJsLmVuY29kZShpbnB1dCk7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgKFVSTCkgZW5jb2RlZCBgc3RyaW5nYCBpbnRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVCYXNlNjRVcmwgPSBzdHIgPT4gQmFzZTY0VXJsLmRlY29kZShzdHIpO1xuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0IChVUkwpIGVuY29kZWQgYHN0cmluZ2AgaW50byBhIFVURi04IGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVCYXNlNjRVcmxTdHJpbmcgPSBzdHIgPT4gRWl0aGVyLm1hcChkZWNvZGVCYXNlNjRVcmwoc3RyKSwgXyA9PiBDb21tb24uZGVjb2Rlci5kZWNvZGUoXykpO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgaGV4IGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBlbmNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVIZXggPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBIZXguZW5jb2RlKENvbW1vbi5lbmNvZGVyLmVuY29kZShpbnB1dCkpIDogSGV4LmVuY29kZShpbnB1dCk7XG4vKipcbiAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBgc3RyaW5nYCBpbnRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVIZXggPSBzdHIgPT4gSGV4LmRlY29kZShzdHIpO1xuLyoqXG4gKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgYHN0cmluZ2AgaW50byBhIFVURi04IGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVIZXhTdHJpbmcgPSBzdHIgPT4gRWl0aGVyLm1hcChkZWNvZGVIZXgoc3RyKSwgXyA9PiBDb21tb24uZGVjb2Rlci5kZWNvZGUoXykpO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb25UeXBlSWQgPSBDb21tb24uRGVjb2RlRXhjZXB0aW9uVHlwZUlkO1xuLyoqXG4gKiBDcmVhdGVzIGEgY2hlY2tlZCBleGNlcHRpb24gd2hpY2ggb2NjdXJzIHdoZW4gZGVjb2RpbmcgZmFpbHMuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb24gPSBDb21tb24uRGVjb2RlRXhjZXB0aW9uO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGBEZWNvZGVFeGNlcHRpb25gLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSByZWZpbmVtZW50c1xuICovXG5leHBvcnQgY29uc3QgaXNEZWNvZGVFeGNlcHRpb24gPSBDb21tb24uaXNEZWNvZGVFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbmNvZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Equal.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Equal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   equivalence: () => (/* binding */ equivalence),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n\n\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"effect/Equal\");\nfunction equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if (selfType === \"object\" || selfType === \"function\") {\n    if (self !== null && that !== null) {\n      if (isEqual(self) && isEqual(that)) {\n        if (_Hash_js__WEBPACK_IMPORTED_MODULE_0__.hash(self) === _Hash_js__WEBPACK_IMPORTED_MODULE_0__.hash(that) && self[symbol](that)) {\n          return true;\n        } else {\n          return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled && _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n        }\n      } else if (self instanceof Date && that instanceof Date) {\n        return self.toISOString() === that.toISOString();\n      }\n    }\n    if (_Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled) {\n      if (Array.isArray(self) && Array.isArray(that)) {\n        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));\n      }\n      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {\n        const keysSelf = Object.keys(self);\n        const keysThat = Object.keys(that);\n        if (keysSelf.length === keysThat.length) {\n          for (const key of keysSelf) {\n            // @ts-expect-error\n            if (!(key in that && compareBoth(self[key], that[key]))) {\n              return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n            }\n          }\n          return true;\n        }\n      }\n      return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n    }\n  }\n  return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled && _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n}\n/**\n * @since 2.0.0\n * @category guards\n */\nconst isEqual = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(u, symbol);\n/**\n * @since 2.0.0\n * @category instances\n */\nconst equivalence = () => equals;\n//# sourceMappingURL=Equal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0M7QUFDVztBQUNNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBUyxXQUFXLDBDQUFTO0FBQ3pDO0FBQ0EsVUFBVTtBQUNWLGlCQUFpQiw0REFBcUIsWUFBWSw0REFBcUIsVUFBVSw0REFBcUI7QUFDdEc7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQXFCLFVBQVUsNERBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFxQixVQUFVLDREQUFxQjtBQUNqRTtBQUNBO0FBQ0EsU0FBUyw0REFBcUIsWUFBWSw0REFBcUIsVUFBVSw0REFBcUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vRXF1YWwuanM/MDU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gXCIuL0hhc2guanNcIjtcbmltcG9ydCB7IGhhc1Byb3BlcnR5IH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgeyBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUgfSBmcm9tIFwiLi9VdGlscy5qc1wiO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9FcXVhbFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNlbGYgPT4gY29tcGFyZUJvdGgoc2VsZiwgYXJndW1lbnRzWzBdKTtcbiAgfVxuICByZXR1cm4gY29tcGFyZUJvdGgoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xufVxuZnVuY3Rpb24gY29tcGFyZUJvdGgoc2VsZiwgdGhhdCkge1xuICBpZiAoc2VsZiA9PT0gdGhhdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGZUeXBlID0gdHlwZW9mIHNlbGY7XG4gIGlmIChzZWxmVHlwZSAhPT0gdHlwZW9mIHRoYXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNlbGZUeXBlID09PSBcIm9iamVjdFwiIHx8IHNlbGZUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoc2VsZiAhPT0gbnVsbCAmJiB0aGF0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNFcXVhbChzZWxmKSAmJiBpc0VxdWFsKHRoYXQpKSB7XG4gICAgICAgIGlmIChIYXNoLmhhc2goc2VsZikgPT09IEhhc2guaGFzaCh0aGF0KSAmJiBzZWxmW3N5bWJvbF0odGhhdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RydWN0dXJhbFJlZ2lvblN0YXRlLmVuYWJsZWQgJiYgc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlciA/IHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIoc2VsZiwgdGhhdCkgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxmIGluc3RhbmNlb2YgRGF0ZSAmJiB0aGF0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VsZi50b0lTT1N0cmluZygpID09PSB0aGF0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZikgJiYgQXJyYXkuaXNBcnJheSh0aGF0KSkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IHRoYXQubGVuZ3RoICYmIHNlbGYuZXZlcnkoKHYsIGkpID0+IGNvbXBhcmVCb3RoKHYsIHRoYXRbaV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VsZikgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlbGYpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGNvbnN0IGtleXNTZWxmID0gT2JqZWN0LmtleXMoc2VsZik7XG4gICAgICAgIGNvbnN0IGtleXNUaGF0ID0gT2JqZWN0LmtleXModGhhdCk7XG4gICAgICAgIGlmIChrZXlzU2VsZi5sZW5ndGggPT09IGtleXNUaGF0Lmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNTZWxmKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhhdCAmJiBjb21wYXJlQm90aChzZWxmW2tleV0sIHRoYXRba2V5XSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID8gc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlcihzZWxmLCB0aGF0KSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIgPyBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyKHNlbGYsIHRoYXQpIDogZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCAmJiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID8gc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlcihzZWxmLCB0aGF0KSA6IGZhbHNlO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSB1ID0+IGhhc1Byb3BlcnR5KHUsIHN5bWJvbCk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICovXG5leHBvcnQgY29uc3QgZXF1aXZhbGVuY2UgPSAoKSA9PiBlcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcXVhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Equivalence.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Equivalence.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Date: () => (/* binding */ Date),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   combineAll: () => (/* binding */ combineAll),\n/* harmony export */   combineMany: () => (/* binding */ combineMany),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   tuple: () => (/* binding */ tuple)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);\nconst isStrictEquivalent = (x, y) => x === y;\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 2.0.0\n * @category constructors\n */\nconst strict = () => isStrictEquivalent;\n/**\n * @category instances\n * @since 2.0.0\n */\nconst string = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nconst number = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nconst boolean = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nconst bigint = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nconst symbol = /*#__PURE__*/strict();\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combine = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineMany = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection) => make((x, y) => {\n  if (!self(x, y)) {\n    return false;\n  }\n  for (const equivalence of collection) {\n    if (!equivalence(x, y)) {\n      return false;\n    }\n  }\n  return true;\n}));\nconst isAlwaysEquivalent = (_x, _y) => true;\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineAll = collection => combineMany(isAlwaysEquivalent, collection);\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f) => make((x, y) => self(f(x), f(y))));\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const equivalence of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      if (!equivalence(x[collectionLength], y[collectionLength])) {\n        return false;\n      }\n      collectionLength++;\n    }\n    return true;\n  });\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  const equivalence = all(collection);\n  return make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));\n};\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n/**\n * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst array = item => make((self, that) => {\n  if (self.length !== that.length) {\n    return false;\n  }\n  for (let i = 0; i < self.length; i++) {\n    const isEq = item(self[i], that[i]);\n    if (!isEq) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      if (!fields[key](self[key], that[key])) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\n//# sourceMappingURL=Equivalence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VxdWl2YWxlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsa0RBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsa0RBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLGtEQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixrREFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9FcXVpdmFsZW5jZS5qcz9mMDllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBFcXVpdmFsZW5jZWAgdHlwZSBjbGFzcywgd2hpY2ggZGVmaW5lcyBhIGJpbmFyeSByZWxhdGlvblxuICogdGhhdCBpcyByZWZsZXhpdmUsIHN5bW1ldHJpYywgYW5kIHRyYW5zaXRpdmUuIEluIG90aGVyIHdvcmRzLCBpdCBkZWZpbmVzIGEgbm90aW9uIG9mIGVxdWl2YWxlbmNlIGJldHdlZW4gdmFsdWVzIG9mIGEgY2VydGFpbiB0eXBlLlxuICogVGhlc2UgcHJvcGVydGllcyBhcmUgYWxzbyBrbm93biBpbiBtYXRoZW1hdGljcyBhcyBhbiBcImVxdWl2YWxlbmNlIHJlbGF0aW9uXCIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCB7IGR1YWwgfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2UgPSBpc0VxdWl2YWxlbnQgPT4gKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgfHwgaXNFcXVpdmFsZW50KHNlbGYsIHRoYXQpO1xuY29uc3QgaXNTdHJpY3RFcXVpdmFsZW50ID0gKHgsIHkpID0+IHggPT09IHk7XG4vKipcbiAqIFJldHVybiBhbiBgRXF1aXZhbGVuY2VgIHRoYXQgdXNlcyBzdHJpY3QgZXF1YWxpdHkgKD09PSkgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpY3QgPSAoKSA9PiBpc1N0cmljdEVxdWl2YWxlbnQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5nID0gLyojX19QVVJFX18qL3N0cmljdCgpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IC8qI19fUFVSRV9fKi9zdHJpY3QoKTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBib29sZWFuID0gLyojX19QVVJFX18qL3N0cmljdCgpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpZ2ludCA9IC8qI19fUFVSRV9fKi9zdHJpY3QoKTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovc3RyaWN0KCk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tYmluZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBtYWtlKCh4LCB5KSA9PiBzZWxmKHgsIHkpICYmIHRoYXQoeCwgeSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lTWFueSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBjb2xsZWN0aW9uKSA9PiBtYWtlKCh4LCB5KSA9PiB7XG4gIGlmICghc2VsZih4LCB5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGVxdWl2YWxlbmNlIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoIWVxdWl2YWxlbmNlKHgsIHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSkpO1xuY29uc3QgaXNBbHdheXNFcXVpdmFsZW50ID0gKF94LCBfeSkgPT4gdHJ1ZTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lQWxsID0gY29sbGVjdGlvbiA9PiBjb21iaW5lTWFueShpc0Fsd2F5c0VxdWl2YWxlbnQsIGNvbGxlY3Rpb24pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJbnB1dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBtYWtlKCh4LCB5KSA9PiBzZWxmKGYoeCksIGYoeSkpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgRGF0ZSA9IC8qI19fUFVSRV9fKi9tYXBJbnB1dChudW1iZXIsIGRhdGUgPT4gZGF0ZS5nZXRUaW1lKCkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3QgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gbWFrZSgoW3hhLCB4Yl0sIFt5YSwgeWJdKSA9PiBzZWxmKHhhLCB5YSkgJiYgdGhhdCh4YiwgeWIpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWxsID0gY29sbGVjdGlvbiA9PiB7XG4gIHJldHVybiBtYWtlKCh4LCB5KSA9PiB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBsZXQgY29sbGVjdGlvbkxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBlcXVpdmFsZW5jZSBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbkxlbmd0aCA+PSBsZW4pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWVxdWl2YWxlbmNlKHhbY29sbGVjdGlvbkxlbmd0aF0sIHlbY29sbGVjdGlvbkxlbmd0aF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbGxlY3Rpb25MZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0TWFueSA9IChzZWxmLCBjb2xsZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGVxdWl2YWxlbmNlID0gYWxsKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gbWFrZSgoeCwgeSkgPT4gIXNlbGYoeFswXSwgeVswXSkgPyBmYWxzZSA6IGVxdWl2YWxlbmNlKHguc2xpY2UoMSksIHkuc2xpY2UoMSkpKTtcbn07XG4vKipcbiAqIFNpbWlsYXIgdG8gYFByb21pc2UuYWxsYCBidXQgb3BlcmF0ZXMgb24gYEVxdWl2YWxlbmNlYHMuXG4gKlxuICogYGBgXG4gKiBbRXF1aXZhbGVuY2U8QT4sIEVxdWl2YWxlbmNlPEI+LCAuLi5dIC0+IEVxdWl2YWxlbmNlPFtBLCBCLCAuLi5dPlxuICogYGBgXG4gKlxuICogR2l2ZW4gYSB0dXBsZSBvZiBgRXF1aXZhbGVuY2VgcyByZXR1cm5zIGEgbmV3IGBFcXVpdmFsZW5jZWAgdGhhdCBjb21wYXJlcyB2YWx1ZXMgb2YgYSB0dXBsZVxuICogYnkgYXBwbHlpbmcgZWFjaCBgRXF1aXZhbGVuY2VgIHRvIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZSA9ICguLi5lbGVtZW50cykgPT4gYWxsKGVsZW1lbnRzKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgRXF1aXZhbGVuY2VgIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMgYmFzZWQgb24gYSBnaXZlbiBgRXF1aXZhbGVuY2VgIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcnJheSA9IGl0ZW0gPT4gbWFrZSgoc2VsZiwgdGhhdCkgPT4ge1xuICBpZiAoc2VsZi5sZW5ndGggIT09IHRoYXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlzRXEgPSBpdGVtKHNlbGZbaV0sIHRoYXRbaV0pO1xuICAgIGlmICghaXNFcSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBHaXZlbiBhIHN0cnVjdCBvZiBgRXF1aXZhbGVuY2VgcyByZXR1cm5zIGEgbmV3IGBFcXVpdmFsZW5jZWAgdGhhdCBjb21wYXJlcyB2YWx1ZXMgb2YgYSBzdHJ1Y3RcbiAqIGJ5IGFwcGx5aW5nIGVhY2ggYEVxdWl2YWxlbmNlYCB0byB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvZiB0aGUgc3RydWN0LlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJ1Y3QgPSBmaWVsZHMgPT4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgcmV0dXJuIG1ha2UoKHNlbGYsIHRoYXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWZpZWxkc1trZXldKHNlbGZba2V5XSwgdGhhdFtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcXVpdmFsZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Equivalence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Function.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Function.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SK: () => (/* binding */ SK),\n/* harmony export */   absurd: () => (/* binding */ absurd),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   constFalse: () => (/* binding */ constFalse),\n/* harmony export */   constNull: () => (/* binding */ constNull),\n/* harmony export */   constTrue: () => (/* binding */ constTrue),\n/* harmony export */   constUndefined: () => (/* binding */ constUndefined),\n/* harmony export */   constVoid: () => (/* binding */ constVoid),\n/* harmony export */   constant: () => (/* binding */ constant),\n/* harmony export */   dual: () => (/* binding */ dual),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   flow: () => (/* binding */ flow),\n/* harmony export */   hole: () => (/* binding */ hole),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   satisfies: () => (/* binding */ satisfies),\n/* harmony export */   tupled: () => (/* binding */ tupled),\n/* harmony export */   unsafeCoerce: () => (/* binding */ unsafeCoerce),\n/* harmony export */   untupled: () => (/* binding */ untupled)\n/* harmony export */ });\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isFunction = input => typeof input === \"function\";\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * import { dual, pipe } from \"effect/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * @since 2.0.0\n */\nconst dual = function (arity, body) {\n  if (typeof arity === \"function\") {\n    return function () {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments);\n      }\n      return self => body(self, ...arguments);\n    };\n  }\n  switch (arity) {\n    case 0:\n    case 1:\n      throw new RangeError(`Invalid arity ${arity}`);\n    case 2:\n      return function (a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b);\n        }\n        return function (self) {\n          return body(self, a);\n        };\n      };\n    case 3:\n      return function (a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c);\n        }\n        return function (self) {\n          return body(self, a, b);\n        };\n      };\n    case 4:\n      return function (a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d);\n        }\n        return function (self) {\n          return body(self, a, b, c);\n        };\n      };\n    case 5:\n      return function (a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e);\n        }\n        return function (self) {\n          return body(self, a, b, c, d);\n        };\n      };\n    default:\n      return function () {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments);\n        }\n        const args = arguments;\n        return function (self) {\n          return body(self, ...args);\n        };\n      };\n  }\n};\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from \"effect/String\"\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n *\n * @since 2.0.0\n */\nconst apply = a => self => self(a);\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n *\n * @since 2.0.0\n */\nconst identity = a => a;\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n *\n * @since 2.0.0\n */\nconst satisfies = () => b => b;\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n *\n * @since 2.0.0\n */\nconst unsafeCoerce = identity;\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nconst constant = value => () => value;\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n *\n * @since 2.0.0\n */\nconst constTrue = /*#__PURE__*/constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n *\n * @since 2.0.0\n */\nconst constFalse = /*#__PURE__*/constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nconst constNull = /*#__PURE__*/constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n *\n * @since 2.0.0\n */\nconst constUndefined = /*#__PURE__*/constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n *\n * @since 2.0.0\n */\nconst constVoid = constUndefined;\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 2.0.0\n */\nconst flip = f => (...b) => (...a) => f(...a)(...b);\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n *\n * @since 2.0.0\n */\nconst compose = /*#__PURE__*/dual(2, (ab, bc) => a => bc(ab(a)));\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nconst absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n *\n * @since 2.0.0\n */\nconst tupled = f => a => f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @example\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n *\n * @since 2.0.0\n */\nconst untupled = f => (...a) => f(a);\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nconst hole = /*#__PURE__*/unsafeCoerce(absurd);\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n *\n * @since 2.0.0\n */\nconst SK = (_, b) => b;\n//# sourceMappingURL=Function.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0Z1bmN0aW9uLmpzPzEwNGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYGZ1bmN0aW9uYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRnVuY3Rpb24oaXNGdW5jdGlvbiksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRnVuY3Rpb24oXCJmdW5jdGlvblwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gaW5wdXQgPT4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgZGF0YS1sYXN0IChha2EgYHBpcGVgYWJsZSkgb3JcbiAqIGRhdGEtZmlyc3Qgc3R5bGUuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciB0byBgZHVhbGAgaXMgZWl0aGVyIHRoZSBhcml0eSBvZiB0aGUgdW5jdXJyaWVkIGZ1bmN0aW9uXG4gKiBvciBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgaW4gYSBkYXRhLWZpcnN0XG4gKiBvciBkYXRhLWxhc3Qgc3R5bGUuXG4gKlxuICogVXNpbmcgdGhlIGFyaXR5IGlzIHRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZSwgYnV0IHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlXG4gKiB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgcHJlZGljYXRlLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiBvcHRpb25hbCBhcmd1bWVudCwgeW91IGNhbiB1c2UgYSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIGlmIHRoZVxuICogZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBpbiBhIGRhdGEtZmlyc3Qgb3IgZGF0YS1sYXN0IHN0eWxlLlxuICpcbiAqIEBwYXJhbSBhcml0eSAtIEVpdGhlciB0aGUgYXJpdHkgb2YgdGhlIHVuY3VycmllZCBmdW5jdGlvbiBvciBhIHByZWRpY2F0ZVxuICogICAgICAgICAgICAgICAgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBpbiBhIGRhdGEtZmlyc3RcbiAqICAgICAgICAgICAgICAgIG9yIGRhdGEtbGFzdCBzdHlsZS5cbiAqIEBwYXJhbSBib2R5IC0gVGhlIGRlZmluaXRpb24gb2YgdGhlIHVuY3VycmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZHVhbCwgcGlwZSB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIC8vIEV4YW1wZSB1c2luZyBhcml0eSB0byBkZXRlcm1pbmUgZGF0YS1maXJzdCBvciBkYXRhLWxhc3Qgc3R5bGVcbiAqIGNvbnN0IHN1bToge1xuICogICAodGhhdDogbnVtYmVyKTogKHNlbGY6IG51bWJlcikgPT4gbnVtYmVyXG4gKiAgIChzZWxmOiBudW1iZXIsIHRoYXQ6IG51bWJlcik6IG51bWJlclxuICogfSA9IGR1YWwoMiwgKHNlbGY6IG51bWJlciwgdGhhdDogbnVtYmVyKTogbnVtYmVyID0+IHNlbGYgKyB0aGF0KVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc3VtKDIsIDMpLCA1KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKDIsIHN1bSgzKSksIDUpXG4gKlxuICogLy8gRXhhbXBsZSB1c2luZyBhIHByZWRpY2F0ZSB0byBkZXRlcm1pbmUgZGF0YS1maXJzdCBvciBkYXRhLWxhc3Qgc3R5bGVcbiAqIGNvbnN0IHN1bTI6IHtcbiAqICAgKHRoYXQ6IG51bWJlcik6IChzZWxmOiBudW1iZXIpID0+IG51bWJlclxuICogICAoc2VsZjogbnVtYmVyLCB0aGF0OiBudW1iZXIpOiBudW1iZXJcbiAqIH0gPSBkdWFsKChhcmdzKSA9PiBhcmdzLmxlbmd0aCA9PT0gMSwgKHNlbGY6IG51bWJlciwgdGhhdDogbnVtYmVyKTogbnVtYmVyID0+IHNlbGYgKyB0aGF0KVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc3VtKDIsIDMpLCA1KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKDIsIHN1bSgzKSksIDUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkdWFsID0gZnVuY3Rpb24gKGFyaXR5LCBib2R5KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYXJpdHkoYXJndW1lbnRzKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZiA9PiBib2R5KHNlbGYsIC4uLmFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKGFyaXR5KSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGFyaXR5ICR7YXJpdHl9YCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjLCBkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiLCBjKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiLCBjLCBkKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkoc2VsZiwgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGEgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgdmFsdWUgdGhhdCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBhcHBsaWVkIHRvLlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byBhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBhcHBseSB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICogaW1wb3J0IHsgbGVuZ3RoIH0gZnJvbSBcImVmZmVjdC9TdHJpbmdcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShsZW5ndGgsIGFwcGx5KFwiaGVsbG9cIikpLCA1KVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBhID0+IHNlbGYgPT4gc2VsZihhKTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLCBpLmUuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0cyBpbnB1dCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBpbnB1dCBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlkZW50aXR5KDUpLCA1KVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBhID0+IGE7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBlbnN1cmVzIHRoYXQgdGhlIHR5cGUgb2YgYW4gZXhwcmVzc2lvbiBtYXRjaGVzIHNvbWUgdHlwZSxcbiAqIHdpdGhvdXQgY2hhbmdpbmcgdGhlIHJlc3VsdGluZyB0eXBlIG9mIHRoYXQgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2F0aXNmaWVzIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3QgdGVzdDEgPSBzYXRpc2ZpZXM8bnVtYmVyPigpKDUgYXMgY29uc3QpXG4gKiAgICAgLy9ePyBjb25zdCB0ZXN0OiA1XG4gKiAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICogY29uc3QgdGVzdDIgPSBzYXRpc2ZpZXM8c3RyaW5nPigpKDUpXG4gKiAgICAgLy9ePyBBcmd1bWVudCBvZiB0eXBlICdudW1iZXInIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHBhcmFtZXRlciBvZiB0eXBlICdzdHJpbmcnXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzYXRpc2ZpZXM8bnVtYmVyPigpKDUpLCA1KVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2F0aXNmaWVzID0gKCkgPT4gYiA9PiBiO1xuLyoqXG4gKiBDYXN0cyB0aGUgcmVzdWx0IHRvIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSB2YWx1ZSB0byBiZSBjYXN0ZWQgdG8gdGhlIHRhcmdldCB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB1bnNhZmVDb2VyY2UsIGlkZW50aXR5IH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh1bnNhZmVDb2VyY2UsIGlkZW50aXR5KVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdW5zYWZlQ29lcmNlID0gaWRlbnRpdHk7XG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSB0aGF0IG5ldmVyIGNoYW5nZXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwYXNzIGEgdmFsdWUgdG8gYSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gKGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbm90aGVyIGZ1bmN0aW9uIGFzIGl0cyBhcmd1bWVudClcbiAqIGFuZCB3YW50IHRoYXQgaW5uZXIgZnVuY3Rpb24gdG8gYWx3YXlzIHVzZSB0aGUgc2FtZSB2YWx1ZSwgbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgY29uc3RhbnQgdmFsdWUgdG8gYmUgcmV0dXJuZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbnN0YW50IH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3QgY29uc3ROdWxsID0gY29uc3RhbnQobnVsbClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbnN0TnVsbCgpLCBudWxsKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb25zdE51bGwoKSwgbnVsbClcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0YW50ID0gdmFsdWUgPT4gKCkgPT4gdmFsdWU7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbnN0VHJ1ZSB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29uc3RUcnVlKCksIHRydWUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb25zdFRydWUgPSAvKiNfX1BVUkVfXyovY29uc3RhbnQodHJ1ZSk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgZmFsc2VgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjb25zdEZhbHNlIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb25zdEZhbHNlKCksIGZhbHNlKVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29uc3RGYWxzZSA9IC8qI19fUFVSRV9fKi9jb25zdGFudChmYWxzZSk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgbnVsbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbnN0TnVsbCB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29uc3ROdWxsKCksIG51bGwpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb25zdE51bGwgPSAvKiNfX1BVUkVfXyovY29uc3RhbnQobnVsbCk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uc3RVbmRlZmluZWQgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbnN0VW5kZWZpbmVkKCksIHVuZGVmaW5lZClcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0VW5kZWZpbmVkID0gLyojX19QVVJFX18qL2NvbnN0YW50KHVuZGVmaW5lZCk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdm9pZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbnN0Vm9pZCB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29uc3RWb2lkKCksIHVuZGVmaW5lZClcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0Vm9pZCA9IGNvbnN0VW5kZWZpbmVkO1xuLyoqXG4gKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgYXJndW1lbnRzIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGYgLSBBIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBtdWx0aXBsZSBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGZsaXAgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBjb25zdCBmID0gKGE6IG51bWJlcikgPT4gKGI6IHN0cmluZykgPT4gYSAtIGIubGVuZ3RoXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChmbGlwKGYpKCdhYWEnKSgyKSwgLTEpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwID0gZiA9PiAoLi4uYikgPT4gKC4uLmEpID0+IGYoLi4uYSkoLi4uYik7XG4vKipcbiAqIENvbXBvc2VzIHR3byBmdW5jdGlvbnMsIGBhYmAgYW5kIGBiY2AgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIGFuIGFyZ3VtZW50IGBhYCBvZiB0eXBlIGBBYCBhbmQgcmV0dXJucyBhIHJlc3VsdCBvZiB0eXBlIGBDYC5cbiAqIFRoZSByZXN1bHQgaXMgb2J0YWluZWQgYnkgZmlyc3QgYXBwbHlpbmcgdGhlIGBhYmAgZnVuY3Rpb24gdG8gYGFgIGFuZCB0aGVuIGFwcGx5aW5nIHRoZSBgYmNgIGZ1bmN0aW9uIHRvIHRoZSByZXN1bHQgb2YgYGFiYC5cbiAqXG4gKiBAcGFyYW0gYWIgLSBBIGZ1bmN0aW9uIHRoYXQgbWFwcyBmcm9tIGBBYCB0byBgQmAuXG4gKiBAcGFyYW0gYmMgLSBBIGZ1bmN0aW9uIHRoYXQgbWFwcyBmcm9tIGBCYCB0byBgQ2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBjb25zdCBpbmNyZW1lbnQgPSAobjogbnVtYmVyKSA9PiBuICsgMTtcbiAqIGNvbnN0IHNxdWFyZSA9IChuOiBudW1iZXIpID0+IG4gKiBuO1xuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChjb21wb3NlKGluY3JlbWVudCwgc3F1YXJlKSgyKSwgOSk7XG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wb3NlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKGFiLCBiYykgPT4gYSA9PiBiYyhhYihhKSkpO1xuLyoqXG4gKiBUaGUgYGFic3VyZGAgZnVuY3Rpb24gaXMgYSBzdHViIGZvciBjYXNlcyB3aGVyZSBhIHZhbHVlIG9mIHR5cGUgYG5ldmVyYCBpcyBlbmNvdW50ZXJlZCBpbiB5b3VyIGNvZGUsXG4gKiBtZWFuaW5nIHRoYXQgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgZm9yIHRoaXMgY29kZSB0byBiZSBleGVjdXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHBhcnRpY3VsYXJseSB3aGVuIGl0J3MgbmVjZXNzYXJ5IHRvIHNwZWNpZnkgdGhhdCBjZXJ0YWluIGNhc2VzIGFyZSBpbXBvc3NpYmxlLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWJzdXJkID0gXyA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBgYWJzdXJkYCBmdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdW5jYWxsYWJsZVwiKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSB0dXBsZWQgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uOiBpbnN0ZWFkIG9mIGBuYCBhcmd1bWVudHMsIGl0IGFjY2VwdHMgYSBzaW5nbGUgdHVwbGUgYXJndW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHR1cGxlZCB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGNvbnN0IHN1bVR1cGxlZCA9IHR1cGxlZCgoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIgPT4geCArIHkpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzdW1UdXBsZWQoWzEsIDJdKSwgMylcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHR1cGxlZCA9IGYgPT4gYSA9PiBmKC4uLmEpO1xuLyoqXG4gKiBJbnZlcnNlIGZ1bmN0aW9uIG9mIGB0dXBsZWRgXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHVudHVwbGVkIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3QgZ2V0Rmlyc3QgPSB1bnR1cGxlZCg8QSwgQj4odHVwbGU6IFtBLCBCXSk6IEEgPT4gdHVwbGVbMF0pXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChnZXRGaXJzdCgxLCAyKSwgMSlcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHVudHVwbGVkID0gZiA9PiAoLi4uYSkgPT4gZihhKTtcbmV4cG9ydCBmdW5jdGlvbiBwaXBlKGEsIGFiLCBiYywgY2QsIGRlLCBlZiwgZmcsIGdoLCBoaSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gYWIoYSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGJjKGFiKGEpKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gY2QoYmMoYWIoYSkpKTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZGUoY2QoYmMoYWIoYSkpKSk7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGVmKGRlKGNkKGJjKGFiKGEpKSkpKTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKSk7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIGhpKGdoKGZnKGVmKGRlKGNkKGJjKGFiKGEpKSkpKSkpKTtcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBsZXQgcmV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJldCA9IGFyZ3VtZW50c1tpXShyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmbG93KGFiLCBiYywgY2QsIGRlLCBlZiwgZmcsIGdoLCBoaSwgaWopIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGFiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlZihkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpKTtcbiAgICAgIH07XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKTtcbiAgICAgIH07XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdoKGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoaShnaChmZyhlZihkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpKSkpKTtcbiAgICAgIH07XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlqKGhpKGdoKGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKSkpKTtcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBUeXBlIGhvbGUgc2ltdWxhdGlvbi5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGhvbGUgPSAvKiNfX1BVUkVfXyovdW5zYWZlQ29lcmNlKGFic3VyZCk7XG4vKipcbiAqIFRoZSBTSyBjb21iaW5hdG9yLCBhbHNvIGtub3duIGFzIHRoZSBcIlMtSyBjb21iaW5hdG9yXCIgb3IgXCJTLWNvbWJpbmF0b3JcIiwgaXMgYSBmdW5kYW1lbnRhbCBjb21iaW5hdG9yIGluIHRoZVxuICogbGFtYmRhIGNhbGN1bHVzIGFuZCB0aGUgU0tJIGNvbWJpbmF0b3IgY2FsY3VsdXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgZm9yIGRpc2NhcmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBpdCBhbmQgcmV0dXJuaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIF8gLSBUaGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgZGlzY2FyZGVkLlxuICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTSyB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIjtcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFNLKDAsIFwiaGVsbG9cIiksIFwiaGVsbG9cIilcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IFNLID0gKF8sIGIpID0+IGI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Function.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/GlobalValue.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/GlobalValue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalValue: () => (/* binding */ globalValue)\n/* harmony export */ });\n/* harmony import */ var _internal_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/version.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/version.js\");\n/**\n * @since 2.0.0\n */\n\nconst globalStoreId = /*#__PURE__*/Symbol.for(`effect/GlobalValue/globalStoreId/${/*#__PURE__*/_internal_version_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentVersion()}`);\nif (!(globalStoreId in globalThis)) {\n  ;\n  globalThis[globalStoreId] = /*#__PURE__*/new Map();\n}\nconst globalStore = globalThis[globalStoreId];\n/**\n * @since 2.0.0\n */\nconst globalValue = (id, compute) => {\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute());\n  }\n  return globalStore.get(id);\n};\n//# sourceMappingURL=GlobalValue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0dsb2JhbFZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2lEO0FBQ2pELGtGQUFrRixhQUFhLG1FQUF5QixHQUFHO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9HbG9iYWxWYWx1ZS5qcz9jZDljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCAqIGFzIHZlcnNpb24gZnJvbSBcIi4vaW50ZXJuYWwvdmVyc2lvbi5qc1wiO1xuY29uc3QgZ2xvYmFsU3RvcmVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKGBlZmZlY3QvR2xvYmFsVmFsdWUvZ2xvYmFsU3RvcmVJZC8key8qI19fUFVSRV9fKi92ZXJzaW9uLmdldEN1cnJlbnRWZXJzaW9uKCl9YCk7XG5pZiAoIShnbG9iYWxTdG9yZUlkIGluIGdsb2JhbFRoaXMpKSB7XG4gIDtcbiAgZ2xvYmFsVGhpc1tnbG9iYWxTdG9yZUlkXSA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG59XG5jb25zdCBnbG9iYWxTdG9yZSA9IGdsb2JhbFRoaXNbZ2xvYmFsU3RvcmVJZF07XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2xvYmFsVmFsdWUgPSAoaWQsIGNvbXB1dGUpID0+IHtcbiAgaWYgKCFnbG9iYWxTdG9yZS5oYXMoaWQpKSB7XG4gICAgZ2xvYmFsU3RvcmUuc2V0KGlkLCBjb21wdXRlKCkpO1xuICB9XG4gIHJldHVybiBnbG9iYWxTdG9yZS5nZXQoaWQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsb2JhbFZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Hash.js":
/*!**********************************************!*\
  !*** ./node_modules/effect/dist/esm/Hash.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   cached: () => (/* binding */ cached),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   optimize: () => (/* binding */ optimize),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   structure: () => (/* binding */ structure),\n/* harmony export */   structureKeys: () => (/* binding */ structureKeys),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/**\n * @since 2.0.0\n */\n\n\n\n\n/** @internal */\nconst randomHashCache = /*#__PURE__*/(0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__.globalValue)( /*#__PURE__*/Symbol.for(\"effect/Hash/randomHashCache\"), () => new WeakMap());\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"effect/Hash\");\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst hash = self => {\n  if (_Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled === true) {\n    return 0;\n  }\n  switch (typeof self) {\n    case \"number\":\n      return number(self);\n    case \"bigint\":\n      return string(self.toString(10));\n    case \"boolean\":\n      return string(String(self));\n    case \"symbol\":\n      return string(String(self));\n    case \"string\":\n      return string(self);\n    case \"undefined\":\n      return string(\"undefined\");\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        } else if (self instanceof Date) {\n          return hash(self.toISOString());\n        } else if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          return random(self);\n        }\n      }\n    default:\n      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);\n  }\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst combine = b => self => self * 53 ^ b;\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 2.0.0\n * @category guards\n */\nconst isHash = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(u, symbol);\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst structureKeys = (o, keys) => {\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= (0,_Function_js__WEBPACK_IMPORTED_MODULE_3__.pipe)(string(keys[i]), combine(hash(o[keys[i]])));\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst structure = o => structureKeys(o, Object.keys(o));\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = (0,_Function_js__WEBPACK_IMPORTED_MODULE_3__.pipe)(h, combine(hash(arr[i])));\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nconst cached = function () {\n  if (arguments.length === 1) {\n    const self = arguments[0];\n    return function (hash) {\n      Object.defineProperty(self, symbol, {\n        value() {\n          return hash;\n        },\n        enumerable: false\n      });\n      return hash;\n    };\n  }\n  const self = arguments[0];\n  const hash = arguments[1];\n  Object.defineProperty(self, symbol, {\n    value() {\n      return hash;\n    },\n    enumerable: false\n  });\n  return hash;\n};\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNxQztBQUNVO0FBQ0Y7QUFDTTtBQUNuRDtBQUNBLHFDQUFxQyw0REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLE1BQU0sNERBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0JBQW9CLDBEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DLFNBQVMsa0RBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxRQUFRLGtEQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9IYXNoLmpzPzM4ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuL0dsb2JhbFZhbHVlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSB9IGZyb20gXCIuL1ByZWRpY2F0ZS5qc1wiO1xuaW1wb3J0IHsgc3RydWN0dXJhbFJlZ2lvblN0YXRlIH0gZnJvbSBcIi4vVXRpbHMuanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHJhbmRvbUhhc2hDYWNoZSA9IC8qI19fUFVSRV9fKi9nbG9iYWxWYWx1ZSggLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvSGFzaC9yYW5kb21IYXNoQ2FjaGVcIiksICgpID0+IG5ldyBXZWFrTWFwKCkpO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9IYXNoXCIpO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoID0gc2VsZiA9PiB7XG4gIGlmIChzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHNlbGYpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gbnVtYmVyKHNlbGYpO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBzdHJpbmcoc2VsZi50b1N0cmluZygxMCkpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gc3RyaW5nKFN0cmluZyhzZWxmKSk7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIHN0cmluZyhTdHJpbmcoc2VsZikpO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBzdHJpbmcoc2VsZik7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIHN0cmluZyhcInVuZGVmaW5lZFwiKTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIGlmIChzZWxmID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZyhcIm51bGxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaGFzaChzZWxmLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGFzaChzZWxmKSkge1xuICAgICAgICAgIHJldHVybiBzZWxmW3N5bWJvbF0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiB1bmhhbmRsZWQgdHlwZW9mICR7dHlwZW9mIHNlbGZ9IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNgKTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgcmFuZG9tID0gc2VsZiA9PiB7XG4gIGlmICghcmFuZG9tSGFzaENhY2hlLmhhcyhzZWxmKSkge1xuICAgIHJhbmRvbUhhc2hDYWNoZS5zZXQoc2VsZiwgbnVtYmVyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkpO1xuICB9XG4gIHJldHVybiByYW5kb21IYXNoQ2FjaGUuZ2V0KHNlbGYpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgY29tYmluZSA9IGIgPT4gc2VsZiA9PiBzZWxmICogNTMgXiBiO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBvcHRpbWl6ZSA9IG4gPT4gbiAmIDB4YmZmZmZmZmYgfCBuID4+PiAxICYgMHg0MDAwMDAwMDtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0hhc2ggPSB1ID0+IGhhc1Byb3BlcnR5KHUsIHN5bWJvbCk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IG4gPT4ge1xuICBpZiAobiAhPT0gbiB8fCBuID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBoID0gbiB8IDA7XG4gIGlmIChoICE9PSBuKSB7XG4gICAgaCBePSBuICogMHhmZmZmZmZmZjtcbiAgfVxuICB3aGlsZSAobiA+IDB4ZmZmZmZmZmYpIHtcbiAgICBoIF49IG4gLz0gMHhmZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gb3B0aW1pemUoaCk7XG59O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSBzdHIgPT4ge1xuICBsZXQgaCA9IDUzODEsXG4gICAgaSA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChpKSB7XG4gICAgaCA9IGggKiAzMyBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cbiAgcmV0dXJuIG9wdGltaXplKGgpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3Qgc3RydWN0dXJlS2V5cyA9IChvLCBrZXlzKSA9PiB7XG4gIGxldCBoID0gMTIyODk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGggXj0gcGlwZShzdHJpbmcoa2V5c1tpXSksIGNvbWJpbmUoaGFzaChvW2tleXNbaV1dKSkpO1xuICB9XG4gIHJldHVybiBvcHRpbWl6ZShoKTtcbn07XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cnVjdHVyZSA9IG8gPT4gc3RydWN0dXJlS2V5cyhvLCBPYmplY3Qua2V5cyhvKSk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFycmF5ID0gYXJyID0+IHtcbiAgbGV0IGggPSA2MTUxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGggPSBwaXBlKGgsIGNvbWJpbmUoaGFzaChhcnJbaV0pKSk7XG4gIH1cbiAgcmV0dXJuIG9wdGltaXplKGgpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgY2FjaGVkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHNlbGYgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgc3ltYm9sLCB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSBhcmd1bWVudHNbMF07XG4gIGNvbnN0IGhhc2ggPSBhcmd1bWVudHNbMV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBzeW1ib2wsIHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBoYXNoO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Inspectable.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Inspectable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProto: () => (/* binding */ BaseProto),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   NodeInspectSymbol: () => (/* binding */ NodeInspectSymbol),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   stringifyCircular: () => (/* binding */ stringifyCircular),\n/* harmony export */   toJSON: () => (/* binding */ toJSON),\n/* harmony export */   toStringUnknown: () => (/* binding */ toStringUnknown)\n/* harmony export */ });\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/**\n * @since 2.0.0\n */\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nconst NodeInspectSymbol = /*#__PURE__*/Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * @since 2.0.0\n */\nconst toJSON = x => {\n  if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(x, \"toJSON\") && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(x[\"toJSON\"]) && x[\"toJSON\"].length === 0) {\n    return x.toJSON();\n  } else if (Array.isArray(x)) {\n    return x.map(toJSON);\n  }\n  return x;\n};\n/**\n * @since 2.0.0\n */\nconst format = x => JSON.stringify(x, null, 2);\n/**\n * @since 2.0.0\n */\nconst BaseProto = {\n  toJSON() {\n    return toJSON(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return format(this.toJSON());\n  }\n};\n/**\n * @since 2.0.0\n */\nclass Class {\n  /**\n   * @since 2.0.0\n   */\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  /**\n   * @since 2.0.0\n   */\n  toString() {\n    return format(this.toJSON());\n  }\n}\n/**\n * @since 2.0.0\n */\nconst toStringUnknown = (u, whitespace = 2) => {\n  try {\n    return typeof u === \"object\" ? stringifyCircular(u, whitespace) : String(u);\n  } catch (_) {\n    return String(u);\n  }\n};\n/**\n * @since 2.0.0\n */\nconst stringifyCircular = (obj, whitespace) => {\n  let cache = [];\n  const retVal = JSON.stringify(obj, (_key, value) => typeof value === \"object\" && value !== null ? cache.includes(value) ? undefined // circular reference\n  : cache.push(value) && value : value, whitespace);\n  cache = undefined;\n  return retVal;\n};\n//# sourceMappingURL=Inspectable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0luc3BlY3RhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3lEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLE1BQU0sMERBQVcsaUJBQWlCLHlEQUFVO0FBQzVDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9JbnNwZWN0YWJsZS5qcz9kNTkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc0Z1bmN0aW9uIH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHN5bWJvbHNcbiAqL1xuZXhwb3J0IGNvbnN0IE5vZGVJbnNwZWN0U3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0b0pTT04gPSB4ID0+IHtcbiAgaWYgKGhhc1Byb3BlcnR5KHgsIFwidG9KU09OXCIpICYmIGlzRnVuY3Rpb24oeFtcInRvSlNPTlwiXSkgJiYgeFtcInRvSlNPTlwiXS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geC50b0pTT04oKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHgubWFwKHRvSlNPTik7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHggPT4gSlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgMik7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgQmFzZVByb3RvID0ge1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRvSlNPTih0aGlzKTtcbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGFzcyB7XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHRvU3RyaW5nVW5rbm93biA9ICh1LCB3aGl0ZXNwYWNlID0gMikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiA/IHN0cmluZ2lmeUNpcmN1bGFyKHUsIHdoaXRlc3BhY2UpIDogU3RyaW5nKHUpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIFN0cmluZyh1KTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdpZnlDaXJjdWxhciA9IChvYmosIHdoaXRlc3BhY2UpID0+IHtcbiAgbGV0IGNhY2hlID0gW107XG4gIGNvbnN0IHJldFZhbCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKF9rZXksIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgPyBjYWNoZS5pbmNsdWRlcyh2YWx1ZSkgPyB1bmRlZmluZWQgLy8gY2lyY3VsYXIgcmVmZXJlbmNlXG4gIDogY2FjaGUucHVzaCh2YWx1ZSkgJiYgdmFsdWUgOiB2YWx1ZSwgd2hpdGVzcGFjZSk7XG4gIGNhY2hlID0gdW5kZWZpbmVkO1xuICByZXR1cm4gcmV0VmFsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3BlY3RhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Inspectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Micro.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Micro.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   EnvRefTypeId: () => (/* binding */ EnvRefTypeId),\n/* harmony export */   EnvTypeId: () => (/* binding */ EnvTypeId),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   HandleTypeId: () => (/* binding */ HandleTypeId),\n/* harmony export */   MicroCauseTypeId: () => (/* binding */ MicroCauseTypeId),\n/* harmony export */   MicroSchedulerDefault: () => (/* binding */ MicroSchedulerDefault),\n/* harmony export */   MicroScope: () => (/* binding */ MicroScope),\n/* harmony export */   MicroScopeTypeId: () => (/* binding */ MicroScopeTypeId),\n/* harmony export */   NoSuchElementException: () => (/* binding */ NoSuchElementException),\n/* harmony export */   TaggedError: () => (/* binding */ TaggedError),\n/* harmony export */   TimeoutException: () => (/* binding */ TimeoutException),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   acquireRelease: () => (/* binding */ acquireRelease),\n/* harmony export */   acquireUseRelease: () => (/* binding */ acquireUseRelease),\n/* harmony export */   addFinalizer: () => (/* binding */ addFinalizer),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   as: () => (/* binding */ as),\n/* harmony export */   asSome: () => (/* binding */ asSome),\n/* harmony export */   asVoid: () => (/* binding */ asVoid),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   catchAll: () => (/* binding */ catchAll),\n/* harmony export */   catchAllCause: () => (/* binding */ catchAllCause),\n/* harmony export */   catchAllDefect: () => (/* binding */ catchAllDefect),\n/* harmony export */   catchCauseIf: () => (/* binding */ catchCauseIf),\n/* harmony export */   catchIf: () => (/* binding */ catchIf),\n/* harmony export */   catchTag: () => (/* binding */ catchTag),\n/* harmony export */   causeDie: () => (/* binding */ causeDie),\n/* harmony export */   causeFail: () => (/* binding */ causeFail),\n/* harmony export */   causeInterrupt: () => (/* binding */ causeInterrupt),\n/* harmony export */   causeIsDie: () => (/* binding */ causeIsDie),\n/* harmony export */   causeIsFail: () => (/* binding */ causeIsFail),\n/* harmony export */   causeIsInterrupt: () => (/* binding */ causeIsInterrupt),\n/* harmony export */   causeSquash: () => (/* binding */ causeSquash),\n/* harmony export */   causeWithTrace: () => (/* binding */ causeWithTrace),\n/* harmony export */   context: () => (/* binding */ context),\n/* harmony export */   currentAbortController: () => (/* binding */ currentAbortController),\n/* harmony export */   currentAbortSignal: () => (/* binding */ currentAbortSignal),\n/* harmony export */   currentConcurrency: () => (/* binding */ currentConcurrency),\n/* harmony export */   currentContext: () => (/* binding */ currentContext),\n/* harmony export */   currentMaxDepthBeforeYield: () => (/* binding */ currentMaxDepthBeforeYield),\n/* harmony export */   currentScheduler: () => (/* binding */ currentScheduler),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   die: () => (/* binding */ die),\n/* harmony export */   either: () => (/* binding */ either),\n/* harmony export */   ensuring: () => (/* binding */ ensuring),\n/* harmony export */   envGet: () => (/* binding */ envGet),\n/* harmony export */   envMake: () => (/* binding */ envMake),\n/* harmony export */   envMutate: () => (/* binding */ envMutate),\n/* harmony export */   envRefMake: () => (/* binding */ envRefMake),\n/* harmony export */   envSet: () => (/* binding */ envSet),\n/* harmony export */   envUnsafeMakeEmpty: () => (/* binding */ envUnsafeMakeEmpty),\n/* harmony export */   exit: () => (/* binding */ exit),\n/* harmony export */   exitDie: () => (/* binding */ exitDie),\n/* harmony export */   exitFail: () => (/* binding */ exitFail),\n/* harmony export */   exitFailCause: () => (/* binding */ exitFailCause),\n/* harmony export */   exitInterrupt: () => (/* binding */ exitInterrupt),\n/* harmony export */   exitIsDie: () => (/* binding */ exitIsDie),\n/* harmony export */   exitIsFail: () => (/* binding */ exitIsFail),\n/* harmony export */   exitIsFailure: () => (/* binding */ exitIsFailure),\n/* harmony export */   exitIsInterrupt: () => (/* binding */ exitIsInterrupt),\n/* harmony export */   exitIsSuccess: () => (/* binding */ exitIsSuccess),\n/* harmony export */   exitSucceed: () => (/* binding */ exitSucceed),\n/* harmony export */   exitVoid: () => (/* binding */ exitVoid),\n/* harmony export */   fail: () => (/* binding */ fail),\n/* harmony export */   failCause: () => (/* binding */ failCause),\n/* harmony export */   failCauseSync: () => (/* binding */ failCauseSync),\n/* harmony export */   failSync: () => (/* binding */ failSync),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   filterOrFail: () => (/* binding */ filterOrFail),\n/* harmony export */   filterOrFailCause: () => (/* binding */ filterOrFailCause),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   forever: () => (/* binding */ forever),\n/* harmony export */   fork: () => (/* binding */ fork),\n/* harmony export */   forkDaemon: () => (/* binding */ forkDaemon),\n/* harmony export */   forkIn: () => (/* binding */ forkIn),\n/* harmony export */   forkScoped: () => (/* binding */ forkScoped),\n/* harmony export */   fromEither: () => (/* binding */ fromEither),\n/* harmony export */   fromExit: () => (/* binding */ fromExit),\n/* harmony export */   fromExitSync: () => (/* binding */ fromExitSync),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   getEnvRef: () => (/* binding */ getEnvRef),\n/* harmony export */   ignore: () => (/* binding */ ignore),\n/* harmony export */   ignoreLogged: () => (/* binding */ ignoreLogged),\n/* harmony export */   interrupt: () => (/* binding */ interrupt),\n/* harmony export */   interruptible: () => (/* binding */ interruptible),\n/* harmony export */   isHandle: () => (/* binding */ isHandle),\n/* harmony export */   isMicro: () => (/* binding */ isMicro),\n/* harmony export */   isMicroCause: () => (/* binding */ isMicroCause),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   locally: () => (/* binding */ locally),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapError: () => (/* binding */ mapError),\n/* harmony export */   mapErrorCause: () => (/* binding */ mapErrorCause),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   matchCause: () => (/* binding */ matchCause),\n/* harmony export */   matchCauseEffect: () => (/* binding */ matchCauseEffect),\n/* harmony export */   matchEffect: () => (/* binding */ matchEffect),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   onError: () => (/* binding */ onError),\n/* harmony export */   onExit: () => (/* binding */ onExit),\n/* harmony export */   onExitIf: () => (/* binding */ onExitIf),\n/* harmony export */   onInterrupt: () => (/* binding */ onInterrupt),\n/* harmony export */   option: () => (/* binding */ option),\n/* harmony export */   orDie: () => (/* binding */ orDie),\n/* harmony export */   orElseSucceed: () => (/* binding */ orElseSucceed),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   provideContext: () => (/* binding */ provideContext),\n/* harmony export */   provideScope: () => (/* binding */ provideScope),\n/* harmony export */   provideService: () => (/* binding */ provideService),\n/* harmony export */   provideServiceEffect: () => (/* binding */ provideServiceEffect),\n/* harmony export */   race: () => (/* binding */ race),\n/* harmony export */   raceAll: () => (/* binding */ raceAll),\n/* harmony export */   raceAllFirst: () => (/* binding */ raceAllFirst),\n/* harmony export */   raceFirst: () => (/* binding */ raceFirst),\n/* harmony export */   repeat: () => (/* binding */ repeat),\n/* harmony export */   repeatExit: () => (/* binding */ repeatExit),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   runFork: () => (/* binding */ runFork),\n/* harmony export */   runPromise: () => (/* binding */ runPromise),\n/* harmony export */   runPromiseExit: () => (/* binding */ runPromiseExit),\n/* harmony export */   runSymbol: () => (/* binding */ runSymbol),\n/* harmony export */   runSync: () => (/* binding */ runSync),\n/* harmony export */   runSyncExit: () => (/* binding */ runSyncExit),\n/* harmony export */   sandbox: () => (/* binding */ sandbox),\n/* harmony export */   scheduleAddDelay: () => (/* binding */ scheduleAddDelay),\n/* harmony export */   scheduleExponential: () => (/* binding */ scheduleExponential),\n/* harmony export */   scheduleIntersect: () => (/* binding */ scheduleIntersect),\n/* harmony export */   scheduleRecurs: () => (/* binding */ scheduleRecurs),\n/* harmony export */   scheduleSpaced: () => (/* binding */ scheduleSpaced),\n/* harmony export */   scheduleUnion: () => (/* binding */ scheduleUnion),\n/* harmony export */   scheduleWithMaxDelay: () => (/* binding */ scheduleWithMaxDelay),\n/* harmony export */   scheduleWithMaxElapsed: () => (/* binding */ scheduleWithMaxElapsed),\n/* harmony export */   scope: () => (/* binding */ scope),\n/* harmony export */   scopeMake: () => (/* binding */ scopeMake),\n/* harmony export */   scopeUnsafeMake: () => (/* binding */ scopeUnsafeMake),\n/* harmony export */   scoped: () => (/* binding */ scoped),\n/* harmony export */   service: () => (/* binding */ service),\n/* harmony export */   serviceOption: () => (/* binding */ serviceOption),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   succeed: () => (/* binding */ succeed),\n/* harmony export */   succeedNone: () => (/* binding */ succeedNone),\n/* harmony export */   succeedSome: () => (/* binding */ succeedSome),\n/* harmony export */   suspend: () => (/* binding */ suspend),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   tapDefect: () => (/* binding */ tapDefect),\n/* harmony export */   tapError: () => (/* binding */ tapError),\n/* harmony export */   tapErrorCause: () => (/* binding */ tapErrorCause),\n/* harmony export */   tapErrorCauseIf: () => (/* binding */ tapErrorCauseIf),\n/* harmony export */   timeout: () => (/* binding */ timeout),\n/* harmony export */   timeoutOption: () => (/* binding */ timeoutOption),\n/* harmony export */   timeoutOrElse: () => (/* binding */ timeoutOrElse),\n/* harmony export */   \"try\": () => (/* binding */ try_),\n/* harmony export */   tryPromise: () => (/* binding */ tryPromise),\n/* harmony export */   uninterruptible: () => (/* binding */ uninterruptible),\n/* harmony export */   uninterruptibleMask: () => (/* binding */ uninterruptibleMask),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   when: () => (/* binding */ when),\n/* harmony export */   withConcurrency: () => (/* binding */ withConcurrency),\n/* harmony export */   withTrace: () => (/* binding */ withTrace),\n/* harmony export */   yieldFlush: () => (/* binding */ yieldFlush),\n/* harmony export */   yieldNow: () => (/* binding */ yieldNow),\n/* harmony export */   yieldWithPriority: () => (/* binding */ yieldWithPriority),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Context.js */ \"(ssr)/./node_modules/effect/dist/esm/Context.js\");\n/* harmony import */ var _Effectable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Effectable.js\");\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_effectable_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./internal/effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _internal_singleShotGen_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./internal/singleShotGen.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/singleShotGen.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Option.js */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @since 3.4.0\n * @experimental\n * @category type ids\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Micro\");\n/**\n * @since 3.4.0\n * @experimental\n * @category symbols\n */\nconst runSymbol = /*#__PURE__*/Symbol.for(\"effect/Micro/runSymbol\");\n/**\n * @since 3.4.0\n * @experimental\n * @category guards\n */\nconst isMicro = u => typeof u === \"object\" && u !== null && TypeId in u;\n// ----------------------------------------------------------------------------\n// MicroCause\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst MicroCauseTypeId = /*#__PURE__*/Symbol.for(\"effect/Micro/MicroCause\");\n/**\n * @since 3.6.6\n * @experimental\n * @category guards\n */\nconst isMicroCause = self => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(self, MicroCauseTypeId);\nconst microCauseVariance = {\n  _E: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n};\nclass MicroCauseImpl extends globalThis.Error {\n  _tag;\n  traces;\n  [MicroCauseTypeId];\n  constructor(_tag, originalError, traces) {\n    const causeName = `MicroCause.${_tag}`;\n    let name;\n    let message;\n    let stack;\n    if (originalError instanceof globalThis.Error) {\n      name = `(${causeName}) ${originalError.name}`;\n      message = originalError.message;\n      const messageLines = message.split(\"\\n\").length;\n      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(\"\\n\").slice(0, messageLines + 3).join(\"\\n\")}` : `${name}: ${message}`;\n    } else {\n      name = causeName;\n      message = (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.toStringUnknown)(originalError, 0);\n      stack = `${name}: ${message}`;\n    }\n    if (traces.length > 0) {\n      stack += `\\n    ${traces.join(\"\\n    \")}`;\n    }\n    super(message);\n    this._tag = _tag;\n    this.traces = traces;\n    this[MicroCauseTypeId] = microCauseVariance;\n    this.name = name;\n    this.stack = stack;\n  }\n  pipe() {\n    return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_3__.pipeArguments)(this, arguments);\n  }\n  toString() {\n    return this.stack;\n  }\n  [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol]() {\n    return this.stack;\n  }\n}\nclass FailImpl extends MicroCauseImpl {\n  error;\n  constructor(error, traces = []) {\n    super(\"Fail\", error, traces);\n    this.error = error;\n  }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeFail = (error, traces = []) => new FailImpl(error, traces);\nclass DieImpl extends MicroCauseImpl {\n  defect;\n  constructor(defect, traces = []) {\n    super(\"Die\", defect, traces);\n    this.defect = defect;\n  }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeDie = (defect, traces = []) => new DieImpl(defect, traces);\nclass InterruptImpl extends MicroCauseImpl {\n  constructor(traces = []) {\n    super(\"Interrupt\", \"interrupted\", traces);\n  }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeInterrupt = (traces = []) => new InterruptImpl(traces);\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeIsFail = self => self._tag === \"Fail\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeIsDie = self => self._tag === \"Die\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeIsInterrupt = self => self._tag === \"Interrupt\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeSquash = self => self._tag === \"Fail\" ? self.error : self._tag === \"Die\" ? self.defect : self;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nconst causeWithTrace = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, trace) => {\n  const traces = [...self.traces, trace];\n  switch (self._tag) {\n    case \"Die\":\n      return causeDie(self.defect, traces);\n    case \"Interrupt\":\n      return causeInterrupt(traces);\n    case \"Fail\":\n      return causeFail(self.error, traces);\n  }\n});\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitInterrupt = /*#__PURE__*/_Either_js__WEBPACK_IMPORTED_MODULE_4__.left( /*#__PURE__*/causeInterrupt());\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitSucceed = _Either_js__WEBPACK_IMPORTED_MODULE_4__.right;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitFail = e => _Either_js__WEBPACK_IMPORTED_MODULE_4__.left(causeFail(e));\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitDie = defect => _Either_js__WEBPACK_IMPORTED_MODULE_4__.left(causeDie(defect));\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitFailCause = _Either_js__WEBPACK_IMPORTED_MODULE_4__.left;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitIsSuccess = _Either_js__WEBPACK_IMPORTED_MODULE_4__.isRight;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitIsFailure = _Either_js__WEBPACK_IMPORTED_MODULE_4__.isLeft;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitIsInterrupt = self => exitIsFailure(self) && self.left._tag === \"Interrupt\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitIsFail = self => exitIsFailure(self) && self.left._tag === \"Fail\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitIsDie = self => exitIsFailure(self) && self.left._tag === \"Die\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nconst exitVoid = /*#__PURE__*/exitSucceed(void 0);\n// ----------------------------------------------------------------------------\n// env\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst EnvTypeId = /*#__PURE__*/Symbol.for(\"effect/Micro/Env\");\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst EnvRefTypeId = /*#__PURE__*/Symbol.for(\"effect/Micro/EnvRef\");\nconst EnvProto = {\n  [EnvTypeId]: {\n    _R: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n  },\n  pipe() {\n    return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_3__.pipeArguments)(this, arguments);\n  }\n};\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst envMake = refs => {\n  const self = Object.create(EnvProto);\n  self.refs = refs;\n  return self;\n};\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst envUnsafeMakeEmpty = () => {\n  const controller = new AbortController();\n  const refs = Object.create(null);\n  refs[currentAbortController.key] = controller;\n  refs[currentAbortSignal.key] = controller.signal;\n  refs[currentScheduler.key] = new MicroSchedulerDefault();\n  return envMake(refs);\n};\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst envGet = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, ref) => ref.key in self.refs ? self.refs[ref.key] : ref.initial);\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst envSet = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, ref, value) => {\n  const refs = Object.assign(Object.create(null), self.refs);\n  refs[ref.key] = value;\n  return envMake(refs);\n});\n/**\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst envMutate = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => envMake(f(Object.assign(Object.create(null), self.refs))));\n/**\n * Access the given `Context.Tag` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst service = tag => make(function (env, onExit) {\n  onExit(exitSucceed(_Context_js__WEBPACK_IMPORTED_MODULE_5__.get(envGet(env, currentContext), tag)));\n});\n/**\n * Access the given `Context.Tag` from the environment, without tracking the\n * dependency at the type level.\n *\n * It will return an `Option` of the service, depending on whether it is\n * available in the environment or not.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst serviceOption = tag => make(function (env, onExit) {\n  onExit(exitSucceed(_Context_js__WEBPACK_IMPORTED_MODULE_5__.getOption(envGet(env, currentContext), tag)));\n});\n/**\n * Retrieve the current value of the given `EnvRef`.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst getEnvRef = envRef => make((env, onExit) => onExit(_Either_js__WEBPACK_IMPORTED_MODULE_4__.right(envGet(env, envRef))));\n/**\n * Set the value of the given `EnvRef` for the duration of the effect.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst locally = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, fiberRef, value) => make((env, onExit) => self[runSymbol](envSet(env, fiberRef, value), onExit)));\n/**\n * Access the current `Context` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst context = () => getEnvRef(currentContext);\n/**\n * Merge the given `Context` with the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst provideContext = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, provided) => make(function (env, onExit) {\n  const context = envGet(env, currentContext);\n  const nextEnv = envSet(env, currentContext, _Context_js__WEBPACK_IMPORTED_MODULE_5__.merge(context, provided));\n  self[runSymbol](nextEnv, onExit);\n}));\n/**\n * Add the provided service to the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nconst provideService = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, tag, service) => make(function (env, onExit) {\n  const context = envGet(env, currentContext);\n  const nextEnv = envSet(env, currentContext, _Context_js__WEBPACK_IMPORTED_MODULE_5__.add(context, tag, service));\n  self[runSymbol](nextEnv, onExit);\n}));\n/**\n * Create a service using the provided `Micro` effect, and add it to the\n * current context.\n *\n * @since 3.4.6\n * @experimental\n * @category environment\n */\nconst provideServiceEffect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, tag, acquire) => flatMap(acquire, service => provideService(self, tag, service)));\nconst setImmediate = \"setImmediate\" in globalThis ? globalThis.setImmediate : f => setTimeout(f, 0);\n/**\n * @since 3.5.9\n * @experimental\n * @category scheduler\n */\nclass MicroSchedulerDefault {\n  tasks = [];\n  running = false;\n  /**\n   * @since 3.5.9\n   */\n  scheduleTask(task, _priority) {\n    this.tasks.push(task);\n    if (!this.running) {\n      this.running = true;\n      setImmediate(this.afterScheduled);\n    }\n  }\n  /**\n   * @since 3.5.9\n   */\n  afterScheduled = () => {\n    this.running = false;\n    this.runTasks();\n  };\n  /**\n   * @since 3.5.9\n   */\n  runTasks() {\n    const tasks = this.tasks;\n    this.tasks = [];\n    for (let i = 0, len = tasks.length; i < len; i++) {\n      tasks[i]();\n    }\n  }\n  /**\n   * @since 3.5.9\n   */\n  shouldYield(_env) {\n    return false;\n  }\n  /**\n   * @since 3.5.9\n   */\n  flush() {\n    while (this.tasks.length > 0) {\n      this.runTasks();\n    }\n  }\n}\n// ========================================================================\n// Env refs\n// ========================================================================\nconst EnvRefProto = {\n  [EnvRefTypeId]: EnvRefTypeId\n};\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst envRefMake = (key, initial) => (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_6__.globalValue)(key, () => {\n  const self = Object.create(EnvRefProto);\n  self.key = key;\n  self.initial = initial();\n  return self;\n});\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentAbortController = /*#__PURE__*/envRefMake(\"effect/Micro/currentAbortController\", () => undefined);\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentAbortSignal = /*#__PURE__*/envRefMake(\"effect/Micro/currentAbortSignal\", () => undefined);\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentContext = /*#__PURE__*/envRefMake(\"effect/Micro/currentContext\", () => _Context_js__WEBPACK_IMPORTED_MODULE_5__.empty());\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentConcurrency = /*#__PURE__*/envRefMake(\"effect/Micro/currentConcurrency\", () => \"unbounded\");\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentMaxDepthBeforeYield = /*#__PURE__*/envRefMake(\"effect/Micro/currentMaxDepthBeforeYield\", () => 2048);\nconst currentInterruptible = /*#__PURE__*/envRefMake(\"effect/Micro/currentInterruptible\", () => true);\n/**\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nconst currentScheduler = /*#__PURE__*/envRefMake(\"effect/Micro/currentScheduler\", () => new MicroSchedulerDefault());\n/**\n * If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\n * api to control the concurrency of that `Micro` when it is run.\n *\n * @since 3.4.0\n * @experimental\n * @category environment refs\n * @example\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n *   concurrency: \"inherit\"\n * }).pipe(\n *   Micro.withConcurrency(2) // use a concurrency of 2\n * )\n */\nconst withConcurrency = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, concurrency) => locally(self, currentConcurrency, concurrency));\n// ----------------------------------------------------------------------------\n// constructors\n// ----------------------------------------------------------------------------\nconst MicroProto = {\n  ..._Effectable_js__WEBPACK_IMPORTED_MODULE_7__.EffectPrototype,\n  _op: \"Micro\",\n  [TypeId]: {\n    _A: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    _E: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    _R: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n  },\n  [Symbol.iterator]() {\n    return new _internal_singleShotGen_js__WEBPACK_IMPORTED_MODULE_8__.SingleShotGen(new _Utils_js__WEBPACK_IMPORTED_MODULE_9__.YieldWrap(this));\n  }\n};\nconst microDepthState = /*#__PURE__*/(0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_6__.globalValue)(\"effect/Micro/microDepthState\", () => ({\n  depth: 0,\n  maxDepthBeforeYield: currentMaxDepthBeforeYield.initial\n}));\nconst unsafeMake = run => {\n  const self = Object.create(MicroProto);\n  self[runSymbol] = run;\n  return self;\n};\nconst unsafeMakeOptions = (run, checkAbort) => unsafeMake(function execute(env, onExit) {\n  if (checkAbort && env.refs[currentInterruptible.key] !== false && env.refs[currentAbortSignal.key].aborted) {\n    return onExit(exitInterrupt);\n  }\n  microDepthState.depth++;\n  if (microDepthState.depth === 1) {\n    microDepthState.maxDepthBeforeYield = envGet(env, currentMaxDepthBeforeYield);\n  }\n  const scheduler = env.refs[currentScheduler.key];\n  if (microDepthState.depth >= microDepthState.maxDepthBeforeYield || scheduler.shouldYield(env)) {\n    scheduler.scheduleTask(() => execute(env, onExit), 0);\n  } else {\n    try {\n      run(env, onExit);\n    } catch (err) {\n      onExit(exitDie(err));\n    }\n  }\n  microDepthState.depth--;\n});\n/**\n * A low-level constructor for creating a `Micro` effect. It takes a function\n * that receives an environment and a callback which should be called with the\n * result of the effect.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst make = run => unsafeMakeOptions(run, true);\n/**\n * Converts a `MicroExit` into a `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nconst fromExit = self => make(function (_env, onExit) {\n  onExit(self);\n});\n/**\n * Converts a lazy `MicroExit` into a `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nconst fromExitSync = self => make(function (_env, onExit) {\n  onExit(self());\n});\n/**\n * Creates a `Micro` effect that will succeed with the specified constant value.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst succeed = a => fromExit(exitSucceed(a));\n/**\n * Creates a `Micro` effect that will succeed with `Option.Some` of the value.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst succeedSome = a => succeed(_Option_js__WEBPACK_IMPORTED_MODULE_10__.some(a));\n/**\n * Creates a `Micro` effect that will succeed with `Option.None`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst succeedNone = /*#__PURE__*/succeed( /*#__PURE__*/_Option_js__WEBPACK_IMPORTED_MODULE_10__.none());\n/**\n * Creates a `Micro` effect that will fail with the specified error.\n *\n * This will result in a `CauseFail`, where the error is tracked at the\n * type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst fail = e => fromExit(exitFail(e));\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated error.\n *\n * This will result in a `CauseFail`, where the error is tracked at the\n * type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst failSync = e => make(function (_env, onExit) {\n  onExit(exitFail(e()));\n});\n/**\n * Creates a `Micro` effect that will die with the specified error.\n *\n * This will result in a `CauseDie`, where the error is not tracked at\n * the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst die = defect => fromExit(exitDie(defect));\n/**\n * Creates a `Micro` effect that will fail with the specified `MicroCause`.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nconst failCause = cause => fromExit(exitFailCause(cause));\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nconst failCauseSync = cause => fromExitSync(() => exitFailCause(cause()));\n/**\n * Creates a `Micro` effect that will succeed with the lazily evaluated value.\n *\n * If the evaluation of the value throws an error, the effect will fail with\n * `CauseDie`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst sync = evaluate => make(function (_env, onExit) {\n  onExit(exitSucceed(evaluate()));\n});\n/**\n * Converts an `Option` into a `Micro` effect, that will fail with\n * `NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the\n * value of the option.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst fromOption = option => make(function (_env, onExit) {\n  onExit(option._tag === \"Some\" ? exitSucceed(option.value) : exitFail(new NoSuchElementException({})));\n});\n/**\n * Converts an `Either` into a `Micro` effect, that will fail with the left side\n * of the either if it is a `Left`. Otherwise, it will succeed with the right\n * side of the either.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst fromEither = either => make(function (_env, onExit) {\n  onExit(either._tag === \"Right\" ? either : exitFail(either.left));\n});\n/**\n * Lazily creates a `Micro` effect from the given side-effect.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst suspend = evaluate => make(function (env, onExit) {\n  evaluate()[runSymbol](env, onExit);\n});\nconst void_ = /*#__PURE__*/succeed(void 0);\n\n/**\n * Create a `Micro` effect from an asynchronous computation.\n *\n * You can return a cleanup effect that will be run when the effect is aborted.\n * It is also passed an `AbortSignal` that is triggered when the effect is\n * aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst async = register => make(function (env, onExit) {\n  let resumed = false;\n  const controller = register.length > 1 ? new AbortController() : undefined;\n  const signal = envGet(env, currentAbortSignal);\n  let cleanup = undefined;\n  function onAbort() {\n    if (cleanup) {\n      resume(uninterruptible(andThen(cleanup, fromExit(exitInterrupt))));\n    } else {\n      resume(fromExit(exitInterrupt));\n    }\n    if (controller !== undefined) {\n      controller.abort();\n    }\n  }\n  function resume(effect) {\n    if (resumed) {\n      return;\n    }\n    resumed = true;\n    signal.removeEventListener(\"abort\", onAbort);\n    effect[runSymbol](env, onExit);\n  }\n  cleanup = controller === undefined ? register(resume) : register(resume, controller.signal);\n  if (resumed) return;\n  signal.addEventListener(\"abort\", onAbort);\n});\nconst try_ = options => make(function (_env, onExit) {\n  try {\n    onExit(exitSucceed(options.try()));\n  } catch (err) {\n    onExit(exitFail(options.catch(err)));\n  }\n});\n\n/**\n * Wrap a `Promise` into a `Micro` effect. Any errors will result in a\n * `CauseDie`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst promise = evaluate => async(function (resume, signal) {\n  evaluate(signal).then(a => resume(succeed(a)), e => resume(die(e)));\n});\n/**\n * Wrap a `Promise` into a `Micro` effect. Any errors will be caught and\n * converted into a specific error type.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n * @example\n * import { Micro } from \"effect\"\n *\n * Micro.tryPromise({\n *   try: () => Promise.resolve(\"success\"),\n *   catch: (cause) => new Error(\"caught\", { cause })\n * })\n */\nconst tryPromise = options => async(function (resume, signal) {\n  try {\n    options.try(signal).then(a => resume(succeed(a)), e => resume(fail(options.catch(e))));\n  } catch (err) {\n    resume(fail(options.catch(err)));\n  }\n});\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * iteration of the event loop.\n *\n * You can specify a priority for the task, which will determine when it is\n * executed relative to other tasks.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst yieldWithPriority = priority => make(function (env, onExit) {\n  envGet(env, currentScheduler).scheduleTask(() => onExit(exitVoid), priority);\n});\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * iteration of the event loop.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst yieldNow = /*#__PURE__*/yieldWithPriority(0);\n/**\n * Flush any yielded effects that are waiting to be executed.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst yieldFlush = /*#__PURE__*/make(function (env, onExit) {\n  envGet(env, currentScheduler).flush();\n  onExit(exitVoid);\n});\n/**\n * A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent\n * the Javascript runtime from exiting.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst never = /*#__PURE__*/async(function () {\n  const interval = setInterval(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constVoid, 2147483646);\n  return sync(() => clearInterval(interval));\n});\n/**\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nconst gen = (...args) => make(function (env, onExit) {\n  const iterator = args.length === 1 ? args[0]() : args[1].call(args[0]);\n  let running = false;\n  let value = undefined;\n  function run() {\n    running = true;\n    try {\n      let shouldContinue = true;\n      while (shouldContinue) {\n        const result = iterator.next(value);\n        if (result.done) {\n          return onExit(exitSucceed(result.value));\n        }\n        shouldContinue = false;\n        (0,_Utils_js__WEBPACK_IMPORTED_MODULE_9__.yieldWrapGet)(result.value)[runSymbol](env, function (exit) {\n          if (exit._tag === \"Left\") {\n            onExit(exit);\n          } else {\n            shouldContinue = true;\n            value = exit.right;\n            if (!running) run();\n          }\n        });\n      }\n    } catch (err) {\n      onExit(exitDie(err));\n    }\n    running = false;\n  }\n  run();\n});\n// ----------------------------------------------------------------------------\n// mapping & sequencing\n// ----------------------------------------------------------------------------\n/**\n * Flattens any nested `Micro` effects, merging the error and requirement types.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst flatten = self => make(function (env, onExit) {\n  self[runSymbol](env, exit => exit._tag === \"Left\" ? onExit(exit) : exit.right[runSymbol](env, onExit));\n});\n/**\n * Transforms the success value of the `Micro` effect with the specified\n * function.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst map = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    onExit(exit._tag === \"Left\" ? exit : exitSucceed(f(exit.right)));\n  });\n}));\n/**\n * Create a `Micro` effect that will replace the success value of the given\n * effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst as = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, value) => map(self, _ => value));\n/**\n * Wrap the success value of this `Micro` effect in an `Option.Some`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst asSome = self => map(self, _Option_js__WEBPACK_IMPORTED_MODULE_10__.some);\n/**\n * Map the success value of this `Micro` effect to another `Micro` effect, then\n * flatten the result.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst flatMap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    if (exit._tag === \"Left\") {\n      return onExit(exit);\n    }\n    f(exit.right)[runSymbol](env, onExit);\n  });\n}));\n/**\n * Swap the error and success types of the `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst flip = self => matchEffect(self, {\n  onFailure: succeed,\n  onSuccess: fail\n});\n/**\n * A more flexible version of `flatMap`, that combines `map` and `flatMap` into\n * a single api.\n *\n * It also allows you to pass in a `Micro` effect directly, which will be\n * executed after the current effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst andThen = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    if (exit._tag === \"Left\") {\n      return onExit(exit);\n    } else if (envGet(env, currentAbortSignal).aborted) {\n      return onExit(exitInterrupt);\n    }\n    const value = isMicro(f) ? f : typeof f === \"function\" ? f(exit.right) : f;\n    if (isMicro(value)) {\n      value[runSymbol](env, onExit);\n    } else {\n      onExit(exitSucceed(value));\n    }\n  });\n}));\n/**\n * Execute a side effect from the success value of the `Micro` effect.\n *\n * It is similar to the `andThen` api, but the success value is ignored.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst tap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => make(function (env, onExit) {\n  self[runSymbol](env, function (selfExit) {\n    if (selfExit._tag === \"Left\") {\n      return onExit(selfExit);\n    } else if (envGet(env, currentAbortSignal).aborted) {\n      return onExit(exitInterrupt);\n    }\n    const value = isMicro(f) ? f : typeof f === \"function\" ? f(selfExit.right) : f;\n    if (isMicro(value)) {\n      value[runSymbol](env, function (tapExit) {\n        if (tapExit._tag === \"Left\") {\n          return onExit(tapExit);\n        }\n        onExit(selfExit);\n      });\n    } else {\n      onExit(selfExit);\n    }\n  });\n}));\n/**\n * Replace the success value of the `Micro` effect with `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst asVoid = self => map(self, _ => void 0);\n/**\n * Access the `MicroExit` of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category mapping & sequencing\n */\nconst exit = self => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    onExit(exitSucceed(exit));\n  });\n});\n/**\n * Replace the error type of the given `Micro` with the full `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nconst sandbox = self => catchAllCause(self, cause => fail(cause));\nfunction forkSignal(env) {\n  const controller = new AbortController();\n  const parentSignal = envGet(env, currentAbortSignal);\n  function onAbort() {\n    controller.abort();\n    parentSignal.removeEventListener(\"abort\", onAbort);\n  }\n  parentSignal.addEventListener(\"abort\", onAbort);\n  const envWithSignal = envMutate(env, function (refs) {\n    refs[currentAbortController.key] = controller;\n    refs[currentAbortSignal.key] = controller.signal;\n    return refs;\n  });\n  return [envWithSignal, onAbort];\n}\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nconst raceAll = all => make(function (env, onExit) {\n  const [envWithSignal, onAbort] = forkSignal(env);\n  const effects = Array.from(all);\n  let len = effects.length;\n  let index = 0;\n  let done = 0;\n  let exit = undefined;\n  const causes = [];\n  function onDone(exit_) {\n    done++;\n    if (exit_._tag === \"Right\" && exit === undefined) {\n      len = index;\n      exit = exit_;\n      onAbort();\n    } else if (exit_._tag === \"Left\") {\n      causes.push(exit_.left);\n    }\n    if (done >= len) {\n      onExit(exit ?? _Either_js__WEBPACK_IMPORTED_MODULE_4__.left(causes[0]));\n    }\n  }\n  for (; index < len; index++) {\n    effects[index][runSymbol](envWithSignal, onDone);\n  }\n});\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed or fail. Losers of\n * the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nconst raceAllFirst = all => make(function (env, onExit) {\n  const [envWithSignal, onAbort] = forkSignal(env);\n  const effects = Array.from(all);\n  let len = effects.length;\n  let index = 0;\n  let done = 0;\n  let exit = undefined;\n  const causes = [];\n  function onDone(exit_) {\n    done++;\n    if (exit === undefined) {\n      len = index;\n      exit = exit_;\n      onAbort();\n    }\n    if (done >= len) {\n      onExit(exit ?? _Either_js__WEBPACK_IMPORTED_MODULE_4__.left(causes[0]));\n    }\n  }\n  for (; index < len; index++) {\n    effects[index][runSymbol](envWithSignal, onDone);\n  }\n});\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed. Losers of the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nconst race = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => raceAll([self, that]));\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed *or* fail. Losers of the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nconst raceFirst = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => raceAllFirst([self, that]));\n// ----------------------------------------------------------------------------\n// zipping\n// ----------------------------------------------------------------------------\n/**\n * Combine two `Micro` effects into a single effect that produces a tuple of\n * their results.\n *\n * @since 3.4.0\n * @experimental\n * @category zipping\n */\nconst zip = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[1]), (self, that, options) => zipWith(self, that, (a, a2) => [a, a2], options));\n/**\n * The `Micro.zipWith` function combines two `Micro` effects and allows you to\n * apply a function to the results of the combined effects, transforming them\n * into a single value.\n *\n * @since 3.4.3\n * @experimental\n * @category zipping\n */\nconst zipWith = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[1]), (self, that, f, options) => {\n  if (options?.concurrent) {\n    // Use `all` exclusively for concurrent cases, as it introduces additional overhead due to the management of concurrency\n    return map(all([self, that], {\n      concurrency: \"unbounded\"\n    }), ([a, a2]) => f(a, a2));\n  }\n  return flatMap(self, a => map(that, a2 => f(a, a2)));\n});\n// ----------------------------------------------------------------------------\n// filtering & conditionals\n// ----------------------------------------------------------------------------\n/**\n * Filter the specified effect with the provided function, failing with specified\n * `MicroCause` if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nconst filterOrFailCause = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : failCause(orFailWith(a))));\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nconst filterOrFail = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : fail(orFailWith(a))));\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nconst when = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, condition) => flatMap(isMicro(condition) ? condition : sync(condition), pass => pass ? asSome(self) : succeed(_Option_js__WEBPACK_IMPORTED_MODULE_10__.none())));\n// ----------------------------------------------------------------------------\n// repetition\n// ----------------------------------------------------------------------------\n/**\n * Repeat the given `Micro` using the provided options.\n *\n * The `while` predicate will be checked after each iteration, and can use the\n * fall `MicroExit` of the effect to determine if the repetition should continue.\n *\n * @since 3.4.6\n * @experimental\n * @category repetition\n */\nconst repeatExit = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => make(function (env, onExit) {\n  const startedAt = options.schedule ? Date.now() : 0;\n  let attempt = 0;\n  self[runSymbol](env, function loop(exit) {\n    if (options.while !== undefined && !options.while(exit)) {\n      return onExit(exit);\n    } else if (options.times !== undefined && attempt >= options.times) {\n      return onExit(exit);\n    }\n    attempt++;\n    let delayEffect = yieldNow;\n    if (options.schedule !== undefined) {\n      const elapsed = Date.now() - startedAt;\n      const duration = options.schedule(attempt, elapsed);\n      if (_Option_js__WEBPACK_IMPORTED_MODULE_10__.isNone(duration)) {\n        return onExit(exit);\n      }\n      delayEffect = sleep(duration.value);\n    }\n    delayEffect[runSymbol](env, function (exit) {\n      if (exit._tag === \"Left\") {\n        return onExit(exit);\n      }\n      self[runSymbol](env, loop);\n    });\n  });\n}));\n/**\n * Repeat the given `Micro` effect using the provided options. Only successful\n * results will be repeated.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */\nconst repeat = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[0]), (self, options) => repeatExit(self, {\n  ...options,\n  while: exit => exit._tag === \"Right\" && (options?.while === undefined || options.while(exit.right))\n}));\n/**\n * Repeat the given `Micro` effect forever, only stopping if the effect fails.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */\nconst forever = self => repeat(self);\n/**\n * Create a `MicroSchedule` that will stop repeating after the specified number\n * of attempts.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleRecurs = n => attempt => attempt <= n ? _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(0) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none();\n/**\n * Create a `MicroSchedule` that will generate a constant delay.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleSpaced = millis => () => _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(millis);\n/**\n * Create a `MicroSchedule` that will generate a delay with an exponential backoff.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleExponential = (baseMillis, factor = 2) => attempt => _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(Math.pow(factor, attempt) * baseMillis);\n/**\n * Returns a new `MicroSchedule` with an added calculated delay to each delay\n * returned by this schedule.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleAddDelay = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => (attempt, elapsed) => _Option_js__WEBPACK_IMPORTED_MODULE_10__.map(self(attempt, elapsed), duration => duration + f()));\n/**\n * Transform a `MicroSchedule` to one that will have a delay that will never exceed\n * the specified maximum.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleWithMaxDelay = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, max) => (attempt, elapsed) => _Option_js__WEBPACK_IMPORTED_MODULE_10__.map(self(attempt, elapsed), duration => Math.min(duration, max)));\n/**\n * Transform a `MicroSchedule` to one that will stop repeating after the specified\n * amount of time.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleWithMaxElapsed = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, max) => (attempt, elapsed) => elapsed < max ? self(attempt, elapsed) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none());\n/**\n * Combines two `MicroSchedule`s, by recurring if either schedule wants to\n * recur, using the minimum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleUnion = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => (attempt, elapsed) => _Option_js__WEBPACK_IMPORTED_MODULE_10__.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.min(d1, d2)));\n/**\n * Combines two `MicroSchedule`s, by recurring only if both schedules want to\n * recur, using the maximum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nconst scheduleIntersect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => (attempt, elapsed) => _Option_js__WEBPACK_IMPORTED_MODULE_10__.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.max(d1, d2)));\n// ----------------------------------------------------------------------------\n// error handling\n// ----------------------------------------------------------------------------\n/**\n * Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\n * recover from any kind of cause.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst catchAllCause = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchCauseIf(self, _Function_js__WEBPACK_IMPORTED_MODULE_1__.constTrue, f));\n/**\n * Selectively catch a `MicroCause` object of the given `Micro` effect,\n * using the provided predicate to determine if the failure should be caught.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst catchCauseIf = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, f) => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    if (exit._tag === \"Right\" || !predicate(exit.left)) {\n      onExit(exit);\n    } else {\n      f(exit.left)[runSymbol](env, onExit);\n    }\n  });\n}));\n/**\n * Catch the error of the given `Micro` effect, allowing you to recover from it.\n *\n * It only catches expected (`MicroCause.Fail`) errors.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst catchAll = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchAllCause(self, cause => causeIsFail(cause) ? f(cause.error) : failCause(cause)));\n/**\n * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst catchAllDefect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchCauseIf(self, causeIsDie, die => f(die.defect)));\n/**\n * Perform a side effect using the full `MicroCause` object of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst tapErrorCause = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => tapErrorCauseIf(self, _Function_js__WEBPACK_IMPORTED_MODULE_1__.constTrue, f));\n/**\n * Perform a side effect using if a `MicroCause` object matches the specified\n * predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst tapErrorCauseIf = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, refinement, f) => catchCauseIf(self, refinement, cause => andThen(f(cause), failCause(cause))));\n/**\n * Perform a side effect from expected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst tapError = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => tapErrorCauseIf(self, causeIsFail, fail => f(fail.error)));\n/**\n * Perform a side effect from unexpected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst tapDefect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => tapErrorCauseIf(self, causeIsDie, die => f(die.defect)));\n/**\n * Catch any expected errors that match the specified predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst catchIf = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, f) => catchCauseIf(self, f => causeIsFail(f) && predicate(f.error), fail => f(fail.error)));\n/**\n * Recovers from the specified tagged error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst catchTag = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, k, f) => catchIf(self, (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isTagged)(k), f));\n/**\n * Transform the full `MicroCause` object of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nconst mapErrorCause = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchAllCause(self, cause => failCause(f(cause))));\n/**\n * Transform any expected errors of the given `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst mapError = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchAll(self, error => fail(f(error))));\n/**\n * Elevate any expected errors of the given `Micro` effect to unexpected errors,\n * resulting in an error type of `never`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst orDie = self => catchAll(self, die);\n/**\n * Recover from all errors by succeeding with the given value.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst orElseSucceed = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => catchAll(self, _ => sync(f)));\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst ignore = self => matchEffect(self, {\n  onFailure: _ => void_,\n  onSuccess: _ => void_\n});\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst ignoreLogged = self => matchEffect(self, {\n  onFailure: error => sync(() => console.error(error)),\n  onSuccess: _ => void_\n});\n/**\n * Replace the success value of the given `Micro` effect with an `Option`,\n * wrapping the success value in `Some` and returning `None` if the effect fails\n * with an expected error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst option = self => match(self, {\n  onFailure: _ => _Option_js__WEBPACK_IMPORTED_MODULE_10__.none(),\n  onSuccess: _Option_js__WEBPACK_IMPORTED_MODULE_10__.some\n});\n/**\n * Replace the success value of the given `Micro` effect with an `Either`,\n * wrapping the success value in `Right` and wrapping any expected errors with\n * a `Left`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst either = self => match(self, {\n  onFailure: _Either_js__WEBPACK_IMPORTED_MODULE_4__.left,\n  onSuccess: _Either_js__WEBPACK_IMPORTED_MODULE_4__.right\n});\n/**\n * Retry the given `Micro` effect using the provided options.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst retry = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(args => isMicro(args[0]), (self, options) => repeatExit(self, {\n  ...options,\n  while: exit => exit._tag === \"Left\" && exit.left._tag === \"Fail\" && (options?.while === undefined || options.while(exit.left.error))\n}));\n/**\n * Add a stack trace to any failures that occur in the effect. The trace will be\n * added to the `traces` field of the `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nconst withTrace = function () {\n  const prevLimit = globalThis.Error.stackTraceLimit;\n  globalThis.Error.stackTraceLimit = 2;\n  const error = new globalThis.Error();\n  globalThis.Error.stackTraceLimit = prevLimit;\n  function generate(name, cause) {\n    const stack = error.stack;\n    if (!stack) {\n      return cause;\n    }\n    const line = stack.split(\"\\n\")[2]?.trim().replace(/^at /, \"\");\n    if (!line) {\n      return cause;\n    }\n    const lineMatch = line.match(/\\((.*)\\)$/);\n    return causeWithTrace(cause, `at ${name} (${lineMatch ? lineMatch[1] : line})`);\n  }\n  const f = name => self => unsafeMakeOptions(function (env, onExit) {\n    self[runSymbol](env, function (exit) {\n      onExit(exit._tag === \"Left\" ? _Either_js__WEBPACK_IMPORTED_MODULE_4__.left(generate(name, exit.left)) : exit);\n    });\n  }, false);\n  if (arguments.length === 2) {\n    return f(arguments[1])(arguments[0]);\n  }\n  return f(arguments[0]);\n};\n// ----------------------------------------------------------------------------\n// pattern matching\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nconst matchCauseEffect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => make(function (env, onExit) {\n  self[runSymbol](env, function (exit) {\n    try {\n      const next = exit._tag === \"Left\" ? options.onFailure(exit.left) : options.onSuccess(exit.right);\n      next[runSymbol](env, onExit);\n    } catch (err) {\n      onExit(exitDie(err));\n    }\n  });\n}));\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nconst matchCause = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => sync(() => options.onFailure(cause)),\n  onSuccess: value => sync(() => options.onSuccess(value))\n}));\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nconst matchEffect = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => cause._tag === \"Fail\" ? options.onFailure(cause.error) : failCause(cause),\n  onSuccess: options.onSuccess\n}));\n/**\n * @since 3.4.0\n * @experimental\n * @category pattern matching\n */\nconst match = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => matchEffect(self, {\n  onFailure: error => sync(() => options.onFailure(error)),\n  onSuccess: value => sync(() => options.onSuccess(value))\n}));\n// ----------------------------------------------------------------------------\n// delays & timeouts\n// ----------------------------------------------------------------------------\n/**\n * Create a `Micro` effect that will sleep for the specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nconst sleep = millis => async(function (resume) {\n  const timeout = setTimeout(function () {\n    resume(void_);\n  }, millis);\n  return sync(() => {\n    return clearTimeout(timeout);\n  });\n});\n/**\n * Returns an effect that will delay the execution of this effect by the\n * specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nconst delay = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis) => andThen(sleep(millis), self));\n/**\n * Returns an effect that will timeout this effect, that will execute the\n * fallback effect if the timeout elapses before the effect has produced a value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nconst timeoutOrElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options) => raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout)));\n/**\n * Returns an effect that will timeout this effect, that will fail with a\n * `TimeoutException` if the timeout elapses before the effect has produced a\n * value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nconst timeout = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis) => timeoutOrElse(self, {\n  duration: millis,\n  onTimeout: () => fail(new TimeoutException())\n}));\n/**\n * Returns an effect that will timeout this effect, succeeding with a `None`\n * if the timeout elapses before the effect has produced a value; and `Some` of\n * the produced value otherwise.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nconst timeoutOption = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis) => raceFirst(asSome(self), as(interruptible(sleep(millis)), _Option_js__WEBPACK_IMPORTED_MODULE_10__.none())));\n// ----------------------------------------------------------------------------\n// resources & finalization\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst MicroScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/Micro/MicroScope\");\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst MicroScope = /*#__PURE__*/_Context_js__WEBPACK_IMPORTED_MODULE_5__.GenericTag(\"effect/Micro/MicroScope\");\nclass MicroScopeImpl {\n  [MicroScopeTypeId];\n  state = {\n    _tag: \"Open\",\n    finalizers: /*#__PURE__*/new Set()\n  };\n  constructor() {\n    this[MicroScopeTypeId] = MicroScopeTypeId;\n  }\n  unsafeAddFinalizer(finalizer) {\n    if (this.state._tag === \"Open\") {\n      this.state.finalizers.add(finalizer);\n    }\n  }\n  addFinalizer(finalizer) {\n    return suspend(() => {\n      if (this.state._tag === \"Open\") {\n        this.state.finalizers.add(finalizer);\n        return void_;\n      }\n      return finalizer(this.state.exit);\n    });\n  }\n  unsafeRemoveFinalizer(finalizer) {\n    if (this.state._tag === \"Open\") {\n      this.state.finalizers.delete(finalizer);\n    }\n  }\n  close(microExit) {\n    return suspend(() => {\n      if (this.state._tag === \"Open\") {\n        const finalizers = Array.from(this.state.finalizers).reverse();\n        this.state = {\n          _tag: \"Closed\",\n          exit: microExit\n        };\n        return flatMap(forEach(finalizers, finalizer => exit(finalizer(microExit))), exits => asVoid(fromExit(_Either_js__WEBPACK_IMPORTED_MODULE_4__.all(exits))));\n      }\n      return void_;\n    });\n  }\n  get fork() {\n    return sync(() => {\n      const newScope = new MicroScopeImpl();\n      if (this.state._tag === \"Closed\") {\n        newScope.state = this.state;\n        return newScope;\n      }\n      function fin(exit) {\n        return newScope.close(exit);\n      }\n      this.state.finalizers.add(fin);\n      newScope.unsafeAddFinalizer(_ => sync(() => this.unsafeRemoveFinalizer(fin)));\n      return newScope;\n    });\n  }\n}\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst scopeMake = /*#__PURE__*/sync(() => new MicroScopeImpl());\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst scopeUnsafeMake = () => new MicroScopeImpl();\n/**\n * Access the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst scope = /*#__PURE__*/service(MicroScope);\n/**\n * Provide a `MicroScope` to an effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst provideScope = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, scope) => provideService(self, MicroScope, scope));\n/**\n * Provide a `MicroScope` to the given effect, closing it after the effect has\n * finished executing.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst scoped = self => suspend(function () {\n  const scope = new MicroScopeImpl();\n  return onExit(provideService(self, MicroScope, scope), exit => scope.close(exit));\n});\n/**\n * Create a resource with a cleanup `Micro` effect, ensuring the cleanup is\n * executed when the `MicroScope` is closed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst acquireRelease = (acquire, release) => uninterruptible(flatMap(scope, scope => tap(acquire, a => scope.addFinalizer(exit => release(a, exit)))));\n/**\n * Add a finalizer to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst addFinalizer = finalizer => flatMap(scope, scope => scope.addFinalizer(finalizer));\n/**\n * When the `Micro` effect is completed, run the given finalizer effect with the\n * `MicroExit` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nconst onExit = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => onExitIf(self, _Function_js__WEBPACK_IMPORTED_MODULE_1__.constTrue, f));\n/**\n * When the `Micro` effect is completed, run the given finalizer effect if it\n * matches the specified predicate.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nconst onExitIf = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, refinement, f) => uninterruptibleMask(restore => make(function (env, onExit) {\n  restore(self)[runSymbol](env, function (exit) {\n    if (!refinement(exit)) {\n      return onExit(exit);\n    }\n    f(exit)[runSymbol](env, function (finalizerExit) {\n      if (finalizerExit._tag === \"Left\") {\n        return onExit(finalizerExit);\n      }\n      onExit(exit);\n    });\n  });\n})));\n/**\n * Regardless of the result of the this `Micro` effect, run the finalizer effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst ensuring = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, finalizer) => onExit(self, _ => finalizer));\n/**\n * When the `Micro` effect fails, run the given finalizer effect with the\n * `MicroCause` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nconst onError = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => onExitIf(self, exitIsFailure, exit => f(exit.left)));\n/**\n * If this `Micro` effect is aborted, run the finalizer effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nconst onInterrupt = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, finalizer) => onExitIf(self, exitIsInterrupt, _ => finalizer));\n/**\n * Acquire a resource, use it, and then release the resource when the `use`\n * effect has completed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nconst acquireUseRelease = (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(exit(restore(use(a))), exit => andThen(release(a, exit), fromExit(exit)))));\n// ----------------------------------------------------------------------------\n// interruption\n// ----------------------------------------------------------------------------\n/**\n * Abort the current `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category interruption\n */\nconst interrupt = /*#__PURE__*/make(function (env, onExit) {\n  const controller = envGet(env, currentAbortController);\n  controller.abort();\n  onExit(exitInterrupt);\n});\n/**\n * Wrap the given `Micro` effect in an uninterruptible region, preventing the\n * effect from being aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category interruption\n */\nconst uninterruptible = self => unsafeMakeOptions(function (env, onExit) {\n  const nextEnv = envMutate(env, function (env) {\n    env[currentInterruptible.key] = false;\n    env[currentAbortSignal.key] = new AbortController().signal;\n    return env;\n  });\n  self[runSymbol](nextEnv, onExit);\n}, false);\n/**\n * Wrap the given `Micro` effect in an uninterruptible region, preventing the\n * effect from being aborted.\n *\n * You can use the `restore` function to restore a `Micro` effect to the\n * interruptibility state before the `uninterruptibleMask` was applied.\n *\n * @since 3.4.0\n * @experimental\n * @category interruption\n * @example\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.uninterruptibleMask((restore) =>\n *   Micro.sleep(1000).pipe( // uninterruptible\n *     Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n *   )\n * )\n */\nconst uninterruptibleMask = f => unsafeMakeOptions((env, onExit) => {\n  const isInterruptible = envGet(env, currentInterruptible);\n  const effect = isInterruptible ? f(interruptible) : f(_Function_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n  const nextEnv = isInterruptible ? envMutate(env, function (env) {\n    env[currentInterruptible.key] = false;\n    env[currentAbortSignal.key] = new AbortController().signal;\n    return env;\n  }) : env;\n  effect[runSymbol](nextEnv, onExit);\n}, false);\n/**\n * Wrap the given `Micro` effect in an interruptible region, allowing the effect\n * to be aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category interruption\n */\nconst interruptible = self => make((env, onExit) => {\n  const isInterruptible = envGet(env, currentInterruptible);\n  let newEnv = env;\n  if (!isInterruptible) {\n    const controller = envGet(env, currentAbortController);\n    newEnv = envMutate(env, function (env) {\n      env[currentInterruptible.key] = true;\n      env[currentAbortSignal.key] = controller.signal;\n      return env;\n    });\n  }\n  self[runSymbol](newEnv, onExit);\n});\n/**\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nconst all = (arg, options) => {\n  if (Array.isArray(arg) || (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(arg)) {\n    return forEach(arg, _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity, options);\n  } else if (options?.discard) {\n    return forEach(Object.values(arg), _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity, options);\n  }\n  return suspend(() => {\n    const out = {};\n    return as(forEach(Object.entries(arg), ([key, effect]) => map(effect, value => {\n      out[key] = value;\n    }), {\n      discard: true,\n      concurrency: options?.concurrency\n    }), out);\n  });\n};\n/**\n * For each element of the provided iterable, run the effect and collect the results.\n *\n * If the `discard` option is set to `true`, the results will be discarded and\n * the effect will return `void`.\n *\n * The `concurrency` option can be set to control how many effects are run in\n * parallel. By default, the effects are run sequentially.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nconst forEach = (iterable, f, options) => make(function (env, onExit) {\n  const concurrencyOption = options?.concurrency === \"inherit\" ? envGet(env, currentConcurrency) : options?.concurrency ?? 1;\n  const concurrency = concurrencyOption === \"unbounded\" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);\n  // abort\n  const [envWithSignal, onAbort] = forkSignal(env);\n  // iterate\n  let result = undefined;\n  const items = Array.from(iterable);\n  let length = items.length;\n  if (length === 0) {\n    return onExit(_Either_js__WEBPACK_IMPORTED_MODULE_4__.right(options?.discard ? undefined : []));\n  }\n  const out = options?.discard ? undefined : new Array(length);\n  let index = 0;\n  let inProgress = 0;\n  let doneCount = 0;\n  let pumping = false;\n  function pump() {\n    pumping = true;\n    while (inProgress < concurrency && index < length) {\n      const currentIndex = index;\n      const item = items[currentIndex];\n      index++;\n      inProgress++;\n      try {\n        f(item, currentIndex)[runSymbol](envWithSignal, function (exit) {\n          if (exit._tag === \"Left\") {\n            if (result === undefined) {\n              result = exit;\n              length = index;\n              onAbort();\n            }\n          } else if (out !== undefined) {\n            out[currentIndex] = exit.right;\n          }\n          doneCount++;\n          inProgress--;\n          if (doneCount === length) {\n            onExit(result ?? _Either_js__WEBPACK_IMPORTED_MODULE_4__.right(out));\n          } else if (!pumping && inProgress < concurrency) {\n            pump();\n          }\n        });\n      } catch (err) {\n        result = exitDie(err);\n        length = index;\n        onAbort();\n      }\n    }\n    pumping = false;\n  }\n  pump();\n});\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed in parallel.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nconst filter = (iterable, f, options) => filterMap(iterable, a => map(f(a), pass => {\n  pass = options?.negate ? !pass : pass;\n  return pass ? _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(a) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none();\n}), options);\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed in parallel.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nconst filterMap = (iterable, f, options) => suspend(() => {\n  const out = [];\n  return as(forEach(iterable, a => map(f(a), o => {\n    if (o._tag === \"Some\") {\n      out.push(o.value);\n    }\n  }), {\n    discard: true,\n    concurrency: options?.concurrency\n  }), out);\n});\n// ----------------------------------------------------------------------------\n// do notation\n// ----------------------------------------------------------------------------\n/**\n * Start a do notation block.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nconst Do = /*#__PURE__*/succeed({});\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nconst bindTo = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.bindTo(map);\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nconst bind = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.bind(map, flatMap);\nconst let_ = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.let_(map);\n\n// ----------------------------------------------------------------------------\n// handle & forking\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst HandleTypeId = /*#__PURE__*/Symbol.for(\"effect/Micro/Handle\");\n/**\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst isHandle = u => typeof u === \"object\" && u !== null && HandleTypeId in u;\nclass HandleImpl {\n  parentSignal;\n  [HandleTypeId];\n  observers = /*#__PURE__*/new Set();\n  _exit = undefined;\n  _controller;\n  isRoot;\n  constructor(parentSignal, controller) {\n    this.parentSignal = parentSignal;\n    this[HandleTypeId] = HandleTypeId;\n    this.isRoot = controller !== undefined;\n    this._controller = controller ?? new AbortController();\n    if (!this.isRoot) {\n      parentSignal.addEventListener(\"abort\", this.unsafeInterrupt);\n    }\n  }\n  unsafePoll() {\n    return this._exit ?? null;\n  }\n  unsafeInterrupt = () => {\n    this._controller.abort();\n  };\n  emit(exit) {\n    if (this._exit) {\n      return;\n    }\n    this._exit = exit;\n    if (!this.isRoot) {\n      this.parentSignal.removeEventListener(\"abort\", this.unsafeInterrupt);\n    }\n    this.observers.forEach(observer => observer(exit));\n    this.observers.clear();\n  }\n  addObserver(observer) {\n    if (this._exit) {\n      return observer(this._exit);\n    }\n    this.observers.add(observer);\n  }\n  removeObserver(observer) {\n    this.observers.delete(observer);\n  }\n  get await() {\n    return suspend(() => {\n      if (this._exit) {\n        return succeed(this._exit);\n      }\n      return async(resume => {\n        function observer(exit) {\n          resume(succeed(exit));\n        }\n        this.addObserver(observer);\n        return sync(() => {\n          this.removeObserver(observer);\n        });\n      });\n    });\n  }\n  get join() {\n    return flatMap(this.await, fromExit);\n  }\n  get interrupt() {\n    return suspend(() => {\n      this.unsafeInterrupt();\n      return this.await;\n    });\n  }\n}\n/**\n * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or\n * aborted.\n *\n * When the parent `Micro` finishes, this `Micro` will be aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst fork = self => make(function (env, onExit) {\n  const signal = envGet(env, currentAbortSignal);\n  const handle = new HandleImpl(signal);\n  const nextEnv = envMutate(env, map => {\n    map[currentAbortController.key] = handle._controller;\n    map[currentAbortSignal.key] = handle._controller.signal;\n    return map;\n  });\n  envGet(env, currentScheduler).scheduleTask(() => {\n    self[runSymbol](nextEnv, exit => {\n      handle.emit(exit);\n    });\n  }, 0);\n  onExit(_Either_js__WEBPACK_IMPORTED_MODULE_4__.right(handle));\n});\n/**\n * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or\n * aborted.\n *\n * It will not be aborted when the parent `Micro` finishes.\n *\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst forkDaemon = self => make(function (env, onExit) {\n  const controller = new AbortController();\n  const handle = new HandleImpl(controller.signal, controller);\n  const nextEnv = envMutate(env, map => {\n    map[currentAbortController.key] = controller;\n    map[currentAbortSignal.key] = controller.signal;\n    return map;\n  });\n  envGet(env, currentScheduler).scheduleTask(() => {\n    self[runSymbol](nextEnv, exit => {\n      handle.emit(exit);\n    });\n  }, 0);\n  onExit(_Either_js__WEBPACK_IMPORTED_MODULE_4__.right(handle));\n});\n/**\n * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the provided `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst forkIn = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, scope) => uninterruptibleMask(restore => flatMap(scope.fork, scope => tap(restore(forkDaemon(onExit(self, exit => scope.close(exit)))), fiber => scope.addFinalizer(_ => asVoid(fiber.interrupt))))));\n/**\n * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category handle & forking\n */\nconst forkScoped = self => flatMap(scope, scope => forkIn(self, scope));\n// ----------------------------------------------------------------------------\n// execution\n// ----------------------------------------------------------------------------\n/**\n * Execute the `Micro` effect and return a `Handle` that can be awaited, joined,\n * or aborted.\n *\n * You can listen for the result by adding an observer using the handle's\n * `addObserver` method.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n * @example\n * import * as Micro from \"effect/Micro\"\n *\n * const handle = Micro.succeed(42).pipe(\n *   Micro.delay(1000),\n *   Micro.runFork\n * )\n *\n * handle.addObserver((exit) => {\n *   console.log(exit)\n * })\n */\nconst runFork = (effect, options) => {\n  const controller = new AbortController();\n  const refs = Object.create(null);\n  refs[currentAbortController.key] = controller;\n  refs[currentAbortSignal.key] = controller.signal;\n  refs[currentScheduler.key] = options?.scheduler ?? new MicroSchedulerDefault();\n  const env = envMake(refs);\n  const handle = new HandleImpl(controller.signal, controller);\n  effect[runSymbol](envSet(env, currentAbortSignal, handle._controller.signal), exit => {\n    handle.emit(exit);\n    if (options?.signal) {\n      options.signal.removeEventListener(\"abort\", handle.unsafeInterrupt);\n    }\n  });\n  if (options?.signal) {\n    if (options.signal.aborted) {\n      handle.unsafeInterrupt();\n    } else {\n      options.signal.addEventListener(\"abort\", handle.unsafeInterrupt, {\n        once: true\n      });\n    }\n  }\n  return handle;\n};\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * `MicroExit` of the computation.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */\nconst runPromiseExit = (effect, options) => new Promise((resolve, _reject) => {\n  const handle = runFork(effect, options);\n  handle.addObserver(resolve);\n});\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * successful value of the computation.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */\nconst runPromise = (effect, options) => runPromiseExit(effect, options).then(exit => {\n  if (exit._tag === \"Left\") {\n    throw exit.left;\n  }\n  return exit.right;\n});\n/**\n * Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.\n *\n * If any asynchronous effects are encountered, the function will return a\n * `CauseDie` containing the `Handle`.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */\nconst runSyncExit = effect => {\n  const scheduler = new MicroSchedulerDefault();\n  const handle = runFork(effect, {\n    scheduler\n  });\n  scheduler.flush();\n  const exit = handle.unsafePoll();\n  if (exit === null) {\n    return exitDie(handle);\n  }\n  return exit;\n};\n/**\n * Attempt to execute the `Micro` effect synchronously and return the success\n * value.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */\nconst runSync = effect => {\n  const exit = runSyncExit(effect);\n  if (exit._tag === \"Left\") {\n    throw exit.left;\n  }\n  return exit.right;\n};\nconst YieldableError = /*#__PURE__*/function () {\n  class YieldableError extends globalThis.Error {\n    [runSymbol](_env, onExit) {\n      onExit(exitFail(this));\n    }\n    toString() {\n      return this.message ? `${this.name}: ${this.message}` : this.name;\n    }\n    toJSON() {\n      return {\n        ...this\n      };\n    }\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol]() {\n      const stack = this.stack;\n      if (stack) {\n        return `${this.toString()}\\n${stack.split(\"\\n\").slice(1).join(\"\\n\")}`;\n      }\n      return this.toString();\n    }\n  }\n  Object.assign(YieldableError.prototype, MicroProto, _internal_effectable_js__WEBPACK_IMPORTED_MODULE_12__.StructuralPrototype);\n  return YieldableError;\n}();\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */\nconst Error = /*#__PURE__*/function () {\n  return class extends YieldableError {\n    constructor(args) {\n      super();\n      if (args) {\n        Object.assign(this, args);\n      }\n    }\n  };\n}();\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */\nconst TaggedError = tag => {\n  class Base extends Error {\n    _tag = tag;\n  }\n  ;\n  Base.prototype.name = tag;\n  return Base;\n};\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */\nclass NoSuchElementException extends /*#__PURE__*/TaggedError(\"NoSuchElementException\") {}\n/**\n * Represents a checked exception which occurs when a timeout occurs.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */\nclass TimeoutException extends /*#__PURE__*/TaggedError(\"TimeoutException\") {}\n//# sourceMappingURL=Micro.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL01pY3JvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ007QUFDUjtBQUMrQjtBQUN0QjtBQUN1QjtBQUNmO0FBQ1E7QUFDSDtBQUN0QjtBQUNRO0FBQ3FCO0FBQ2Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QiwwREFBVztBQUMvQztBQUNBLE1BQU0sa0RBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVLElBQUksbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVSxJQUFJLHNFQUFzRSxPQUFPLEtBQUssSUFBSSxRQUFRO0FBQ3BKLE1BQU07QUFDTjtBQUNBLGdCQUFnQixnRUFBZTtBQUMvQixpQkFBaUIsS0FBSyxJQUFJLFFBQVE7QUFDbEM7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOERBQWlCO0FBQ3BCO0FB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsSUFBSSxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOERBQWlCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLElBQUksc0NBQXNDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlFQUFtQjtBQUN6RTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL01pY3JvLmpzPzE0YWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ29udGV4dCBmcm9tIFwiLi9Db250ZXh0LmpzXCI7XG5pbXBvcnQgKiBhcyBFZmZlY3RhYmxlIGZyb20gXCIuL0VmZmVjdGFibGUuanNcIjtcbmltcG9ydCAqIGFzIEVpdGhlciBmcm9tIFwiLi9FaXRoZXIuanNcIjtcbmltcG9ydCB7IGNvbnN0VHJ1ZSwgY29uc3RWb2lkLCBkdWFsLCBpZGVudGl0eSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuL0dsb2JhbFZhbHVlLmpzXCI7XG5pbXBvcnQgeyBOb2RlSW5zcGVjdFN5bWJvbCwgdG9TdHJpbmdVbmtub3duIH0gZnJvbSBcIi4vSW5zcGVjdGFibGUuanNcIjtcbmltcG9ydCAqIGFzIGRvTm90YXRpb24gZnJvbSBcIi4vaW50ZXJuYWwvZG9Ob3RhdGlvbi5qc1wiO1xuaW1wb3J0IHsgU3RydWN0dXJhbFByb3RvdHlwZSB9IGZyb20gXCIuL2ludGVybmFsL2VmZmVjdGFibGUuanNcIjtcbmltcG9ydCB7IFNpbmdsZVNob3RHZW4gfSBmcm9tIFwiLi9pbnRlcm5hbC9zaW5nbGVTaG90R2VuLmpzXCI7XG5pbXBvcnQgKiBhcyBPcHRpb24gZnJvbSBcIi4vT3B0aW9uLmpzXCI7XG5pbXBvcnQgeyBwaXBlQXJndW1lbnRzIH0gZnJvbSBcIi4vUGlwZWFibGUuanNcIjtcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc0l0ZXJhYmxlLCBpc1RhZ2dlZCB9IGZyb20gXCIuL1ByZWRpY2F0ZS5qc1wiO1xuaW1wb3J0IHsgWWllbGRXcmFwLCB5aWVsZFdyYXBHZXQgfSBmcm9tIFwiLi9VdGlscy5qc1wiO1xuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSB0eXBlIGlkc1xuICovXG5leHBvcnQgY29uc3QgVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm9cIik7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHN5bWJvbHNcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1blN5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL3J1blN5bWJvbFwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc01pY3JvID0gdSA9PiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiAmJiB1ICE9PSBudWxsICYmIFR5cGVJZCBpbiB1O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWljcm9DYXVzZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb0NhdXNlVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9DYXVzZVwiKTtcbi8qKlxuICogQHNpbmNlIDMuNi42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc01pY3JvQ2F1c2UgPSBzZWxmID0+IGhhc1Byb3BlcnR5KHNlbGYsIE1pY3JvQ2F1c2VUeXBlSWQpO1xuY29uc3QgbWljcm9DYXVzZVZhcmlhbmNlID0ge1xuICBfRTogaWRlbnRpdHlcbn07XG5jbGFzcyBNaWNyb0NhdXNlSW1wbCBleHRlbmRzIGdsb2JhbFRoaXMuRXJyb3Ige1xuICBfdGFnO1xuICB0cmFjZXM7XG4gIFtNaWNyb0NhdXNlVHlwZUlkXTtcbiAgY29uc3RydWN0b3IoX3RhZywgb3JpZ2luYWxFcnJvciwgdHJhY2VzKSB7XG4gICAgY29uc3QgY2F1c2VOYW1lID0gYE1pY3JvQ2F1c2UuJHtfdGFnfWA7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgbGV0IHN0YWNrO1xuICAgIGlmIChvcmlnaW5hbEVycm9yIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvcikge1xuICAgICAgbmFtZSA9IGAoJHtjYXVzZU5hbWV9KSAke29yaWdpbmFsRXJyb3IubmFtZX1gO1xuICAgICAgbWVzc2FnZSA9IG9yaWdpbmFsRXJyb3IubWVzc2FnZTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuICAgICAgc3RhY2sgPSBvcmlnaW5hbEVycm9yLnN0YWNrID8gYCgke2NhdXNlTmFtZX0pICR7b3JpZ2luYWxFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgwLCBtZXNzYWdlTGluZXMgKyAzKS5qb2luKFwiXFxuXCIpfWAgOiBgJHtuYW1lfTogJHttZXNzYWdlfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBjYXVzZU5hbWU7XG4gICAgICBtZXNzYWdlID0gdG9TdHJpbmdVbmtub3duKG9yaWdpbmFsRXJyb3IsIDApO1xuICAgICAgc3RhY2sgPSBgJHtuYW1lfTogJHttZXNzYWdlfWA7XG4gICAgfVxuICAgIGlmICh0cmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2sgKz0gYFxcbiAgICAke3RyYWNlcy5qb2luKFwiXFxuICAgIFwiKX1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLl90YWcgPSBfdGFnO1xuICAgIHRoaXMudHJhY2VzID0gdHJhY2VzO1xuICAgIHRoaXNbTWljcm9DYXVzZVR5cGVJZF0gPSBtaWNyb0NhdXNlVmFyaWFuY2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gcGlwZUFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s7XG4gIH1cbn1cbmNsYXNzIEZhaWxJbXBsIGV4dGVuZHMgTWljcm9DYXVzZUltcGwge1xuICBlcnJvcjtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHRyYWNlcyA9IFtdKSB7XG4gICAgc3VwZXIoXCJGYWlsXCIsIGVycm9yLCB0cmFjZXMpO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXVzZUZhaWwgPSAoZXJyb3IsIHRyYWNlcyA9IFtdKSA9PiBuZXcgRmFpbEltcGwoZXJyb3IsIHRyYWNlcyk7XG5jbGFzcyBEaWVJbXBsIGV4dGVuZHMgTWljcm9DYXVzZUltcGwge1xuICBkZWZlY3Q7XG4gIGNvbnN0cnVjdG9yKGRlZmVjdCwgdHJhY2VzID0gW10pIHtcbiAgICBzdXBlcihcIkRpZVwiLCBkZWZlY3QsIHRyYWNlcyk7XG4gICAgdGhpcy5kZWZlY3QgPSBkZWZlY3Q7XG4gIH1cbn1cbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9DYXVzZVxuICovXG5leHBvcnQgY29uc3QgY2F1c2VEaWUgPSAoZGVmZWN0LCB0cmFjZXMgPSBbXSkgPT4gbmV3IERpZUltcGwoZGVmZWN0LCB0cmFjZXMpO1xuY2xhc3MgSW50ZXJydXB0SW1wbCBleHRlbmRzIE1pY3JvQ2F1c2VJbXBsIHtcbiAgY29uc3RydWN0b3IodHJhY2VzID0gW10pIHtcbiAgICBzdXBlcihcIkludGVycnVwdFwiLCBcImludGVycnVwdGVkXCIsIHRyYWNlcyk7XG4gIH1cbn1cbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9DYXVzZVxuICovXG5leHBvcnQgY29uc3QgY2F1c2VJbnRlcnJ1cHQgPSAodHJhY2VzID0gW10pID0+IG5ldyBJbnRlcnJ1cHRJbXBsKHRyYWNlcyk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlSXNGYWlsID0gc2VsZiA9PiBzZWxmLl90YWcgPT09IFwiRmFpbFwiO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXVzZUlzRGllID0gc2VsZiA9PiBzZWxmLl90YWcgPT09IFwiRGllXCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlSXNJbnRlcnJ1cHQgPSBzZWxmID0+IHNlbGYuX3RhZyA9PT0gXCJJbnRlcnJ1cHRcIjtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9DYXVzZVxuICovXG5leHBvcnQgY29uc3QgY2F1c2VTcXVhc2ggPSBzZWxmID0+IHNlbGYuX3RhZyA9PT0gXCJGYWlsXCIgPyBzZWxmLmVycm9yIDogc2VsZi5fdGFnID09PSBcIkRpZVwiID8gc2VsZi5kZWZlY3QgOiBzZWxmO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXVzZVdpdGhUcmFjZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0cmFjZSkgPT4ge1xuICBjb25zdCB0cmFjZXMgPSBbLi4uc2VsZi50cmFjZXMsIHRyYWNlXTtcbiAgc3dpdGNoIChzZWxmLl90YWcpIHtcbiAgICBjYXNlIFwiRGllXCI6XG4gICAgICByZXR1cm4gY2F1c2VEaWUoc2VsZi5kZWZlY3QsIHRyYWNlcyk7XG4gICAgY2FzZSBcIkludGVycnVwdFwiOlxuICAgICAgcmV0dXJuIGNhdXNlSW50ZXJydXB0KHRyYWNlcyk7XG4gICAgY2FzZSBcIkZhaWxcIjpcbiAgICAgIHJldHVybiBjYXVzZUZhaWwoc2VsZi5lcnJvciwgdHJhY2VzKTtcbiAgfVxufSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdEludGVycnVwdCA9IC8qI19fUFVSRV9fKi9FaXRoZXIubGVmdCggLyojX19QVVJFX18qL2NhdXNlSW50ZXJydXB0KCkpO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRTdWNjZWVkID0gRWl0aGVyLnJpZ2h0O1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRGYWlsID0gZSA9PiBFaXRoZXIubGVmdChjYXVzZUZhaWwoZSkpO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXREaWUgPSBkZWZlY3QgPT4gRWl0aGVyLmxlZnQoY2F1c2VEaWUoZGVmZWN0KSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdEZhaWxDYXVzZSA9IEVpdGhlci5sZWZ0O1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRJc1N1Y2Nlc3MgPSBFaXRoZXIuaXNSaWdodDtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9FeGl0XG4gKi9cbmV4cG9ydCBjb25zdCBleGl0SXNGYWlsdXJlID0gRWl0aGVyLmlzTGVmdDtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9FeGl0XG4gKi9cbmV4cG9ydCBjb25zdCBleGl0SXNJbnRlcnJ1cHQgPSBzZWxmID0+IGV4aXRJc0ZhaWx1cmUoc2VsZikgJiYgc2VsZi5sZWZ0Ll90YWcgPT09IFwiSW50ZXJydXB0XCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdElzRmFpbCA9IHNlbGYgPT4gZXhpdElzRmFpbHVyZShzZWxmKSAmJiBzZWxmLmxlZnQuX3RhZyA9PT0gXCJGYWlsXCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdElzRGllID0gc2VsZiA9PiBleGl0SXNGYWlsdXJlKHNlbGYpICYmIHNlbGYubGVmdC5fdGFnID09PSBcIkRpZVwiO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRWb2lkID0gLyojX19QVVJFX18qL2V4aXRTdWNjZWVkKHZvaWQgMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBlbnZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEVudlR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL0VudlwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEVudlJlZlR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL0VudlJlZlwiKTtcbmNvbnN0IEVudlByb3RvID0ge1xuICBbRW52VHlwZUlkXToge1xuICAgIF9SOiBpZGVudGl0eVxuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiBwaXBlQXJndW1lbnRzKHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBlbnZNYWtlID0gcmVmcyA9PiB7XG4gIGNvbnN0IHNlbGYgPSBPYmplY3QuY3JlYXRlKEVudlByb3RvKTtcbiAgc2VsZi5yZWZzID0gcmVmcztcbiAgcmV0dXJuIHNlbGY7XG59O1xuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3QgZW52VW5zYWZlTWFrZUVtcHR5ID0gKCkgPT4ge1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdCByZWZzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmVmc1tjdXJyZW50QWJvcnRDb250cm9sbGVyLmtleV0gPSBjb250cm9sbGVyO1xuICByZWZzW2N1cnJlbnRBYm9ydFNpZ25hbC5rZXldID0gY29udHJvbGxlci5zaWduYWw7XG4gIHJlZnNbY3VycmVudFNjaGVkdWxlci5rZXldID0gbmV3IE1pY3JvU2NoZWR1bGVyRGVmYXVsdCgpO1xuICByZXR1cm4gZW52TWFrZShyZWZzKTtcbn07XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBlbnZHZXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcmVmKSA9PiByZWYua2V5IGluIHNlbGYucmVmcyA/IHNlbGYucmVmc1tyZWYua2V5XSA6IHJlZi5pbml0aWFsKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGVudlNldCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCByZWYsIHZhbHVlKSA9PiB7XG4gIGNvbnN0IHJlZnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHNlbGYucmVmcyk7XG4gIHJlZnNbcmVmLmtleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIGVudk1ha2UocmVmcyk7XG59KTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGVudk11dGF0ZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBlbnZNYWtlKGYoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBzZWxmLnJlZnMpKSkpO1xuLyoqXG4gKiBBY2Nlc3MgdGhlIGdpdmVuIGBDb250ZXh0LlRhZ2AgZnJvbSB0aGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNlcnZpY2UgPSB0YWcgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgb25FeGl0KGV4aXRTdWNjZWVkKENvbnRleHQuZ2V0KGVudkdldChlbnYsIGN1cnJlbnRDb250ZXh0KSwgdGFnKSkpO1xufSk7XG4vKipcbiAqIEFjY2VzcyB0aGUgZ2l2ZW4gYENvbnRleHQuVGFnYCBmcm9tIHRoZSBlbnZpcm9ubWVudCwgd2l0aG91dCB0cmFja2luZyB0aGVcbiAqIGRlcGVuZGVuY3kgYXQgdGhlIHR5cGUgbGV2ZWwuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gYW4gYE9wdGlvbmAgb2YgdGhlIHNlcnZpY2UsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzXG4gKiBhdmFpbGFibGUgaW4gdGhlIGVudmlyb25tZW50IG9yIG5vdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3Qgc2VydmljZU9wdGlvbiA9IHRhZyA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBvbkV4aXQoZXhpdFN1Y2NlZWQoQ29udGV4dC5nZXRPcHRpb24oZW52R2V0KGVudiwgY3VycmVudENvbnRleHQpLCB0YWcpKSk7XG59KTtcbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGdpdmVuIGBFbnZSZWZgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbnZSZWYgPSBlbnZSZWYgPT4gbWFrZSgoZW52LCBvbkV4aXQpID0+IG9uRXhpdChFaXRoZXIucmlnaHQoZW52R2V0KGVudiwgZW52UmVmKSkpKTtcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYEVudlJlZmAgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBsb2NhbGx5ID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGZpYmVyUmVmLCB2YWx1ZSkgPT4gbWFrZSgoZW52LCBvbkV4aXQpID0+IHNlbGZbcnVuU3ltYm9sXShlbnZTZXQoZW52LCBmaWJlclJlZiwgdmFsdWUpLCBvbkV4aXQpKSk7XG4vKipcbiAqIEFjY2VzcyB0aGUgY3VycmVudCBgQ29udGV4dGAgZnJvbSB0aGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRleHQgPSAoKSA9PiBnZXRFbnZSZWYoY3VycmVudENvbnRleHQpO1xuLyoqXG4gKiBNZXJnZSB0aGUgZ2l2ZW4gYENvbnRleHRgIHdpdGggdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3QgcHJvdmlkZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcHJvdmlkZWQpID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBlbnZHZXQoZW52LCBjdXJyZW50Q29udGV4dCk7XG4gIGNvbnN0IG5leHRFbnYgPSBlbnZTZXQoZW52LCBjdXJyZW50Q29udGV4dCwgQ29udGV4dC5tZXJnZShjb250ZXh0LCBwcm92aWRlZCkpO1xuICBzZWxmW3J1blN5bWJvbF0obmV4dEVudiwgb25FeGl0KTtcbn0pKTtcbi8qKlxuICogQWRkIHRoZSBwcm92aWRlZCBzZXJ2aWNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3ZpZGVTZXJ2aWNlID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRhZywgc2VydmljZSkgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3QgY29udGV4dCA9IGVudkdldChlbnYsIGN1cnJlbnRDb250ZXh0KTtcbiAgY29uc3QgbmV4dEVudiA9IGVudlNldChlbnYsIGN1cnJlbnRDb250ZXh0LCBDb250ZXh0LmFkZChjb250ZXh0LCB0YWcsIHNlcnZpY2UpKTtcbiAgc2VsZltydW5TeW1ib2xdKG5leHRFbnYsIG9uRXhpdCk7XG59KSk7XG4vKipcbiAqIENyZWF0ZSBhIHNlcnZpY2UgdXNpbmcgdGhlIHByb3ZpZGVkIGBNaWNyb2AgZWZmZWN0LCBhbmQgYWRkIGl0IHRvIHRoZVxuICogY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBwcm92aWRlU2VydmljZUVmZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0YWcsIGFjcXVpcmUpID0+IGZsYXRNYXAoYWNxdWlyZSwgc2VydmljZSA9PiBwcm92aWRlU2VydmljZShzZWxmLCB0YWcsIHNlcnZpY2UpKSk7XG5jb25zdCBzZXRJbW1lZGlhdGUgPSBcInNldEltbWVkaWF0ZVwiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLnNldEltbWVkaWF0ZSA6IGYgPT4gc2V0VGltZW91dChmLCAwKTtcbi8qKlxuICogQHNpbmNlIDMuNS45XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBNaWNyb1NjaGVkdWxlckRlZmF1bHQge1xuICB0YXNrcyA9IFtdO1xuICBydW5uaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAc2luY2UgMy41LjlcbiAgICovXG4gIHNjaGVkdWxlVGFzayh0YXNrLCBfcHJpb3JpdHkpIHtcbiAgICB0aGlzLnRhc2tzLnB1c2godGFzayk7XG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUodGhpcy5hZnRlclNjaGVkdWxlZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMy41LjlcbiAgICovXG4gIGFmdGVyU2NoZWR1bGVkID0gKCkgPT4ge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMucnVuVGFza3MoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgcnVuVGFza3MoKSB7XG4gICAgY29uc3QgdGFza3MgPSB0aGlzLnRhc2tzO1xuICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFza3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhc2tzW2ldKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMy41LjlcbiAgICovXG4gIHNob3VsZFlpZWxkKF9lbnYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgd2hpbGUgKHRoaXMudGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5ydW5UYXNrcygpO1xuICAgIH1cbiAgfVxufVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFbnYgcmVmc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBFbnZSZWZQcm90byA9IHtcbiAgW0VudlJlZlR5cGVJZF06IEVudlJlZlR5cGVJZFxufTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnQgcmVmc1xuICovXG5leHBvcnQgY29uc3QgZW52UmVmTWFrZSA9IChrZXksIGluaXRpYWwpID0+IGdsb2JhbFZhbHVlKGtleSwgKCkgPT4ge1xuICBjb25zdCBzZWxmID0gT2JqZWN0LmNyZWF0ZShFbnZSZWZQcm90byk7XG4gIHNlbGYua2V5ID0ga2V5O1xuICBzZWxmLmluaXRpYWwgPSBpbml0aWFsKCk7XG4gIHJldHVybiBzZWxmO1xufSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNvbnN0IGN1cnJlbnRBYm9ydENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZW52UmVmTWFrZShcImVmZmVjdC9NaWNyby9jdXJyZW50QWJvcnRDb250cm9sbGVyXCIsICgpID0+IHVuZGVmaW5lZCk7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNvbnN0IGN1cnJlbnRBYm9ydFNpZ25hbCA9IC8qI19fUFVSRV9fKi9lbnZSZWZNYWtlKFwiZWZmZWN0L01pY3JvL2N1cnJlbnRBYm9ydFNpZ25hbFwiLCAoKSA9PiB1bmRlZmluZWQpO1xuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudCByZWZzXG4gKi9cbmV4cG9ydCBjb25zdCBjdXJyZW50Q29udGV4dCA9IC8qI19fUFVSRV9fKi9lbnZSZWZNYWtlKFwiZWZmZWN0L01pY3JvL2N1cnJlbnRDb250ZXh0XCIsICgpID0+IENvbnRleHQuZW1wdHkoKSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNvbnN0IGN1cnJlbnRDb25jdXJyZW5jeSA9IC8qI19fUFVSRV9fKi9lbnZSZWZNYWtlKFwiZWZmZWN0L01pY3JvL2N1cnJlbnRDb25jdXJyZW5jeVwiLCAoKSA9PiBcInVuYm91bmRlZFwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnQgcmVmc1xuICovXG5leHBvcnQgY29uc3QgY3VycmVudE1heERlcHRoQmVmb3JlWWllbGQgPSAvKiNfX1BVUkVfXyovZW52UmVmTWFrZShcImVmZmVjdC9NaWNyby9jdXJyZW50TWF4RGVwdGhCZWZvcmVZaWVsZFwiLCAoKSA9PiAyMDQ4KTtcbmNvbnN0IGN1cnJlbnRJbnRlcnJ1cHRpYmxlID0gLyojX19QVVJFX18qL2VudlJlZk1ha2UoXCJlZmZlY3QvTWljcm8vY3VycmVudEludGVycnVwdGlibGVcIiwgKCkgPT4gdHJ1ZSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNvbnN0IGN1cnJlbnRTY2hlZHVsZXIgPSAvKiNfX1BVUkVfXyovZW52UmVmTWFrZShcImVmZmVjdC9NaWNyby9jdXJyZW50U2NoZWR1bGVyXCIsICgpID0+IG5ldyBNaWNyb1NjaGVkdWxlckRlZmF1bHQoKSk7XG4vKipcbiAqIElmIHlvdSBoYXZlIGEgYE1pY3JvYCB0aGF0IHVzZXMgYGNvbmN1cnJlbmN5OiBcImluaGVyaXRcImAsIHlvdSBjYW4gdXNlIHRoaXNcbiAqIGFwaSB0byBjb250cm9sIHRoZSBjb25jdXJyZW5jeSBvZiB0aGF0IGBNaWNyb2Agd2hlbiBpdCBpcyBydW4uXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnQgcmVmc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIE1pY3JvIGZyb20gXCJlZmZlY3QvTWljcm9cIlxuICpcbiAqIE1pY3JvLmZvckVhY2goWzEsIDIsIDNdLCAobikgPT4gTWljcm8uc3VjY2VlZChuKSwge1xuICogICBjb25jdXJyZW5jeTogXCJpbmhlcml0XCJcbiAqIH0pLnBpcGUoXG4gKiAgIE1pY3JvLndpdGhDb25jdXJyZW5jeSgyKSAvLyB1c2UgYSBjb25jdXJyZW5jeSBvZiAyXG4gKiApXG4gKi9cbmV4cG9ydCBjb25zdCB3aXRoQ29uY3VycmVuY3kgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgY29uY3VycmVuY3kpID0+IGxvY2FsbHkoc2VsZiwgY3VycmVudENvbmN1cnJlbmN5LCBjb25jdXJyZW5jeSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29uc3RydWN0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBNaWNyb1Byb3RvID0ge1xuICAuLi5FZmZlY3RhYmxlLkVmZmVjdFByb3RvdHlwZSxcbiAgX29wOiBcIk1pY3JvXCIsXG4gIFtUeXBlSWRdOiB7XG4gICAgX0E6IGlkZW50aXR5LFxuICAgIF9FOiBpZGVudGl0eSxcbiAgICBfUjogaWRlbnRpdHlcbiAgfSxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5nbGVTaG90R2VuKG5ldyBZaWVsZFdyYXAodGhpcykpO1xuICB9XG59O1xuY29uc3QgbWljcm9EZXB0aFN0YXRlID0gLyojX19QVVJFX18qL2dsb2JhbFZhbHVlKFwiZWZmZWN0L01pY3JvL21pY3JvRGVwdGhTdGF0ZVwiLCAoKSA9PiAoe1xuICBkZXB0aDogMCxcbiAgbWF4RGVwdGhCZWZvcmVZaWVsZDogY3VycmVudE1heERlcHRoQmVmb3JlWWllbGQuaW5pdGlhbFxufSkpO1xuY29uc3QgdW5zYWZlTWFrZSA9IHJ1biA9PiB7XG4gIGNvbnN0IHNlbGYgPSBPYmplY3QuY3JlYXRlKE1pY3JvUHJvdG8pO1xuICBzZWxmW3J1blN5bWJvbF0gPSBydW47XG4gIHJldHVybiBzZWxmO1xufTtcbmNvbnN0IHVuc2FmZU1ha2VPcHRpb25zID0gKHJ1biwgY2hlY2tBYm9ydCkgPT4gdW5zYWZlTWFrZShmdW5jdGlvbiBleGVjdXRlKGVudiwgb25FeGl0KSB7XG4gIGlmIChjaGVja0Fib3J0ICYmIGVudi5yZWZzW2N1cnJlbnRJbnRlcnJ1cHRpYmxlLmtleV0gIT09IGZhbHNlICYmIGVudi5yZWZzW2N1cnJlbnRBYm9ydFNpZ25hbC5rZXldLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gb25FeGl0KGV4aXRJbnRlcnJ1cHQpO1xuICB9XG4gIG1pY3JvRGVwdGhTdGF0ZS5kZXB0aCsrO1xuICBpZiAobWljcm9EZXB0aFN0YXRlLmRlcHRoID09PSAxKSB7XG4gICAgbWljcm9EZXB0aFN0YXRlLm1heERlcHRoQmVmb3JlWWllbGQgPSBlbnZHZXQoZW52LCBjdXJyZW50TWF4RGVwdGhCZWZvcmVZaWVsZCk7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVyID0gZW52LnJlZnNbY3VycmVudFNjaGVkdWxlci5rZXldO1xuICBpZiAobWljcm9EZXB0aFN0YXRlLmRlcHRoID49IG1pY3JvRGVwdGhTdGF0ZS5tYXhEZXB0aEJlZm9yZVlpZWxkIHx8IHNjaGVkdWxlci5zaG91bGRZaWVsZChlbnYpKSB7XG4gICAgc2NoZWR1bGVyLnNjaGVkdWxlVGFzaygoKSA9PiBleGVjdXRlKGVudiwgb25FeGl0KSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJ1bihlbnYsIG9uRXhpdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBvbkV4aXQoZXhpdERpZShlcnIpKTtcbiAgICB9XG4gIH1cbiAgbWljcm9EZXB0aFN0YXRlLmRlcHRoLS07XG59KTtcbi8qKlxuICogQSBsb3ctbGV2ZWwgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGEgYE1pY3JvYCBlZmZlY3QuIEl0IHRha2VzIGEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYW4gZW52aXJvbm1lbnQgYW5kIGEgY2FsbGJhY2sgd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZVxuICogcmVzdWx0IG9mIHRoZSBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gcnVuID0+IHVuc2FmZU1ha2VPcHRpb25zKHJ1biwgdHJ1ZSk7XG4vKipcbiAqIENvbnZlcnRzIGEgYE1pY3JvRXhpdGAgaW50byBhIGBNaWNyb2AgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZnJvbUV4aXQgPSBzZWxmID0+IG1ha2UoZnVuY3Rpb24gKF9lbnYsIG9uRXhpdCkge1xuICBvbkV4aXQoc2VsZik7XG59KTtcbi8qKlxuICogQ29udmVydHMgYSBsYXp5IGBNaWNyb0V4aXRgIGludG8gYSBgTWljcm9gIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21FeGl0U3luYyA9IHNlbGYgPT4gbWFrZShmdW5jdGlvbiAoX2Vudiwgb25FeGl0KSB7XG4gIG9uRXhpdChzZWxmKCkpO1xufSk7XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHdpbGwgc3VjY2VlZCB3aXRoIHRoZSBzcGVjaWZpZWQgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdWNjZWVkID0gYSA9PiBmcm9tRXhpdChleGl0U3VjY2VlZChhKSk7XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHdpbGwgc3VjY2VlZCB3aXRoIGBPcHRpb24uU29tZWAgb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3Qgc3VjY2VlZFNvbWUgPSBhID0+IHN1Y2NlZWQoT3B0aW9uLnNvbWUoYSkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIHN1Y2NlZWQgd2l0aCBgT3B0aW9uLk5vbmVgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3Qgc3VjY2VlZE5vbmUgPSAvKiNfX1BVUkVfXyovc3VjY2VlZCggLyojX19QVVJFX18qL09wdGlvbi5ub25lKCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgc3BlY2lmaWVkIGVycm9yLlxuICpcbiAqIFRoaXMgd2lsbCByZXN1bHQgaW4gYSBgQ2F1c2VGYWlsYCwgd2hlcmUgdGhlIGVycm9yIGlzIHRyYWNrZWQgYXQgdGhlXG4gKiB0eXBlIGxldmVsLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZmFpbCA9IGUgPT4gZnJvbUV4aXQoZXhpdEZhaWwoZSkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgbGF6aWx5IGV2YWx1YXRlZCBlcnJvci5cbiAqXG4gKiBUaGlzIHdpbGwgcmVzdWx0IGluIGEgYENhdXNlRmFpbGAsIHdoZXJlIHRoZSBlcnJvciBpcyB0cmFja2VkIGF0IHRoZVxuICogdHlwZSBsZXZlbC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZhaWxTeW5jID0gZSA9PiBtYWtlKGZ1bmN0aW9uIChfZW52LCBvbkV4aXQpIHtcbiAgb25FeGl0KGV4aXRGYWlsKGUoKSkpO1xufSk7XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHdpbGwgZGllIHdpdGggdGhlIHNwZWNpZmllZCBlcnJvci5cbiAqXG4gKiBUaGlzIHdpbGwgcmVzdWx0IGluIGEgYENhdXNlRGllYCwgd2hlcmUgdGhlIGVycm9yIGlzIG5vdCB0cmFja2VkIGF0XG4gKiB0aGUgdHlwZSBsZXZlbC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGRpZSA9IGRlZmVjdCA9PiBmcm9tRXhpdChleGl0RGllKGRlZmVjdCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgc3BlY2lmaWVkIGBNaWNyb0NhdXNlYC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZhaWxDYXVzZSA9IGNhdXNlID0+IGZyb21FeGl0KGV4aXRGYWlsQ2F1c2UoY2F1c2UpKTtcbi8qKlxuICogQ3JlYXRlcyBhIGBNaWNyb2AgZWZmZWN0IHRoYXQgd2lsbCBmYWlsIHdpdGggdGhlIGxhemlseSBldmFsdWF0ZWQgYE1pY3JvQ2F1c2VgLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZmFpbENhdXNlU3luYyA9IGNhdXNlID0+IGZyb21FeGl0U3luYygoKSA9PiBleGl0RmFpbENhdXNlKGNhdXNlKCkpKTtcbi8qKlxuICogQ3JlYXRlcyBhIGBNaWNyb2AgZWZmZWN0IHRoYXQgd2lsbCBzdWNjZWVkIHdpdGggdGhlIGxhemlseSBldmFsdWF0ZWQgdmFsdWUuXG4gKlxuICogSWYgdGhlIGV2YWx1YXRpb24gb2YgdGhlIHZhbHVlIHRocm93cyBhbiBlcnJvciwgdGhlIGVmZmVjdCB3aWxsIGZhaWwgd2l0aFxuICogYENhdXNlRGllYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHN5bmMgPSBldmFsdWF0ZSA9PiBtYWtlKGZ1bmN0aW9uIChfZW52LCBvbkV4aXQpIHtcbiAgb25FeGl0KGV4aXRTdWNjZWVkKGV2YWx1YXRlKCkpKTtcbn0pO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgT3B0aW9uYCBpbnRvIGEgYE1pY3JvYCBlZmZlY3QsIHRoYXQgd2lsbCBmYWlsIHdpdGhcbiAqIGBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uYCBpZiB0aGUgb3B0aW9uIGlzIGBOb25lYC4gT3RoZXJ3aXNlLCBpdCB3aWxsIHN1Y2NlZWQgd2l0aCB0aGVcbiAqIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tT3B0aW9uID0gb3B0aW9uID0+IG1ha2UoZnVuY3Rpb24gKF9lbnYsIG9uRXhpdCkge1xuICBvbkV4aXQob3B0aW9uLl90YWcgPT09IFwiU29tZVwiID8gZXhpdFN1Y2NlZWQob3B0aW9uLnZhbHVlKSA6IGV4aXRGYWlsKG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKHt9KSkpO1xufSk7XG4vKipcbiAqIENvbnZlcnRzIGFuIGBFaXRoZXJgIGludG8gYSBgTWljcm9gIGVmZmVjdCwgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgbGVmdCBzaWRlXG4gKiBvZiB0aGUgZWl0aGVyIGlmIGl0IGlzIGEgYExlZnRgLiBPdGhlcndpc2UsIGl0IHdpbGwgc3VjY2VlZCB3aXRoIHRoZSByaWdodFxuICogc2lkZSBvZiB0aGUgZWl0aGVyLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZnJvbUVpdGhlciA9IGVpdGhlciA9PiBtYWtlKGZ1bmN0aW9uIChfZW52LCBvbkV4aXQpIHtcbiAgb25FeGl0KGVpdGhlci5fdGFnID09PSBcIlJpZ2h0XCIgPyBlaXRoZXIgOiBleGl0RmFpbChlaXRoZXIubGVmdCkpO1xufSk7XG4vKipcbiAqIExhemlseSBjcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgZnJvbSB0aGUgZ2l2ZW4gc2lkZS1lZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdXNwZW5kID0gZXZhbHVhdGUgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgZXZhbHVhdGUoKVtydW5TeW1ib2xdKGVudiwgb25FeGl0KTtcbn0pO1xuY29uc3Qgdm9pZF8gPSAvKiNfX1BVUkVfXyovc3VjY2VlZCh2b2lkIDApO1xuZXhwb3J0IHtcbi8qKlxuICogQSBgTWljcm9gIGVmZmVjdCB0aGF0IHdpbGwgc3VjY2VlZCB3aXRoIGB2b2lkYCAoYHVuZGVmaW5lZGApLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG52b2lkXyBhcyB2b2lkIH07XG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb2AgZWZmZWN0IGZyb20gYW4gYXN5bmNocm9ub3VzIGNvbXB1dGF0aW9uLlxuICpcbiAqIFlvdSBjYW4gcmV0dXJuIGEgY2xlYW51cCBlZmZlY3QgdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHRoZSBlZmZlY3QgaXMgYWJvcnRlZC5cbiAqIEl0IGlzIGFsc28gcGFzc2VkIGFuIGBBYm9ydFNpZ25hbGAgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZWZmZWN0IGlzXG4gKiBhYm9ydGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgYXN5bmMgPSByZWdpc3RlciA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBsZXQgcmVzdW1lZCA9IGZhbHNlO1xuICBjb25zdCBjb250cm9sbGVyID0gcmVnaXN0ZXIubGVuZ3RoID4gMSA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc2lnbmFsID0gZW52R2V0KGVudiwgY3VycmVudEFib3J0U2lnbmFsKTtcbiAgbGV0IGNsZWFudXAgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIG9uQWJvcnQoKSB7XG4gICAgaWYgKGNsZWFudXApIHtcbiAgICAgIHJlc3VtZSh1bmludGVycnVwdGlibGUoYW5kVGhlbihjbGVhbnVwLCBmcm9tRXhpdChleGl0SW50ZXJydXB0KSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdW1lKGZyb21FeGl0KGV4aXRJbnRlcnJ1cHQpKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoZWZmZWN0KSB7XG4gICAgaWYgKHJlc3VtZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdW1lZCA9IHRydWU7XG4gICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICBlZmZlY3RbcnVuU3ltYm9sXShlbnYsIG9uRXhpdCk7XG4gIH1cbiAgY2xlYW51cCA9IGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCA/IHJlZ2lzdGVyKHJlc3VtZSkgOiByZWdpc3RlcihyZXN1bWUsIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgaWYgKHJlc3VtZWQpIHJldHVybjtcbiAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbn0pO1xuY29uc3QgdHJ5XyA9IG9wdGlvbnMgPT4gbWFrZShmdW5jdGlvbiAoX2Vudiwgb25FeGl0KSB7XG4gIHRyeSB7XG4gICAgb25FeGl0KGV4aXRTdWNjZWVkKG9wdGlvbnMudHJ5KCkpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25FeGl0KGV4aXRGYWlsKG9wdGlvbnMuY2F0Y2goZXJyKSkpO1xuICB9XG59KTtcbmV4cG9ydCB7XG4vKipcbiAqIFRoZSBgTWljcm9gIGVxdWl2YWxlbnQgb2YgYSB0cnkgLyBjYXRjaCBibG9jaywgd2hpY2ggYWxsb3dzIHlvdSB0byBtYXBcbiAqIHRocm93biBlcnJvcnMgdG8gYSBzcGVjaWZpYyBlcnJvciB0eXBlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE1pY3JvIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogTWljcm8udHJ5KHtcbiAqICAgdHJ5OiAoKSA9PiB0aHJvdyBuZXcgRXJyb3IoXCJib29tXCIpLFxuICogICBjYXRjaDogKGNhdXNlKSA9PiBuZXcgRXJyb3IoXCJjYXVnaHRcIiwgeyBjYXVzZSB9KVxuICogfSlcbiAqL1xudHJ5XyBhcyB0cnkgfTtcbi8qKlxuICogV3JhcCBhIGBQcm9taXNlYCBpbnRvIGEgYE1pY3JvYCBlZmZlY3QuIEFueSBlcnJvcnMgd2lsbCByZXN1bHQgaW4gYVxuICogYENhdXNlRGllYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHByb21pc2UgPSBldmFsdWF0ZSA9PiBhc3luYyhmdW5jdGlvbiAocmVzdW1lLCBzaWduYWwpIHtcbiAgZXZhbHVhdGUoc2lnbmFsKS50aGVuKGEgPT4gcmVzdW1lKHN1Y2NlZWQoYSkpLCBlID0+IHJlc3VtZShkaWUoZSkpKTtcbn0pO1xuLyoqXG4gKiBXcmFwIGEgYFByb21pc2VgIGludG8gYSBgTWljcm9gIGVmZmVjdC4gQW55IGVycm9ycyB3aWxsIGJlIGNhdWdodCBhbmRcbiAqIGNvbnZlcnRlZCBpbnRvIGEgc3BlY2lmaWMgZXJyb3IgdHlwZS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBNaWNybyB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIE1pY3JvLnRyeVByb21pc2Uoe1xuICogICB0cnk6ICgpID0+IFByb21pc2UucmVzb2x2ZShcInN1Y2Nlc3NcIiksXG4gKiAgIGNhdGNoOiAoY2F1c2UpID0+IG5ldyBFcnJvcihcImNhdWdodFwiLCB7IGNhdXNlIH0pXG4gKiB9KVxuICovXG5leHBvcnQgY29uc3QgdHJ5UHJvbWlzZSA9IG9wdGlvbnMgPT4gYXN5bmMoZnVuY3Rpb24gKHJlc3VtZSwgc2lnbmFsKSB7XG4gIHRyeSB7XG4gICAgb3B0aW9ucy50cnkoc2lnbmFsKS50aGVuKGEgPT4gcmVzdW1lKHN1Y2NlZWQoYSkpLCBlID0+IHJlc3VtZShmYWlsKG9wdGlvbnMuY2F0Y2goZSkpKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJlc3VtZShmYWlsKG9wdGlvbnMuY2F0Y2goZXJyKSkpO1xuICB9XG59KTtcbi8qKlxuICogUGF1c2UgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBgTWljcm9gIGVmZmVjdCwgYW5kIHJlc3VtZSBpdCBvbiB0aGUgbmV4dFxuICogaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wLlxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBhIHByaW9yaXR5IGZvciB0aGUgdGFzaywgd2hpY2ggd2lsbCBkZXRlcm1pbmUgd2hlbiBpdCBpc1xuICogZXhlY3V0ZWQgcmVsYXRpdmUgdG8gb3RoZXIgdGFza3MuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCB5aWVsZFdpdGhQcmlvcml0eSA9IHByaW9yaXR5ID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIGVudkdldChlbnYsIGN1cnJlbnRTY2hlZHVsZXIpLnNjaGVkdWxlVGFzaygoKSA9PiBvbkV4aXQoZXhpdFZvaWQpLCBwcmlvcml0eSk7XG59KTtcbi8qKlxuICogUGF1c2UgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBgTWljcm9gIGVmZmVjdCwgYW5kIHJlc3VtZSBpdCBvbiB0aGUgbmV4dFxuICogaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgeWllbGROb3cgPSAvKiNfX1BVUkVfXyoveWllbGRXaXRoUHJpb3JpdHkoMCk7XG4vKipcbiAqIEZsdXNoIGFueSB5aWVsZGVkIGVmZmVjdHMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBleGVjdXRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHlpZWxkRmx1c2ggPSAvKiNfX1BVUkVfXyovbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgZW52R2V0KGVudiwgY3VycmVudFNjaGVkdWxlcikuZmx1c2goKTtcbiAgb25FeGl0KGV4aXRWb2lkKTtcbn0pO1xuLyoqXG4gKiBBIGBNaWNyb2AgdGhhdCB3aWxsIG5ldmVyIHN1Y2NlZWQgb3IgZmFpbC4gSXQgd3JhcHMgYHNldEludGVydmFsYCB0byBwcmV2ZW50XG4gKiB0aGUgSmF2YXNjcmlwdCBydW50aW1lIGZyb20gZXhpdGluZy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldmVyID0gLyojX19QVVJFX18qL2FzeW5jKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjb25zdFZvaWQsIDIxNDc0ODM2NDYpO1xuICByZXR1cm4gc3luYygoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKSk7XG59KTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW4gPSAoLi4uYXJncykgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0oKSA6IGFyZ3NbMV0uY2FsbChhcmdzWzBdKTtcbiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICBmdW5jdGlvbiBydW4oKSB7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzaG91bGRDb250aW51ZSA9IHRydWU7XG4gICAgICB3aGlsZSAoc2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBvbkV4aXQoZXhpdFN1Y2NlZWQocmVzdWx0LnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkQ29udGludWUgPSBmYWxzZTtcbiAgICAgICAgeWllbGRXcmFwR2V0KHJlc3VsdC52YWx1ZSlbcnVuU3ltYm9sXShlbnYsIGZ1bmN0aW9uIChleGl0KSB7XG4gICAgICAgICAgaWYgKGV4aXQuX3RhZyA9PT0gXCJMZWZ0XCIpIHtcbiAgICAgICAgICAgIG9uRXhpdChleGl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hvdWxkQ29udGludWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSBleGl0LnJpZ2h0O1xuICAgICAgICAgICAgaWYgKCFydW5uaW5nKSBydW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgb25FeGl0KGV4aXREaWUoZXJyKSk7XG4gICAgfVxuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBydW4oKTtcbn0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbWFwcGluZyAmIHNlcXVlbmNpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogRmxhdHRlbnMgYW55IG5lc3RlZCBgTWljcm9gIGVmZmVjdHMsIG1lcmdpbmcgdGhlIGVycm9yIGFuZCByZXF1aXJlbWVudCB0eXBlcy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IHNlbGYgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgc2VsZltydW5TeW1ib2xdKGVudiwgZXhpdCA9PiBleGl0Ll90YWcgPT09IFwiTGVmdFwiID8gb25FeGl0KGV4aXQpIDogZXhpdC5yaWdodFtydW5TeW1ib2xdKGVudiwgb25FeGl0KSk7XG59KTtcbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGUgYE1pY3JvYCBlZmZlY3Qgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgbWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIHNlbGZbcnVuU3ltYm9sXShlbnYsIGZ1bmN0aW9uIChleGl0KSB7XG4gICAgb25FeGl0KGV4aXQuX3RhZyA9PT0gXCJMZWZ0XCIgPyBleGl0IDogZXhpdFN1Y2NlZWQoZihleGl0LnJpZ2h0KSkpO1xuICB9KTtcbn0pKTtcbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhlIGdpdmVuXG4gKiBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHZhbHVlKSA9PiBtYXAoc2VsZiwgXyA9PiB2YWx1ZSkpO1xuLyoqXG4gKiBXcmFwIHRoZSBzdWNjZXNzIHZhbHVlIG9mIHRoaXMgYE1pY3JvYCBlZmZlY3QgaW4gYW4gYE9wdGlvbi5Tb21lYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgYXNTb21lID0gc2VsZiA9PiBtYXAoc2VsZiwgT3B0aW9uLnNvbWUpO1xuLyoqXG4gKiBNYXAgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhpcyBgTWljcm9gIGVmZmVjdCB0byBhbm90aGVyIGBNaWNyb2AgZWZmZWN0LCB0aGVuXG4gKiBmbGF0dGVuIHRoZSByZXN1bHQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXRNYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgc2VsZltydW5TeW1ib2xdKGVudiwgZnVuY3Rpb24gKGV4aXQpIHtcbiAgICBpZiAoZXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgICAgcmV0dXJuIG9uRXhpdChleGl0KTtcbiAgICB9XG4gICAgZihleGl0LnJpZ2h0KVtydW5TeW1ib2xdKGVudiwgb25FeGl0KTtcbiAgfSk7XG59KSk7XG4vKipcbiAqIFN3YXAgdGhlIGVycm9yIGFuZCBzdWNjZXNzIHR5cGVzIG9mIHRoZSBgTWljcm9gIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgZmxpcCA9IHNlbGYgPT4gbWF0Y2hFZmZlY3Qoc2VsZiwge1xuICBvbkZhaWx1cmU6IHN1Y2NlZWQsXG4gIG9uU3VjY2VzczogZmFpbFxufSk7XG4vKipcbiAqIEEgbW9yZSBmbGV4aWJsZSB2ZXJzaW9uIG9mIGBmbGF0TWFwYCwgdGhhdCBjb21iaW5lcyBgbWFwYCBhbmQgYGZsYXRNYXBgIGludG9cbiAqIGEgc2luZ2xlIGFwaS5cbiAqXG4gKiBJdCBhbHNvIGFsbG93cyB5b3UgdG8gcGFzcyBpbiBhIGBNaWNyb2AgZWZmZWN0IGRpcmVjdGx5LCB3aGljaCB3aWxsIGJlXG4gKiBleGVjdXRlZCBhZnRlciB0aGUgY3VycmVudCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFuZFRoZW4gPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgc2VsZltydW5TeW1ib2xdKGVudiwgZnVuY3Rpb24gKGV4aXQpIHtcbiAgICBpZiAoZXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgICAgcmV0dXJuIG9uRXhpdChleGl0KTtcbiAgICB9IGVsc2UgaWYgKGVudkdldChlbnYsIGN1cnJlbnRBYm9ydFNpZ25hbCkuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIG9uRXhpdChleGl0SW50ZXJydXB0KTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBpc01pY3JvKGYpID8gZiA6IHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIgPyBmKGV4aXQucmlnaHQpIDogZjtcbiAgICBpZiAoaXNNaWNybyh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlW3J1blN5bWJvbF0oZW52LCBvbkV4aXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkV4aXQoZXhpdFN1Y2NlZWQodmFsdWUpKTtcbiAgICB9XG4gIH0pO1xufSkpO1xuLyoqXG4gKiBFeGVjdXRlIGEgc2lkZSBlZmZlY3QgZnJvbSB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGUgYE1pY3JvYCBlZmZlY3QuXG4gKlxuICogSXQgaXMgc2ltaWxhciB0byB0aGUgYGFuZFRoZW5gIGFwaSwgYnV0IHRoZSBzdWNjZXNzIHZhbHVlIGlzIGlnbm9yZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBzZWxmW3J1blN5bWJvbF0oZW52LCBmdW5jdGlvbiAoc2VsZkV4aXQpIHtcbiAgICBpZiAoc2VsZkV4aXQuX3RhZyA9PT0gXCJMZWZ0XCIpIHtcbiAgICAgIHJldHVybiBvbkV4aXQoc2VsZkV4aXQpO1xuICAgIH0gZWxzZSBpZiAoZW52R2V0KGVudiwgY3VycmVudEFib3J0U2lnbmFsKS5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gb25FeGl0KGV4aXRJbnRlcnJ1cHQpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGlzTWljcm8oZikgPyBmIDogdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIiA/IGYoc2VsZkV4aXQucmlnaHQpIDogZjtcbiAgICBpZiAoaXNNaWNybyh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlW3J1blN5bWJvbF0oZW52LCBmdW5jdGlvbiAodGFwRXhpdCkge1xuICAgICAgICBpZiAodGFwRXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgICAgICAgIHJldHVybiBvbkV4aXQodGFwRXhpdCk7XG4gICAgICAgIH1cbiAgICAgICAgb25FeGl0KHNlbGZFeGl0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkV4aXQoc2VsZkV4aXQpO1xuICAgIH1cbiAgfSk7XG59KSk7XG4vKipcbiAqIFJlcGxhY2UgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhlIGBNaWNyb2AgZWZmZWN0IHdpdGggYHZvaWRgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBhc1ZvaWQgPSBzZWxmID0+IG1hcChzZWxmLCBfID0+IHZvaWQgMCk7XG4vKipcbiAqIEFjY2VzcyB0aGUgYE1pY3JvRXhpdGAgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBleGl0ID0gc2VsZiA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBzZWxmW3J1blN5bWJvbF0oZW52LCBmdW5jdGlvbiAoZXhpdCkge1xuICAgIG9uRXhpdChleGl0U3VjY2VlZChleGl0KSk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFJlcGxhY2UgdGhlIGVycm9yIHR5cGUgb2YgdGhlIGdpdmVuIGBNaWNyb2Agd2l0aCB0aGUgZnVsbCBgTWljcm9DYXVzZWAgb2JqZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzYW5kYm94ID0gc2VsZiA9PiBjYXRjaEFsbENhdXNlKHNlbGYsIGNhdXNlID0+IGZhaWwoY2F1c2UpKTtcbmZ1bmN0aW9uIGZvcmtTaWduYWwoZW52KSB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHBhcmVudFNpZ25hbCA9IGVudkdldChlbnYsIGN1cnJlbnRBYm9ydFNpZ25hbCk7XG4gIGZ1bmN0aW9uIG9uQWJvcnQoKSB7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBhcmVudFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gIH1cbiAgcGFyZW50U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgY29uc3QgZW52V2l0aFNpZ25hbCA9IGVudk11dGF0ZShlbnYsIGZ1bmN0aW9uIChyZWZzKSB7XG4gICAgcmVmc1tjdXJyZW50QWJvcnRDb250cm9sbGVyLmtleV0gPSBjb250cm9sbGVyO1xuICAgIHJlZnNbY3VycmVudEFib3J0U2lnbmFsLmtleV0gPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICByZXR1cm4gcmVmcztcbiAgfSk7XG4gIHJldHVybiBbZW52V2l0aFNpZ25hbCwgb25BYm9ydF07XG59XG4vKipcbiAqIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgcmFjZXMgYWxsIHRoZSBzcGVjaWZpZWQgZWZmZWN0cyxcbiAqIHlpZWxkaW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWZmZWN0IHRvIHN1Y2NlZWQgd2l0aCBhIHZhbHVlLiBMb3NlcnMgb2ZcbiAqIHRoZSByYWNlIHdpbGwgYmUgaW50ZXJydXB0ZWQgaW1tZWRpYXRlbHlcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByYWNlQWxsID0gYWxsID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIGNvbnN0IFtlbnZXaXRoU2lnbmFsLCBvbkFib3J0XSA9IGZvcmtTaWduYWwoZW52KTtcbiAgY29uc3QgZWZmZWN0cyA9IEFycmF5LmZyb20oYWxsKTtcbiAgbGV0IGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgZG9uZSA9IDA7XG4gIGxldCBleGl0ID0gdW5kZWZpbmVkO1xuICBjb25zdCBjYXVzZXMgPSBbXTtcbiAgZnVuY3Rpb24gb25Eb25lKGV4aXRfKSB7XG4gICAgZG9uZSsrO1xuICAgIGlmIChleGl0Xy5fdGFnID09PSBcIlJpZ2h0XCIgJiYgZXhpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZW4gPSBpbmRleDtcbiAgICAgIGV4aXQgPSBleGl0XztcbiAgICAgIG9uQWJvcnQoKTtcbiAgICB9IGVsc2UgaWYgKGV4aXRfLl90YWcgPT09IFwiTGVmdFwiKSB7XG4gICAgICBjYXVzZXMucHVzaChleGl0Xy5sZWZ0KTtcbiAgICB9XG4gICAgaWYgKGRvbmUgPj0gbGVuKSB7XG4gICAgICBvbkV4aXQoZXhpdCA/PyBFaXRoZXIubGVmdChjYXVzZXNbMF0pKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgZWZmZWN0c1tpbmRleF1bcnVuU3ltYm9sXShlbnZXaXRoU2lnbmFsLCBvbkRvbmUpO1xuICB9XG59KTtcbi8qKlxuICogUmV0dXJucyBhbiBlZmZlY3QgdGhhdCByYWNlcyBhbGwgdGhlIHNwZWNpZmllZCBlZmZlY3RzLFxuICogeWllbGRpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlZmZlY3QgdG8gc3VjY2VlZCBvciBmYWlsLiBMb3NlcnMgb2ZcbiAqIHRoZSByYWNlIHdpbGwgYmUgaW50ZXJydXB0ZWQgaW1tZWRpYXRlbHlcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByYWNlQWxsRmlyc3QgPSBhbGwgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3QgW2VudldpdGhTaWduYWwsIG9uQWJvcnRdID0gZm9ya1NpZ25hbChlbnYpO1xuICBjb25zdCBlZmZlY3RzID0gQXJyYXkuZnJvbShhbGwpO1xuICBsZXQgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBkb25lID0gMDtcbiAgbGV0IGV4aXQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IGNhdXNlcyA9IFtdO1xuICBmdW5jdGlvbiBvbkRvbmUoZXhpdF8pIHtcbiAgICBkb25lKys7XG4gICAgaWYgKGV4aXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGVuID0gaW5kZXg7XG4gICAgICBleGl0ID0gZXhpdF87XG4gICAgICBvbkFib3J0KCk7XG4gICAgfVxuICAgIGlmIChkb25lID49IGxlbikge1xuICAgICAgb25FeGl0KGV4aXQgPz8gRWl0aGVyLmxlZnQoY2F1c2VzWzBdKSk7XG4gICAgfVxuICB9XG4gIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgIGVmZmVjdHNbaW5kZXhdW3J1blN5bWJvbF0oZW52V2l0aFNpZ25hbCwgb25Eb25lKTtcbiAgfVxufSk7XG4vKipcbiAqIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgcmFjZXMgdHdvIGVmZmVjdHMsIHlpZWxkaW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3RcbiAqIGVmZmVjdCB0byBzdWNjZWVkLiBMb3NlcnMgb2YgdGhlIHJhY2Ugd2lsbCBiZSBpbnRlcnJ1cHRlZCBpbW1lZGlhdGVseVxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHJhY2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gcmFjZUFsbChbc2VsZiwgdGhhdF0pKTtcbi8qKlxuICogUmV0dXJucyBhbiBlZmZlY3QgdGhhdCByYWNlcyB0d28gZWZmZWN0cywgeWllbGRpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdFxuICogZWZmZWN0IHRvIHN1Y2NlZWQgKm9yKiBmYWlsLiBMb3NlcnMgb2YgdGhlIHJhY2Ugd2lsbCBiZSBpbnRlcnJ1cHRlZCBpbW1lZGlhdGVseVxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHJhY2VGaXJzdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiByYWNlQWxsRmlyc3QoW3NlbGYsIHRoYXRdKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB6aXBwaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIENvbWJpbmUgdHdvIGBNaWNyb2AgZWZmZWN0cyBpbnRvIGEgc2luZ2xlIGVmZmVjdCB0aGF0IHByb2R1Y2VzIGEgdHVwbGUgb2ZcbiAqIHRoZWlyIHJlc3VsdHMuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICovXG5leHBvcnQgY29uc3QgemlwID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMV0pLCAoc2VsZiwgdGhhdCwgb3B0aW9ucykgPT4gemlwV2l0aChzZWxmLCB0aGF0LCAoYSwgYTIpID0+IFthLCBhMl0sIG9wdGlvbnMpKTtcbi8qKlxuICogVGhlIGBNaWNyby56aXBXaXRoYCBmdW5jdGlvbiBjb21iaW5lcyB0d28gYE1pY3JvYCBlZmZlY3RzIGFuZCBhbGxvd3MgeW91IHRvXG4gKiBhcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSByZXN1bHRzIG9mIHRoZSBjb21iaW5lZCBlZmZlY3RzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAc2luY2UgMy40LjNcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB6aXBXaXRoID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMV0pLCAoc2VsZiwgdGhhdCwgZiwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucz8uY29uY3VycmVudCkge1xuICAgIC8vIFVzZSBgYWxsYCBleGNsdXNpdmVseSBmb3IgY29uY3VycmVudCBjYXNlcywgYXMgaXQgaW50cm9kdWNlcyBhZGRpdGlvbmFsIG92ZXJoZWFkIGR1ZSB0byB0aGUgbWFuYWdlbWVudCBvZiBjb25jdXJyZW5jeVxuICAgIHJldHVybiBtYXAoYWxsKFtzZWxmLCB0aGF0XSwge1xuICAgICAgY29uY3VycmVuY3k6IFwidW5ib3VuZGVkXCJcbiAgICB9KSwgKFthLCBhMl0pID0+IGYoYSwgYTIpKTtcbiAgfVxuICByZXR1cm4gZmxhdE1hcChzZWxmLCBhID0+IG1hcCh0aGF0LCBhMiA9PiBmKGEsIGEyKSkpO1xufSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogRmlsdGVyIHRoZSBzcGVjaWZpZWQgZWZmZWN0IHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBmYWlsaW5nIHdpdGggc3BlY2lmaWVkXG4gKiBgTWljcm9DYXVzZWAgaWYgdGhlIHByZWRpY2F0ZSBmYWlscy5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgZmlsdGVyaW5nIGNhcGFiaWxpdGllcyBkaXNjdXNzZWQgZWFybGllciwgeW91IGhhdmUgdGhlIG9wdGlvbiB0byBmdXJ0aGVyXG4gKiByZWZpbmUgYW5kIG5hcnJvdyBkb3duIHRoZSB0eXBlIG9mIHRoZSBzdWNjZXNzIGNoYW5uZWwgYnkgcHJvdmlkaW5nIGFcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck9yRmFpbENhdXNlID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMF0pLCAoc2VsZiwgcmVmaW5lbWVudCwgb3JGYWlsV2l0aCkgPT4gZmxhdE1hcChzZWxmLCBhID0+IHJlZmluZW1lbnQoYSkgPyBzdWNjZWVkKGEpIDogZmFpbENhdXNlKG9yRmFpbFdpdGgoYSkpKSk7XG4vKipcbiAqIEZpbHRlciB0aGUgc3BlY2lmaWVkIGVmZmVjdCB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgZmFpbGluZyB3aXRoIHNwZWNpZmllZFxuICogZXJyb3IgaWYgdGhlIHByZWRpY2F0ZSBmYWlscy5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgZmlsdGVyaW5nIGNhcGFiaWxpdGllcyBkaXNjdXNzZWQgZWFybGllciwgeW91IGhhdmUgdGhlIG9wdGlvbiB0byBmdXJ0aGVyXG4gKiByZWZpbmUgYW5kIG5hcnJvdyBkb3duIHRoZSB0eXBlIG9mIHRoZSBzdWNjZXNzIGNoYW5uZWwgYnkgcHJvdmlkaW5nIGFcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck9yRmFpbCA9IC8qI19fUFVSRV9fKi9kdWFsKGFyZ3MgPT4gaXNNaWNybyhhcmdzWzBdKSwgKHNlbGYsIHJlZmluZW1lbnQsIG9yRmFpbFdpdGgpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiByZWZpbmVtZW50KGEpID8gc3VjY2VlZChhKSA6IGZhaWwob3JGYWlsV2l0aChhKSkpKTtcbi8qKlxuICogVGhlIG1vcmFsIGVxdWl2YWxlbnQgb2YgYGlmIChwKSBleHBgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGZpbHRlcmluZyAmIGNvbmRpdGlvbmFsc1xuICovXG5leHBvcnQgY29uc3Qgd2hlbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBjb25kaXRpb24pID0+IGZsYXRNYXAoaXNNaWNybyhjb25kaXRpb24pID8gY29uZGl0aW9uIDogc3luYyhjb25kaXRpb24pLCBwYXNzID0+IHBhc3MgPyBhc1NvbWUoc2VsZikgOiBzdWNjZWVkKE9wdGlvbi5ub25lKCkpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyByZXBldGl0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYE1pY3JvYCB1c2luZyB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAqXG4gKiBUaGUgYHdoaWxlYCBwcmVkaWNhdGUgd2lsbCBiZSBjaGVja2VkIGFmdGVyIGVhY2ggaXRlcmF0aW9uLCBhbmQgY2FuIHVzZSB0aGVcbiAqIGZhbGwgYE1pY3JvRXhpdGAgb2YgdGhlIGVmZmVjdCB0byBkZXRlcm1pbmUgaWYgdGhlIHJlcGV0aXRpb24gc2hvdWxkIGNvbnRpbnVlLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlcGV0aXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGVhdEV4aXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3Qgc3RhcnRlZEF0ID0gb3B0aW9ucy5zY2hlZHVsZSA/IERhdGUubm93KCkgOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHNlbGZbcnVuU3ltYm9sXShlbnYsIGZ1bmN0aW9uIGxvb3AoZXhpdCkge1xuICAgIGlmIChvcHRpb25zLndoaWxlICE9PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMud2hpbGUoZXhpdCkpIHtcbiAgICAgIHJldHVybiBvbkV4aXQoZXhpdCk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnRpbWVzICE9PSB1bmRlZmluZWQgJiYgYXR0ZW1wdCA+PSBvcHRpb25zLnRpbWVzKSB7XG4gICAgICByZXR1cm4gb25FeGl0KGV4aXQpO1xuICAgIH1cbiAgICBhdHRlbXB0Kys7XG4gICAgbGV0IGRlbGF5RWZmZWN0ID0geWllbGROb3c7XG4gICAgaWYgKG9wdGlvbnMuc2NoZWR1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydGVkQXQ7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IG9wdGlvbnMuc2NoZWR1bGUoYXR0ZW1wdCwgZWxhcHNlZCk7XG4gICAgICBpZiAoT3B0aW9uLmlzTm9uZShkdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG9uRXhpdChleGl0KTtcbiAgICAgIH1cbiAgICAgIGRlbGF5RWZmZWN0ID0gc2xlZXAoZHVyYXRpb24udmFsdWUpO1xuICAgIH1cbiAgICBkZWxheUVmZmVjdFtydW5TeW1ib2xdKGVudiwgZnVuY3Rpb24gKGV4aXQpIHtcbiAgICAgIGlmIChleGl0Ll90YWcgPT09IFwiTGVmdFwiKSB7XG4gICAgICAgIHJldHVybiBvbkV4aXQoZXhpdCk7XG4gICAgICB9XG4gICAgICBzZWxmW3J1blN5bWJvbF0oZW52LCBsb29wKTtcbiAgICB9KTtcbiAgfSk7XG59KSk7XG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QgdXNpbmcgdGhlIHByb3ZpZGVkIG9wdGlvbnMuIE9ubHkgc3VjY2Vzc2Z1bFxuICogcmVzdWx0cyB3aWxsIGJlIHJlcGVhdGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlcGV0aXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGVhdCA9IC8qI19fUFVSRV9fKi9kdWFsKGFyZ3MgPT4gaXNNaWNybyhhcmdzWzBdKSwgKHNlbGYsIG9wdGlvbnMpID0+IHJlcGVhdEV4aXQoc2VsZiwge1xuICAuLi5vcHRpb25zLFxuICB3aGlsZTogZXhpdCA9PiBleGl0Ll90YWcgPT09IFwiUmlnaHRcIiAmJiAob3B0aW9ucz8ud2hpbGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndoaWxlKGV4aXQucmlnaHQpKVxufSkpO1xuLyoqXG4gKiBSZXBlYXQgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IGZvcmV2ZXIsIG9ubHkgc3RvcHBpbmcgaWYgdGhlIGVmZmVjdCBmYWlscy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXBldGl0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JldmVyID0gc2VsZiA9PiByZXBlYXQoc2VsZik7XG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb1NjaGVkdWxlYCB0aGF0IHdpbGwgc3RvcCByZXBlYXRpbmcgYWZ0ZXIgdGhlIHNwZWNpZmllZCBudW1iZXJcbiAqIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNjaGVkdWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlUmVjdXJzID0gbiA9PiBhdHRlbXB0ID0+IGF0dGVtcHQgPD0gbiA/IE9wdGlvbi5zb21lKDApIDogT3B0aW9uLm5vbmUoKTtcbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvU2NoZWR1bGVgIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIGNvbnN0YW50IGRlbGF5LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNjaGVkdWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlU3BhY2VkID0gbWlsbGlzID0+ICgpID0+IE9wdGlvbi5zb21lKG1pbGxpcyk7XG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb1NjaGVkdWxlYCB0aGF0IHdpbGwgZ2VuZXJhdGUgYSBkZWxheSB3aXRoIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVFeHBvbmVudGlhbCA9IChiYXNlTWlsbGlzLCBmYWN0b3IgPSAyKSA9PiBhdHRlbXB0ID0+IE9wdGlvbi5zb21lKE1hdGgucG93KGZhY3RvciwgYXR0ZW1wdCkgKiBiYXNlTWlsbGlzKTtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBgTWljcm9TY2hlZHVsZWAgd2l0aCBhbiBhZGRlZCBjYWxjdWxhdGVkIGRlbGF5IHRvIGVhY2ggZGVsYXlcbiAqIHJldHVybmVkIGJ5IHRoaXMgc2NoZWR1bGUuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVBZGREZWxheSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiAoYXR0ZW1wdCwgZWxhcHNlZCkgPT4gT3B0aW9uLm1hcChzZWxmKGF0dGVtcHQsIGVsYXBzZWQpLCBkdXJhdGlvbiA9PiBkdXJhdGlvbiArIGYoKSkpO1xuLyoqXG4gKiBUcmFuc2Zvcm0gYSBgTWljcm9TY2hlZHVsZWAgdG8gb25lIHRoYXQgd2lsbCBoYXZlIGEgZGVsYXkgdGhhdCB3aWxsIG5ldmVyIGV4Y2VlZFxuICogdGhlIHNwZWNpZmllZCBtYXhpbXVtLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNjaGVkdWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlV2l0aE1heERlbGF5ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG1heCkgPT4gKGF0dGVtcHQsIGVsYXBzZWQpID0+IE9wdGlvbi5tYXAoc2VsZihhdHRlbXB0LCBlbGFwc2VkKSwgZHVyYXRpb24gPT4gTWF0aC5taW4oZHVyYXRpb24sIG1heCkpKTtcbi8qKlxuICogVHJhbnNmb3JtIGEgYE1pY3JvU2NoZWR1bGVgIHRvIG9uZSB0aGF0IHdpbGwgc3RvcCByZXBlYXRpbmcgYWZ0ZXIgdGhlIHNwZWNpZmllZFxuICogYW1vdW50IG9mIHRpbWUuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVXaXRoTWF4RWxhcHNlZCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtYXgpID0+IChhdHRlbXB0LCBlbGFwc2VkKSA9PiBlbGFwc2VkIDwgbWF4ID8gc2VsZihhdHRlbXB0LCBlbGFwc2VkKSA6IE9wdGlvbi5ub25lKCkpO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gYE1pY3JvU2NoZWR1bGVgcywgYnkgcmVjdXJyaW5nIGlmIGVpdGhlciBzY2hlZHVsZSB3YW50cyB0b1xuICogcmVjdXIsIHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSB0d28gZHVyYXRpb25zIGJldHdlZW4gcmVjdXJyZW5jZXMuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVVbmlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiAoYXR0ZW1wdCwgZWxhcHNlZCkgPT4gT3B0aW9uLnppcFdpdGgoc2VsZihhdHRlbXB0LCBlbGFwc2VkKSwgdGhhdChhdHRlbXB0LCBlbGFwc2VkKSwgKGQxLCBkMikgPT4gTWF0aC5taW4oZDEsIGQyKSkpO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gYE1pY3JvU2NoZWR1bGVgcywgYnkgcmVjdXJyaW5nIG9ubHkgaWYgYm90aCBzY2hlZHVsZXMgd2FudCB0b1xuICogcmVjdXIsIHVzaW5nIHRoZSBtYXhpbXVtIG9mIHRoZSB0d28gZHVyYXRpb25zIGJldHdlZW4gcmVjdXJyZW5jZXMuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVJbnRlcnNlY3QgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gKGF0dGVtcHQsIGVsYXBzZWQpID0+IE9wdGlvbi56aXBXaXRoKHNlbGYoYXR0ZW1wdCwgZWxhcHNlZCksIHRoYXQoYXR0ZW1wdCwgZWxhcHNlZCksIChkMSwgZDIpID0+IE1hdGgubWF4KGQxLCBkMikpKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGVycm9yIGhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIENhdGNoIHRoZSBmdWxsIGBNaWNyb0NhdXNlYCBvYmplY3Qgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LCBhbGxvd2luZyB5b3UgdG9cbiAqIHJlY292ZXIgZnJvbSBhbnkga2luZCBvZiBjYXVzZS5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgY2F0Y2hBbGxDYXVzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBjYXRjaENhdXNlSWYoc2VsZiwgY29uc3RUcnVlLCBmKSk7XG4vKipcbiAqIFNlbGVjdGl2ZWx5IGNhdGNoIGEgYE1pY3JvQ2F1c2VgIG9iamVjdCBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QsXG4gKiB1c2luZyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIHRvIGRldGVybWluZSBpZiB0aGUgZmFpbHVyZSBzaG91bGQgYmUgY2F1Z2h0LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaENhdXNlSWYgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgcHJlZGljYXRlLCBmKSA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBzZWxmW3J1blN5bWJvbF0oZW52LCBmdW5jdGlvbiAoZXhpdCkge1xuICAgIGlmIChleGl0Ll90YWcgPT09IFwiUmlnaHRcIiB8fCAhcHJlZGljYXRlKGV4aXQubGVmdCkpIHtcbiAgICAgIG9uRXhpdChleGl0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZihleGl0LmxlZnQpW3J1blN5bWJvbF0oZW52LCBvbkV4aXQpO1xuICAgIH1cbiAgfSk7XG59KSk7XG4vKipcbiAqIENhdGNoIHRoZSBlcnJvciBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QsIGFsbG93aW5nIHlvdSB0byByZWNvdmVyIGZyb20gaXQuXG4gKlxuICogSXQgb25seSBjYXRjaGVzIGV4cGVjdGVkIChgTWljcm9DYXVzZS5GYWlsYCkgZXJyb3JzLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaEFsbCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBjYXRjaEFsbENhdXNlKHNlbGYsIGNhdXNlID0+IGNhdXNlSXNGYWlsKGNhdXNlKSA/IGYoY2F1c2UuZXJyb3IpIDogZmFpbENhdXNlKGNhdXNlKSkpO1xuLyoqXG4gKiBDYXRjaCBhbnkgdW5leHBlY3RlZCBlcnJvcnMgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LCBhbGxvd2luZyB5b3UgdG8gcmVjb3ZlciBmcm9tIHRoZW0uXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdGNoQWxsRGVmZWN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGNhdGNoQ2F1c2VJZihzZWxmLCBjYXVzZUlzRGllLCBkaWUgPT4gZihkaWUuZGVmZWN0KSkpO1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgdXNpbmcgdGhlIGZ1bGwgYE1pY3JvQ2F1c2VgIG9iamVjdCBvZiB0aGUgZ2l2ZW4gYE1pY3JvYC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgdGFwRXJyb3JDYXVzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB0YXBFcnJvckNhdXNlSWYoc2VsZiwgY29uc3RUcnVlLCBmKSk7XG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCB1c2luZyBpZiBhIGBNaWNyb0NhdXNlYCBvYmplY3QgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkXG4gKiBwcmVkaWNhdGUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcEVycm9yQ2F1c2VJZiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCByZWZpbmVtZW50LCBmKSA9PiBjYXRjaENhdXNlSWYoc2VsZiwgcmVmaW5lbWVudCwgY2F1c2UgPT4gYW5kVGhlbihmKGNhdXNlKSwgZmFpbENhdXNlKGNhdXNlKSkpKTtcbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZyb20gZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0YXBFcnJvciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB0YXBFcnJvckNhdXNlSWYoc2VsZiwgY2F1c2VJc0ZhaWwsIGZhaWwgPT4gZihmYWlsLmVycm9yKSkpO1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgZnJvbSB1bmV4cGVjdGVkIGVycm9ycyBvZiB0aGUgZ2l2ZW4gYE1pY3JvYC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgdGFwRGVmZWN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHRhcEVycm9yQ2F1c2VJZihzZWxmLCBjYXVzZUlzRGllLCBkaWUgPT4gZihkaWUuZGVmZWN0KSkpO1xuLyoqXG4gKiBDYXRjaCBhbnkgZXhwZWN0ZWQgZXJyb3JzIHRoYXQgbWF0Y2ggdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdGNoSWYgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgcHJlZGljYXRlLCBmKSA9PiBjYXRjaENhdXNlSWYoc2VsZiwgZiA9PiBjYXVzZUlzRmFpbChmKSAmJiBwcmVkaWNhdGUoZi5lcnJvciksIGZhaWwgPT4gZihmYWlsLmVycm9yKSkpO1xuLyoqXG4gKiBSZWNvdmVycyBmcm9tIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIGVycm9yLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaFRhZyA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBrLCBmKSA9PiBjYXRjaElmKHNlbGYsIGlzVGFnZ2VkKGspLCBmKSk7XG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZnVsbCBgTWljcm9DYXVzZWAgb2JqZWN0IG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgbWFwRXJyb3JDYXVzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBjYXRjaEFsbENhdXNlKHNlbGYsIGNhdXNlID0+IGZhaWxDYXVzZShmKGNhdXNlKSkpKTtcbi8qKlxuICogVHJhbnNmb3JtIGFueSBleHBlY3RlZCBlcnJvcnMgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBFcnJvciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBjYXRjaEFsbChzZWxmLCBlcnJvciA9PiBmYWlsKGYoZXJyb3IpKSkpO1xuLyoqXG4gKiBFbGV2YXRlIGFueSBleHBlY3RlZCBlcnJvcnMgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IHRvIHVuZXhwZWN0ZWQgZXJyb3JzLFxuICogcmVzdWx0aW5nIGluIGFuIGVycm9yIHR5cGUgb2YgYG5ldmVyYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3Qgb3JEaWUgPSBzZWxmID0+IGNhdGNoQWxsKHNlbGYsIGRpZSk7XG4vKipcbiAqIFJlY292ZXIgZnJvbSBhbGwgZXJyb3JzIGJ5IHN1Y2NlZWRpbmcgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRWxzZVN1Y2NlZWQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gY2F0Y2hBbGwoc2VsZiwgXyA9PiBzeW5jKGYpKSk7XG4vKipcbiAqIElnbm9yZSBhbnkgZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCwgcmV0dXJuaW5nIGB2b2lkYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgaWdub3JlID0gc2VsZiA9PiBtYXRjaEVmZmVjdChzZWxmLCB7XG4gIG9uRmFpbHVyZTogXyA9PiB2b2lkXyxcbiAgb25TdWNjZXNzOiBfID0+IHZvaWRfXG59KTtcbi8qKlxuICogSWdub3JlIGFueSBleHBlY3RlZCBlcnJvcnMgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LCByZXR1cm5pbmcgYHZvaWRgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpZ25vcmVMb2dnZWQgPSBzZWxmID0+IG1hdGNoRWZmZWN0KHNlbGYsIHtcbiAgb25GYWlsdXJlOiBlcnJvciA9PiBzeW5jKCgpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKSxcbiAgb25TdWNjZXNzOiBfID0+IHZvaWRfXG59KTtcbi8qKlxuICogUmVwbGFjZSB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3Qgd2l0aCBhbiBgT3B0aW9uYCxcbiAqIHdyYXBwaW5nIHRoZSBzdWNjZXNzIHZhbHVlIGluIGBTb21lYCBhbmQgcmV0dXJuaW5nIGBOb25lYCBpZiB0aGUgZWZmZWN0IGZhaWxzXG4gKiB3aXRoIGFuIGV4cGVjdGVkIGVycm9yLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBvcHRpb24gPSBzZWxmID0+IG1hdGNoKHNlbGYsIHtcbiAgb25GYWlsdXJlOiBfID0+IE9wdGlvbi5ub25lKCksXG4gIG9uU3VjY2VzczogT3B0aW9uLnNvbWVcbn0pO1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBzdWNjZXNzIHZhbHVlIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCB3aXRoIGFuIGBFaXRoZXJgLFxuICogd3JhcHBpbmcgdGhlIHN1Y2Nlc3MgdmFsdWUgaW4gYFJpZ2h0YCBhbmQgd3JhcHBpbmcgYW55IGV4cGVjdGVkIGVycm9ycyB3aXRoXG4gKiBhIGBMZWZ0YC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgZWl0aGVyID0gc2VsZiA9PiBtYXRjaChzZWxmLCB7XG4gIG9uRmFpbHVyZTogRWl0aGVyLmxlZnQsXG4gIG9uU3VjY2VzczogRWl0aGVyLnJpZ2h0XG59KTtcbi8qKlxuICogUmV0cnkgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IHVzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeSA9IC8qI19fUFVSRV9fKi9kdWFsKGFyZ3MgPT4gaXNNaWNybyhhcmdzWzBdKSwgKHNlbGYsIG9wdGlvbnMpID0+IHJlcGVhdEV4aXQoc2VsZiwge1xuICAuLi5vcHRpb25zLFxuICB3aGlsZTogZXhpdCA9PiBleGl0Ll90YWcgPT09IFwiTGVmdFwiICYmIGV4aXQubGVmdC5fdGFnID09PSBcIkZhaWxcIiAmJiAob3B0aW9ucz8ud2hpbGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndoaWxlKGV4aXQubGVmdC5lcnJvcikpXG59KSk7XG4vKipcbiAqIEFkZCBhIHN0YWNrIHRyYWNlIHRvIGFueSBmYWlsdXJlcyB0aGF0IG9jY3VyIGluIHRoZSBlZmZlY3QuIFRoZSB0cmFjZSB3aWxsIGJlXG4gKiBhZGRlZCB0byB0aGUgYHRyYWNlc2AgZmllbGQgb2YgdGhlIGBNaWNyb0NhdXNlYCBvYmplY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcHJldkxpbWl0ID0gZ2xvYmFsVGhpcy5FcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIGdsb2JhbFRoaXMuRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMjtcbiAgY29uc3QgZXJyb3IgPSBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICBnbG9iYWxUaGlzLkVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHByZXZMaW1pdDtcbiAgZnVuY3Rpb24gZ2VuZXJhdGUobmFtZSwgY2F1c2UpIHtcbiAgICBjb25zdCBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIHJldHVybiBjYXVzZTtcbiAgICB9XG4gICAgY29uc3QgbGluZSA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpWzJdPy50cmltKCkucmVwbGFjZSgvXmF0IC8sIFwiXCIpO1xuICAgIGlmICghbGluZSkge1xuICAgICAgcmV0dXJuIGNhdXNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lTWF0Y2ggPSBsaW5lLm1hdGNoKC9cXCgoLiopXFwpJC8pO1xuICAgIHJldHVybiBjYXVzZVdpdGhUcmFjZShjYXVzZSwgYGF0ICR7bmFtZX0gKCR7bGluZU1hdGNoID8gbGluZU1hdGNoWzFdIDogbGluZX0pYCk7XG4gIH1cbiAgY29uc3QgZiA9IG5hbWUgPT4gc2VsZiA9PiB1bnNhZmVNYWtlT3B0aW9ucyhmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgICBzZWxmW3J1blN5bWJvbF0oZW52LCBmdW5jdGlvbiAoZXhpdCkge1xuICAgICAgb25FeGl0KGV4aXQuX3RhZyA9PT0gXCJMZWZ0XCIgPyBFaXRoZXIubGVmdChnZW5lcmF0ZShuYW1lLCBleGl0LmxlZnQpKSA6IGV4aXQpO1xuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGYoYXJndW1lbnRzWzFdKShhcmd1bWVudHNbMF0pO1xuICB9XG4gIHJldHVybiBmKGFyZ3VtZW50c1swXSk7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcGF0dGVybiBtYXRjaGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaENhdXNlRWZmZWN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9wdGlvbnMpID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIHNlbGZbcnVuU3ltYm9sXShlbnYsIGZ1bmN0aW9uIChleGl0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5leHQgPSBleGl0Ll90YWcgPT09IFwiTGVmdFwiID8gb3B0aW9ucy5vbkZhaWx1cmUoZXhpdC5sZWZ0KSA6IG9wdGlvbnMub25TdWNjZXNzKGV4aXQucmlnaHQpO1xuICAgICAgbmV4dFtydW5TeW1ib2xdKGVudiwgb25FeGl0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG9uRXhpdChleGl0RGllKGVycikpO1xuICAgIH1cbiAgfSk7XG59KSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHBhdHRlcm4gbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoQ2F1c2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWF0Y2hDYXVzZUVmZmVjdChzZWxmLCB7XG4gIG9uRmFpbHVyZTogY2F1c2UgPT4gc3luYygoKSA9PiBvcHRpb25zLm9uRmFpbHVyZShjYXVzZSkpLFxuICBvblN1Y2Nlc3M6IHZhbHVlID0+IHN5bmMoKCkgPT4gb3B0aW9ucy5vblN1Y2Nlc3ModmFsdWUpKVxufSkpO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaEVmZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvcHRpb25zKSA9PiBtYXRjaENhdXNlRWZmZWN0KHNlbGYsIHtcbiAgb25GYWlsdXJlOiBjYXVzZSA9PiBjYXVzZS5fdGFnID09PSBcIkZhaWxcIiA/IG9wdGlvbnMub25GYWlsdXJlKGNhdXNlLmVycm9yKSA6IGZhaWxDYXVzZShjYXVzZSksXG4gIG9uU3VjY2Vzczogb3B0aW9ucy5vblN1Y2Nlc3Ncbn0pKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICovXG5leHBvcnQgY29uc3QgbWF0Y2ggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWF0Y2hFZmZlY3Qoc2VsZiwge1xuICBvbkZhaWx1cmU6IGVycm9yID0+IHN5bmMoKCkgPT4gb3B0aW9ucy5vbkZhaWx1cmUoZXJyb3IpKSxcbiAgb25TdWNjZXNzOiB2YWx1ZSA9PiBzeW5jKCgpID0+IG9wdGlvbnMub25TdWNjZXNzKHZhbHVlKSlcbn0pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRlbGF5cyAmIHRpbWVvdXRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb2AgZWZmZWN0IHRoYXQgd2lsbCBzbGVlcCBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkZWxheXMgJiB0aW1lb3V0c1xuICovXG5leHBvcnQgY29uc3Qgc2xlZXAgPSBtaWxsaXMgPT4gYXN5bmMoZnVuY3Rpb24gKHJlc3VtZSkge1xuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmVzdW1lKHZvaWRfKTtcbiAgfSwgbWlsbGlzKTtcbiAgcmV0dXJuIHN5bmMoKCkgPT4ge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgZWZmZWN0IGJ5IHRoZVxuICogc3BlY2lmaWVkIGR1cmF0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRlbGF5cyAmIHRpbWVvdXRzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxheSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtaWxsaXMpID0+IGFuZFRoZW4oc2xlZXAobWlsbGlzKSwgc2VsZikpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgdGhhdCB3aWxsIGV4ZWN1dGUgdGhlXG4gKiBmYWxsYmFjayBlZmZlY3QgaWYgdGhlIHRpbWVvdXQgZWxhcHNlcyBiZWZvcmUgdGhlIGVmZmVjdCBoYXMgcHJvZHVjZWQgYSB2YWx1ZS5cbiAqXG4gKiBJZiB0aGUgdGltZW91dCBlbGFwc2VzLCB0aGUgcnVubmluZyBlZmZlY3Qgd2lsbCBiZSBzYWZlbHkgaW50ZXJydXB0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZGVsYXlzICYgdGltZW91dHNcbiAqL1xuZXhwb3J0IGNvbnN0IHRpbWVvdXRPckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gcmFjZUZpcnN0KHNlbGYsIGFuZFRoZW4oaW50ZXJydXB0aWJsZShzbGVlcChvcHRpb25zLmR1cmF0aW9uKSksIG9wdGlvbnMub25UaW1lb3V0KSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgdGhhdCB3aWxsIGZhaWwgd2l0aCBhXG4gKiBgVGltZW91dEV4Y2VwdGlvbmAgaWYgdGhlIHRpbWVvdXQgZWxhcHNlcyBiZWZvcmUgdGhlIGVmZmVjdCBoYXMgcHJvZHVjZWQgYVxuICogdmFsdWUuXG4gKlxuICogSWYgdGhlIHRpbWVvdXQgZWxhcHNlcywgdGhlIHJ1bm5pbmcgZWZmZWN0IHdpbGwgYmUgc2FmZWx5IGludGVycnVwdGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRlbGF5cyAmIHRpbWVvdXRzXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG1pbGxpcykgPT4gdGltZW91dE9yRWxzZShzZWxmLCB7XG4gIGR1cmF0aW9uOiBtaWxsaXMsXG4gIG9uVGltZW91dDogKCkgPT4gZmFpbChuZXcgVGltZW91dEV4Y2VwdGlvbigpKVxufSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgc3VjY2VlZGluZyB3aXRoIGEgYE5vbmVgXG4gKiBpZiB0aGUgdGltZW91dCBlbGFwc2VzIGJlZm9yZSB0aGUgZWZmZWN0IGhhcyBwcm9kdWNlZCBhIHZhbHVlOyBhbmQgYFNvbWVgIG9mXG4gKiB0aGUgcHJvZHVjZWQgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIElmIHRoZSB0aW1lb3V0IGVsYXBzZXMsIHRoZSBydW5uaW5nIGVmZmVjdCB3aWxsIGJlIHNhZmVseSBpbnRlcnJ1cHRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkZWxheXMgJiB0aW1lb3V0c1xuICovXG5leHBvcnQgY29uc3QgdGltZW91dE9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtaWxsaXMpID0+IHJhY2VGaXJzdChhc1NvbWUoc2VsZiksIGFzKGludGVycnVwdGlibGUoc2xlZXAobWlsbGlzKSksIE9wdGlvbi5ub25lKCkpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb1Njb3BlVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9TY29wZVwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb1Njb3BlID0gLyojX19QVVJFX18qL0NvbnRleHQuR2VuZXJpY1RhZyhcImVmZmVjdC9NaWNyby9NaWNyb1Njb3BlXCIpO1xuY2xhc3MgTWljcm9TY29wZUltcGwge1xuICBbTWljcm9TY29wZVR5cGVJZF07XG4gIHN0YXRlID0ge1xuICAgIF90YWc6IFwiT3BlblwiLFxuICAgIGZpbmFsaXplcnM6IC8qI19fUFVSRV9fKi9uZXcgU2V0KClcbiAgfTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpc1tNaWNyb1Njb3BlVHlwZUlkXSA9IE1pY3JvU2NvcGVUeXBlSWQ7XG4gIH1cbiAgdW5zYWZlQWRkRmluYWxpemVyKGZpbmFsaXplcikge1xuICAgIGlmICh0aGlzLnN0YXRlLl90YWcgPT09IFwiT3BlblwiKSB7XG4gICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbmFsaXplcik7XG4gICAgfVxuICB9XG4gIGFkZEZpbmFsaXplcihmaW5hbGl6ZXIpIHtcbiAgICByZXR1cm4gc3VzcGVuZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5fdGFnID09PSBcIk9wZW5cIikge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbmFsaXplcik7XG4gICAgICAgIHJldHVybiB2b2lkXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5hbGl6ZXIodGhpcy5zdGF0ZS5leGl0KTtcbiAgICB9KTtcbiAgfVxuICB1bnNhZmVSZW1vdmVGaW5hbGl6ZXIoZmluYWxpemVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX3RhZyA9PT0gXCJPcGVuXCIpIHtcbiAgICAgIHRoaXMuc3RhdGUuZmluYWxpemVycy5kZWxldGUoZmluYWxpemVyKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UobWljcm9FeGl0KSB7XG4gICAgcmV0dXJuIHN1c3BlbmQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuX3RhZyA9PT0gXCJPcGVuXCIpIHtcbiAgICAgICAgY29uc3QgZmluYWxpemVycyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZS5maW5hbGl6ZXJzKS5yZXZlcnNlKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgX3RhZzogXCJDbG9zZWRcIixcbiAgICAgICAgICBleGl0OiBtaWNyb0V4aXRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAoZm9yRWFjaChmaW5hbGl6ZXJzLCBmaW5hbGl6ZXIgPT4gZXhpdChmaW5hbGl6ZXIobWljcm9FeGl0KSkpLCBleGl0cyA9PiBhc1ZvaWQoZnJvbUV4aXQoRWl0aGVyLmFsbChleGl0cykpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZF87XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZvcmsoKSB7XG4gICAgcmV0dXJuIHN5bmMoKCkgPT4ge1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBuZXcgTWljcm9TY29wZUltcGwoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLl90YWcgPT09IFwiQ2xvc2VkXCIpIHtcbiAgICAgICAgbmV3U2NvcGUuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICByZXR1cm4gbmV3U2NvcGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmaW4oZXhpdCkge1xuICAgICAgICByZXR1cm4gbmV3U2NvcGUuY2xvc2UoZXhpdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbik7XG4gICAgICBuZXdTY29wZS51bnNhZmVBZGRGaW5hbGl6ZXIoXyA9PiBzeW5jKCgpID0+IHRoaXMudW5zYWZlUmVtb3ZlRmluYWxpemVyKGZpbikpKTtcbiAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlTWFrZSA9IC8qI19fUFVSRV9fKi9zeW5jKCgpID0+IG5ldyBNaWNyb1Njb3BlSW1wbCgpKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzY29wZVVuc2FmZU1ha2UgPSAoKSA9PiBuZXcgTWljcm9TY29wZUltcGwoKTtcbi8qKlxuICogQWNjZXNzIHRoZSBjdXJyZW50IGBNaWNyb1Njb3BlYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlID0gLyojX19QVVJFX18qL3NlcnZpY2UoTWljcm9TY29wZSk7XG4vKipcbiAqIFByb3ZpZGUgYSBgTWljcm9TY29wZWAgdG8gYW4gZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlc291cmNlcyAmIGZpbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgcHJvdmlkZVNjb3BlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHNjb3BlKSA9PiBwcm92aWRlU2VydmljZShzZWxmLCBNaWNyb1Njb3BlLCBzY29wZSkpO1xuLyoqXG4gKiBQcm92aWRlIGEgYE1pY3JvU2NvcGVgIHRvIHRoZSBnaXZlbiBlZmZlY3QsIGNsb3NpbmcgaXQgYWZ0ZXIgdGhlIGVmZmVjdCBoYXNcbiAqIGZpbmlzaGVkIGV4ZWN1dGluZy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlZCA9IHNlbGYgPT4gc3VzcGVuZChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNjb3BlID0gbmV3IE1pY3JvU2NvcGVJbXBsKCk7XG4gIHJldHVybiBvbkV4aXQocHJvdmlkZVNlcnZpY2Uoc2VsZiwgTWljcm9TY29wZSwgc2NvcGUpLCBleGl0ID0+IHNjb3BlLmNsb3NlKGV4aXQpKTtcbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSByZXNvdXJjZSB3aXRoIGEgY2xlYW51cCBgTWljcm9gIGVmZmVjdCwgZW5zdXJpbmcgdGhlIGNsZWFudXAgaXNcbiAqIGV4ZWN1dGVkIHdoZW4gdGhlIGBNaWNyb1Njb3BlYCBpcyBjbG9zZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhY3F1aXJlUmVsZWFzZSA9IChhY3F1aXJlLCByZWxlYXNlKSA9PiB1bmludGVycnVwdGlibGUoZmxhdE1hcChzY29wZSwgc2NvcGUgPT4gdGFwKGFjcXVpcmUsIGEgPT4gc2NvcGUuYWRkRmluYWxpemVyKGV4aXQgPT4gcmVsZWFzZShhLCBleGl0KSkpKSk7XG4vKipcbiAqIEFkZCBhIGZpbmFsaXplciB0byB0aGUgY3VycmVudCBgTWljcm9TY29wZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRGaW5hbGl6ZXIgPSBmaW5hbGl6ZXIgPT4gZmxhdE1hcChzY29wZSwgc2NvcGUgPT4gc2NvcGUuYWRkRmluYWxpemVyKGZpbmFsaXplcikpO1xuLyoqXG4gKiBXaGVuIHRoZSBgTWljcm9gIGVmZmVjdCBpcyBjb21wbGV0ZWQsIHJ1biB0aGUgZ2l2ZW4gZmluYWxpemVyIGVmZmVjdCB3aXRoIHRoZVxuICogYE1pY3JvRXhpdGAgb2YgdGhlIGV4ZWN1dGVkIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG9uRXhpdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBvbkV4aXRJZihzZWxmLCBjb25zdFRydWUsIGYpKTtcbi8qKlxuICogV2hlbiB0aGUgYE1pY3JvYCBlZmZlY3QgaXMgY29tcGxldGVkLCBydW4gdGhlIGdpdmVuIGZpbmFsaXplciBlZmZlY3QgaWYgaXRcbiAqIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBvbkV4aXRJZiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCByZWZpbmVtZW50LCBmKSA9PiB1bmludGVycnVwdGlibGVNYXNrKHJlc3RvcmUgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgcmVzdG9yZShzZWxmKVtydW5TeW1ib2xdKGVudiwgZnVuY3Rpb24gKGV4aXQpIHtcbiAgICBpZiAoIXJlZmluZW1lbnQoZXhpdCkpIHtcbiAgICAgIHJldHVybiBvbkV4aXQoZXhpdCk7XG4gICAgfVxuICAgIGYoZXhpdClbcnVuU3ltYm9sXShlbnYsIGZ1bmN0aW9uIChmaW5hbGl6ZXJFeGl0KSB7XG4gICAgICBpZiAoZmluYWxpemVyRXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgICAgICByZXR1cm4gb25FeGl0KGZpbmFsaXplckV4aXQpO1xuICAgICAgfVxuICAgICAgb25FeGl0KGV4aXQpO1xuICAgIH0pO1xuICB9KTtcbn0pKSk7XG4vKipcbiAqIFJlZ2FyZGxlc3Mgb2YgdGhlIHJlc3VsdCBvZiB0aGUgdGhpcyBgTWljcm9gIGVmZmVjdCwgcnVuIHRoZSBmaW5hbGl6ZXIgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlc291cmNlcyAmIGZpbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgZW5zdXJpbmcgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZmluYWxpemVyKSA9PiBvbkV4aXQoc2VsZiwgXyA9PiBmaW5hbGl6ZXIpKTtcbi8qKlxuICogV2hlbiB0aGUgYE1pY3JvYCBlZmZlY3QgZmFpbHMsIHJ1biB0aGUgZ2l2ZW4gZmluYWxpemVyIGVmZmVjdCB3aXRoIHRoZVxuICogYE1pY3JvQ2F1c2VgIG9mIHRoZSBleGVjdXRlZCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IG9uRXhpdElmKHNlbGYsIGV4aXRJc0ZhaWx1cmUsIGV4aXQgPT4gZihleGl0LmxlZnQpKSk7XG4vKipcbiAqIElmIHRoaXMgYE1pY3JvYCBlZmZlY3QgaXMgYWJvcnRlZCwgcnVuIHRoZSBmaW5hbGl6ZXIgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlc291cmNlcyAmIGZpbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3Qgb25JbnRlcnJ1cHQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZmluYWxpemVyKSA9PiBvbkV4aXRJZihzZWxmLCBleGl0SXNJbnRlcnJ1cHQsIF8gPT4gZmluYWxpemVyKSk7XG4vKipcbiAqIEFjcXVpcmUgYSByZXNvdXJjZSwgdXNlIGl0LCBhbmQgdGhlbiByZWxlYXNlIHRoZSByZXNvdXJjZSB3aGVuIHRoZSBgdXNlYFxuICogZWZmZWN0IGhhcyBjb21wbGV0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhY3F1aXJlVXNlUmVsZWFzZSA9IChhY3F1aXJlLCB1c2UsIHJlbGVhc2UpID0+IHVuaW50ZXJydXB0aWJsZU1hc2socmVzdG9yZSA9PiBmbGF0TWFwKGFjcXVpcmUsIGEgPT4gZmxhdE1hcChleGl0KHJlc3RvcmUodXNlKGEpKSksIGV4aXQgPT4gYW5kVGhlbihyZWxlYXNlKGEsIGV4aXQpLCBmcm9tRXhpdChleGl0KSkpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbnRlcnJ1cHRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQWJvcnQgdGhlIGN1cnJlbnQgYE1pY3JvYCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgaW50ZXJydXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnJ1cHQgPSAvKiNfX1BVUkVfXyovbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3QgY29udHJvbGxlciA9IGVudkdldChlbnYsIGN1cnJlbnRBYm9ydENvbnRyb2xsZXIpO1xuICBjb250cm9sbGVyLmFib3J0KCk7XG4gIG9uRXhpdChleGl0SW50ZXJydXB0KTtcbn0pO1xuLyoqXG4gKiBXcmFwIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCBpbiBhbiB1bmludGVycnVwdGlibGUgcmVnaW9uLCBwcmV2ZW50aW5nIHRoZVxuICogZWZmZWN0IGZyb20gYmVpbmcgYWJvcnRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBpbnRlcnJ1cHRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaW50ZXJydXB0aWJsZSA9IHNlbGYgPT4gdW5zYWZlTWFrZU9wdGlvbnMoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIGNvbnN0IG5leHRFbnYgPSBlbnZNdXRhdGUoZW52LCBmdW5jdGlvbiAoZW52KSB7XG4gICAgZW52W2N1cnJlbnRJbnRlcnJ1cHRpYmxlLmtleV0gPSBmYWxzZTtcbiAgICBlbnZbY3VycmVudEFib3J0U2lnbmFsLmtleV0gPSBuZXcgQWJvcnRDb250cm9sbGVyKCkuc2lnbmFsO1xuICAgIHJldHVybiBlbnY7XG4gIH0pO1xuICBzZWxmW3J1blN5bWJvbF0obmV4dEVudiwgb25FeGl0KTtcbn0sIGZhbHNlKTtcbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QgaW4gYW4gdW5pbnRlcnJ1cHRpYmxlIHJlZ2lvbiwgcHJldmVudGluZyB0aGVcbiAqIGVmZmVjdCBmcm9tIGJlaW5nIGFib3J0ZWQuXG4gKlxuICogWW91IGNhbiB1c2UgdGhlIGByZXN0b3JlYCBmdW5jdGlvbiB0byByZXN0b3JlIGEgYE1pY3JvYCBlZmZlY3QgdG8gdGhlXG4gKiBpbnRlcnJ1cHRpYmlsaXR5IHN0YXRlIGJlZm9yZSB0aGUgYHVuaW50ZXJydXB0aWJsZU1hc2tgIHdhcyBhcHBsaWVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGludGVycnVwdGlvblxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIE1pY3JvIGZyb20gXCJlZmZlY3QvTWljcm9cIlxuICpcbiAqIE1pY3JvLnVuaW50ZXJydXB0aWJsZU1hc2soKHJlc3RvcmUpID0+XG4gKiAgIE1pY3JvLnNsZWVwKDEwMDApLnBpcGUoIC8vIHVuaW50ZXJydXB0aWJsZVxuICogICAgIE1pY3JvLmFuZFRoZW4ocmVzdG9yZShNaWNyby5zbGVlcCgxMDAwKSkpIC8vIGludGVycnVwdGlibGVcbiAqICAgKVxuICogKVxuICovXG5leHBvcnQgY29uc3QgdW5pbnRlcnJ1cHRpYmxlTWFzayA9IGYgPT4gdW5zYWZlTWFrZU9wdGlvbnMoKGVudiwgb25FeGl0KSA9PiB7XG4gIGNvbnN0IGlzSW50ZXJydXB0aWJsZSA9IGVudkdldChlbnYsIGN1cnJlbnRJbnRlcnJ1cHRpYmxlKTtcbiAgY29uc3QgZWZmZWN0ID0gaXNJbnRlcnJ1cHRpYmxlID8gZihpbnRlcnJ1cHRpYmxlKSA6IGYoaWRlbnRpdHkpO1xuICBjb25zdCBuZXh0RW52ID0gaXNJbnRlcnJ1cHRpYmxlID8gZW52TXV0YXRlKGVudiwgZnVuY3Rpb24gKGVudikge1xuICAgIGVudltjdXJyZW50SW50ZXJydXB0aWJsZS5rZXldID0gZmFsc2U7XG4gICAgZW52W2N1cnJlbnRBYm9ydFNpZ25hbC5rZXldID0gbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbDtcbiAgICByZXR1cm4gZW52O1xuICB9KSA6IGVudjtcbiAgZWZmZWN0W3J1blN5bWJvbF0obmV4dEVudiwgb25FeGl0KTtcbn0sIGZhbHNlKTtcbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QgaW4gYW4gaW50ZXJydXB0aWJsZSByZWdpb24sIGFsbG93aW5nIHRoZSBlZmZlY3RcbiAqIHRvIGJlIGFib3J0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgaW50ZXJydXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnJ1cHRpYmxlID0gc2VsZiA9PiBtYWtlKChlbnYsIG9uRXhpdCkgPT4ge1xuICBjb25zdCBpc0ludGVycnVwdGlibGUgPSBlbnZHZXQoZW52LCBjdXJyZW50SW50ZXJydXB0aWJsZSk7XG4gIGxldCBuZXdFbnYgPSBlbnY7XG4gIGlmICghaXNJbnRlcnJ1cHRpYmxlKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGVudkdldChlbnYsIGN1cnJlbnRBYm9ydENvbnRyb2xsZXIpO1xuICAgIG5ld0VudiA9IGVudk11dGF0ZShlbnYsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgIGVudltjdXJyZW50SW50ZXJydXB0aWJsZS5rZXldID0gdHJ1ZTtcbiAgICAgIGVudltjdXJyZW50QWJvcnRTaWduYWwua2V5XSA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgcmV0dXJuIGVudjtcbiAgICB9KTtcbiAgfVxuICBzZWxmW3J1blN5bWJvbF0obmV3RW52LCBvbkV4aXQpO1xufSk7XG4vKipcbiAqIFJ1bnMgYWxsIHRoZSBwcm92aWRlZCBlZmZlY3RzIGluIHNlcXVlbmNlIHJlc3BlY3RpbmcgdGhlIHN0cnVjdHVyZSBwcm92aWRlZCBpbiBpbnB1dC5cbiAqXG4gKiBTdXBwb3J0cyBtdWx0aXBsZSBhcmd1bWVudHMsIGEgc2luZ2xlIGFyZ3VtZW50IHR1cGxlIC8gYXJyYXkgb3IgcmVjb3JkIC8gc3RydWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbGxlY3RpbmcgJiBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3QgYWxsID0gKGFyZywgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8IGlzSXRlcmFibGUoYXJnKSkge1xuICAgIHJldHVybiBmb3JFYWNoKGFyZywgaWRlbnRpdHksIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnM/LmRpc2NhcmQpIHtcbiAgICByZXR1cm4gZm9yRWFjaChPYmplY3QudmFsdWVzKGFyZyksIGlkZW50aXR5LCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gc3VzcGVuZCgoKSA9PiB7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgcmV0dXJuIGFzKGZvckVhY2goT2JqZWN0LmVudHJpZXMoYXJnKSwgKFtrZXksIGVmZmVjdF0pID0+IG1hcChlZmZlY3QsIHZhbHVlID0+IHtcbiAgICAgIG91dFtrZXldID0gdmFsdWU7XG4gICAgfSksIHtcbiAgICAgIGRpc2NhcmQ6IHRydWUsXG4gICAgICBjb25jdXJyZW5jeTogb3B0aW9ucz8uY29uY3VycmVuY3lcbiAgICB9KSwgb3V0KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBGb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBwcm92aWRlZCBpdGVyYWJsZSwgcnVuIHRoZSBlZmZlY3QgYW5kIGNvbGxlY3QgdGhlIHJlc3VsdHMuXG4gKlxuICogSWYgdGhlIGBkaXNjYXJkYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBkaXNjYXJkZWQgYW5kXG4gKiB0aGUgZWZmZWN0IHdpbGwgcmV0dXJuIGB2b2lkYC5cbiAqXG4gKiBUaGUgYGNvbmN1cnJlbmN5YCBvcHRpb24gY2FuIGJlIHNldCB0byBjb250cm9sIGhvdyBtYW55IGVmZmVjdHMgYXJlIHJ1biBpblxuICogcGFyYWxsZWwuIEJ5IGRlZmF1bHQsIHRoZSBlZmZlY3RzIGFyZSBydW4gc2VxdWVudGlhbGx5LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbGxlY3RpbmcgJiBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChpdGVyYWJsZSwgZiwgb3B0aW9ucykgPT4gbWFrZShmdW5jdGlvbiAoZW52LCBvbkV4aXQpIHtcbiAgY29uc3QgY29uY3VycmVuY3lPcHRpb24gPSBvcHRpb25zPy5jb25jdXJyZW5jeSA9PT0gXCJpbmhlcml0XCIgPyBlbnZHZXQoZW52LCBjdXJyZW50Q29uY3VycmVuY3kpIDogb3B0aW9ucz8uY29uY3VycmVuY3kgPz8gMTtcbiAgY29uc3QgY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeU9wdGlvbiA9PT0gXCJ1bmJvdW5kZWRcIiA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE1hdGgubWF4KDEsIGNvbmN1cnJlbmN5T3B0aW9uKTtcbiAgLy8gYWJvcnRcbiAgY29uc3QgW2VudldpdGhTaWduYWwsIG9uQWJvcnRdID0gZm9ya1NpZ25hbChlbnYpO1xuICAvLyBpdGVyYXRlXG4gIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG4gIGxldCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb25FeGl0KEVpdGhlci5yaWdodChvcHRpb25zPy5kaXNjYXJkID8gdW5kZWZpbmVkIDogW10pKTtcbiAgfVxuICBjb25zdCBvdXQgPSBvcHRpb25zPy5kaXNjYXJkID8gdW5kZWZpbmVkIDogbmV3IEFycmF5KGxlbmd0aCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBpblByb2dyZXNzID0gMDtcbiAgbGV0IGRvbmVDb3VudCA9IDA7XG4gIGxldCBwdW1waW5nID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgcHVtcGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGluUHJvZ3Jlc3MgPCBjb25jdXJyZW5jeSAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbY3VycmVudEluZGV4XTtcbiAgICAgIGluZGV4Kys7XG4gICAgICBpblByb2dyZXNzKys7XG4gICAgICB0cnkge1xuICAgICAgICBmKGl0ZW0sIGN1cnJlbnRJbmRleClbcnVuU3ltYm9sXShlbnZXaXRoU2lnbmFsLCBmdW5jdGlvbiAoZXhpdCkge1xuICAgICAgICAgIGlmIChleGl0Ll90YWcgPT09IFwiTGVmdFwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZXhpdDtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gaW5kZXg7XG4gICAgICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdXRbY3VycmVudEluZGV4XSA9IGV4aXQucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbmVDb3VudCsrO1xuICAgICAgICAgIGluUHJvZ3Jlc3MtLTtcbiAgICAgICAgICBpZiAoZG9uZUNvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIG9uRXhpdChyZXN1bHQgPz8gRWl0aGVyLnJpZ2h0KG91dCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXB1bXBpbmcgJiYgaW5Qcm9ncmVzcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBwdW1wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXN1bHQgPSBleGl0RGllKGVycik7XG4gICAgICAgIGxlbmd0aCA9IGluZGV4O1xuICAgICAgICBvbkFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1bXBpbmcgPSBmYWxzZTtcbiAgfVxuICBwdW1wKCk7XG59KTtcbi8qKlxuICogRWZmZWN0ZnVsbHkgZmlsdGVyIHRoZSBlbGVtZW50cyBvZiB0aGUgcHJvdmlkZWQgaXRlcmFibGUuXG4gKlxuICogVXNlIHRoZSBgY29uY3VycmVuY3lgIG9wdGlvbiB0byBjb250cm9sIGhvdyBtYW55IGVsZW1lbnRzIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29sbGVjdGluZyAmIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSAoaXRlcmFibGUsIGYsIG9wdGlvbnMpID0+IGZpbHRlck1hcChpdGVyYWJsZSwgYSA9PiBtYXAoZihhKSwgcGFzcyA9PiB7XG4gIHBhc3MgPSBvcHRpb25zPy5uZWdhdGUgPyAhcGFzcyA6IHBhc3M7XG4gIHJldHVybiBwYXNzID8gT3B0aW9uLnNvbWUoYSkgOiBPcHRpb24ubm9uZSgpO1xufSksIG9wdGlvbnMpO1xuLyoqXG4gKiBFZmZlY3RmdWxseSBmaWx0ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBwcm92aWRlZCBpdGVyYWJsZS5cbiAqXG4gKiBVc2UgdGhlIGBjb25jdXJyZW5jeWAgb3B0aW9uIHRvIGNvbnRyb2wgaG93IG1hbnkgZWxlbWVudHMgYXJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb2xsZWN0aW5nICYgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck1hcCA9IChpdGVyYWJsZSwgZiwgb3B0aW9ucykgPT4gc3VzcGVuZCgoKSA9PiB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICByZXR1cm4gYXMoZm9yRWFjaChpdGVyYWJsZSwgYSA9PiBtYXAoZihhKSwgbyA9PiB7XG4gICAgaWYgKG8uX3RhZyA9PT0gXCJTb21lXCIpIHtcbiAgICAgIG91dC5wdXNoKG8udmFsdWUpO1xuICAgIH1cbiAgfSksIHtcbiAgICBkaXNjYXJkOiB0cnVlLFxuICAgIGNvbmN1cnJlbmN5OiBvcHRpb25zPy5jb25jdXJyZW5jeVxuICB9KSwgb3V0KTtcbn0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZG8gbm90YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogU3RhcnQgYSBkbyBub3RhdGlvbiBibG9jay5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICovXG5leHBvcnQgY29uc3QgRG8gPSAvKiNfX1BVUkVfXyovc3VjY2VlZCh7fSk7XG4vKipcbiAqIEJpbmQgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhpcyBgTWljcm9gIGVmZmVjdCB0byB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICovXG5leHBvcnQgY29uc3QgYmluZFRvID0gLyojX19QVVJFX18qL2RvTm90YXRpb24uYmluZFRvKG1hcCk7XG4vKipcbiAqIEJpbmQgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhpcyBgTWljcm9gIGVmZmVjdCB0byB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICovXG5leHBvcnQgY29uc3QgYmluZCA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmJpbmQobWFwLCBmbGF0TWFwKTtcbmNvbnN0IGxldF8gPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5sZXRfKG1hcCk7XG5leHBvcnQge1xuLyoqXG4gKiBCaW5kIHRoZSByZXN1bHQgb2YgYSBzeW5jaHJvbm91cyBjb21wdXRhdGlvbiB0byB0aGUgZ2l2ZW4gbmFtZS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICovXG5sZXRfIGFzIGxldCB9O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaGFuZGxlICYgZm9ya2luZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBoYW5kbGUgJiBmb3JraW5nXG4gKi9cbmV4cG9ydCBjb25zdCBIYW5kbGVUeXBlSWQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9IYW5kbGVcIik7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGhhbmRsZSAmIGZvcmtpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlzSGFuZGxlID0gdSA9PiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiAmJiB1ICE9PSBudWxsICYmIEhhbmRsZVR5cGVJZCBpbiB1O1xuY2xhc3MgSGFuZGxlSW1wbCB7XG4gIHBhcmVudFNpZ25hbDtcbiAgW0hhbmRsZVR5cGVJZF07XG4gIG9ic2VydmVycyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG4gIF9leGl0ID0gdW5kZWZpbmVkO1xuICBfY29udHJvbGxlcjtcbiAgaXNSb290O1xuICBjb25zdHJ1Y3RvcihwYXJlbnRTaWduYWwsIGNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnBhcmVudFNpZ25hbCA9IHBhcmVudFNpZ25hbDtcbiAgICB0aGlzW0hhbmRsZVR5cGVJZF0gPSBIYW5kbGVUeXBlSWQ7XG4gICAgdGhpcy5pc1Jvb3QgPSBjb250cm9sbGVyICE9PSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IGNvbnRyb2xsZXIgPz8gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmICghdGhpcy5pc1Jvb3QpIHtcbiAgICAgIHBhcmVudFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdGhpcy51bnNhZmVJbnRlcnJ1cHQpO1xuICAgIH1cbiAgfVxuICB1bnNhZmVQb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9leGl0ID8/IG51bGw7XG4gIH1cbiAgdW5zYWZlSW50ZXJydXB0ID0gKCkgPT4ge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfTtcbiAgZW1pdChleGl0KSB7XG4gICAgaWYgKHRoaXMuX2V4aXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXhpdCA9IGV4aXQ7XG4gICAgaWYgKCF0aGlzLmlzUm9vdCkge1xuICAgICAgdGhpcy5wYXJlbnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMudW5zYWZlSW50ZXJydXB0KTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlcihleGl0KSk7XG4gICAgdGhpcy5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBhZGRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIGlmICh0aGlzLl9leGl0KSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXIodGhpcy5fZXhpdCk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gIH1cbiAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICB9XG4gIGdldCBhd2FpdCgpIHtcbiAgICByZXR1cm4gc3VzcGVuZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZXhpdCkge1xuICAgICAgICByZXR1cm4gc3VjY2VlZCh0aGlzLl9leGl0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3luYyhyZXN1bWUgPT4ge1xuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlcihleGl0KSB7XG4gICAgICAgICAgcmVzdW1lKHN1Y2NlZWQoZXhpdCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gc3luYygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGpvaW4oKSB7XG4gICAgcmV0dXJuIGZsYXRNYXAodGhpcy5hd2FpdCwgZnJvbUV4aXQpO1xuICB9XG4gIGdldCBpbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHN1c3BlbmQoKCkgPT4ge1xuICAgICAgdGhpcy51bnNhZmVJbnRlcnJ1cHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmF3YWl0O1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYEhhbmRsZWAgdGhhdCBjYW4gYmUgYXdhaXRlZCwgam9pbmVkLCBvclxuICogYWJvcnRlZC5cbiAqXG4gKiBXaGVuIHRoZSBwYXJlbnQgYE1pY3JvYCBmaW5pc2hlcywgdGhpcyBgTWljcm9gIHdpbGwgYmUgYWJvcnRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBoYW5kbGUgJiBmb3JraW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JrID0gc2VsZiA9PiBtYWtlKGZ1bmN0aW9uIChlbnYsIG9uRXhpdCkge1xuICBjb25zdCBzaWduYWwgPSBlbnZHZXQoZW52LCBjdXJyZW50QWJvcnRTaWduYWwpO1xuICBjb25zdCBoYW5kbGUgPSBuZXcgSGFuZGxlSW1wbChzaWduYWwpO1xuICBjb25zdCBuZXh0RW52ID0gZW52TXV0YXRlKGVudiwgbWFwID0+IHtcbiAgICBtYXBbY3VycmVudEFib3J0Q29udHJvbGxlci5rZXldID0gaGFuZGxlLl9jb250cm9sbGVyO1xuICAgIG1hcFtjdXJyZW50QWJvcnRTaWduYWwua2V5XSA9IGhhbmRsZS5fY29udHJvbGxlci5zaWduYWw7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSk7XG4gIGVudkdldChlbnYsIGN1cnJlbnRTY2hlZHVsZXIpLnNjaGVkdWxlVGFzaygoKSA9PiB7XG4gICAgc2VsZltydW5TeW1ib2xdKG5leHRFbnYsIGV4aXQgPT4ge1xuICAgICAgaGFuZGxlLmVtaXQoZXhpdCk7XG4gICAgfSk7XG4gIH0sIDApO1xuICBvbkV4aXQoRWl0aGVyLnJpZ2h0KGhhbmRsZSkpO1xufSk7XG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYEhhbmRsZWAgdGhhdCBjYW4gYmUgYXdhaXRlZCwgam9pbmVkLCBvclxuICogYWJvcnRlZC5cbiAqXG4gKiBJdCB3aWxsIG5vdCBiZSBhYm9ydGVkIHdoZW4gdGhlIHBhcmVudCBgTWljcm9gIGZpbmlzaGVzLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGhhbmRsZSAmIGZvcmtpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmtEYWVtb24gPSBzZWxmID0+IG1ha2UoZnVuY3Rpb24gKGVudiwgb25FeGl0KSB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IGhhbmRsZSA9IG5ldyBIYW5kbGVJbXBsKGNvbnRyb2xsZXIuc2lnbmFsLCBjb250cm9sbGVyKTtcbiAgY29uc3QgbmV4dEVudiA9IGVudk11dGF0ZShlbnYsIG1hcCA9PiB7XG4gICAgbWFwW2N1cnJlbnRBYm9ydENvbnRyb2xsZXIua2V5XSA9IGNvbnRyb2xsZXI7XG4gICAgbWFwW2N1cnJlbnRBYm9ydFNpZ25hbC5rZXldID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSk7XG4gIGVudkdldChlbnYsIGN1cnJlbnRTY2hlZHVsZXIpLnNjaGVkdWxlVGFzaygoKSA9PiB7XG4gICAgc2VsZltydW5TeW1ib2xdKG5leHRFbnYsIGV4aXQgPT4ge1xuICAgICAgaGFuZGxlLmVtaXQoZXhpdCk7XG4gICAgfSk7XG4gIH0sIDApO1xuICBvbkV4aXQoRWl0aGVyLnJpZ2h0KGhhbmRsZSkpO1xufSk7XG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYEhhbmRsZWAgdGhhdCBjYW4gYmUgYXdhaXRlZCwgam9pbmVkLCBvclxuICogYWJvcnRlZC5cbiAqXG4gKiBUaGUgbGlmZXRpbWUgb2YgdGhlIGhhbmRsZSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCBgTWljcm9TY29wZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgaGFuZGxlICYgZm9ya2luZ1xuICovXG5leHBvcnQgY29uc3QgZm9ya0luID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHNjb3BlKSA9PiB1bmludGVycnVwdGlibGVNYXNrKHJlc3RvcmUgPT4gZmxhdE1hcChzY29wZS5mb3JrLCBzY29wZSA9PiB0YXAocmVzdG9yZShmb3JrRGFlbW9uKG9uRXhpdChzZWxmLCBleGl0ID0+IHNjb3BlLmNsb3NlKGV4aXQpKSkpLCBmaWJlciA9PiBzY29wZS5hZGRGaW5hbGl6ZXIoXyA9PiBhc1ZvaWQoZmliZXIuaW50ZXJydXB0KSkpKSkpO1xuLyoqXG4gKiBSdW4gdGhlIGBNaWNyb2AgZWZmZWN0IGluIGEgbmV3IGBIYW5kbGVgIHRoYXQgY2FuIGJlIGF3YWl0ZWQsIGpvaW5lZCwgb3JcbiAqIGFib3J0ZWQuXG4gKlxuICogVGhlIGxpZmV0aW1lIG9mIHRoZSBoYW5kbGUgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY3VycmVudCBgTWljcm9TY29wZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgaGFuZGxlICYgZm9ya2luZ1xuICovXG5leHBvcnQgY29uc3QgZm9ya1Njb3BlZCA9IHNlbGYgPT4gZmxhdE1hcChzY29wZSwgc2NvcGUgPT4gZm9ya0luKHNlbGYsIHNjb3BlKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBleGVjdXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogRXhlY3V0ZSB0aGUgYE1pY3JvYCBlZmZlY3QgYW5kIHJldHVybiBhIGBIYW5kbGVgIHRoYXQgY2FuIGJlIGF3YWl0ZWQsIGpvaW5lZCxcbiAqIG9yIGFib3J0ZWQuXG4gKlxuICogWW91IGNhbiBsaXN0ZW4gZm9yIHRoZSByZXN1bHQgYnkgYWRkaW5nIGFuIG9ic2VydmVyIHVzaW5nIHRoZSBoYW5kbGUnc1xuICogYGFkZE9ic2VydmVyYCBtZXRob2QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgTWljcm8gZnJvbSBcImVmZmVjdC9NaWNyb1wiXG4gKlxuICogY29uc3QgaGFuZGxlID0gTWljcm8uc3VjY2VlZCg0MikucGlwZShcbiAqICAgTWljcm8uZGVsYXkoMTAwMCksXG4gKiAgIE1pY3JvLnJ1bkZvcmtcbiAqIClcbiAqXG4gKiBoYW5kbGUuYWRkT2JzZXJ2ZXIoKGV4aXQpID0+IHtcbiAqICAgY29uc29sZS5sb2coZXhpdClcbiAqIH0pXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Gb3JrID0gKGVmZmVjdCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdCByZWZzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmVmc1tjdXJyZW50QWJvcnRDb250cm9sbGVyLmtleV0gPSBjb250cm9sbGVyO1xuICByZWZzW2N1cnJlbnRBYm9ydFNpZ25hbC5rZXldID0gY29udHJvbGxlci5zaWduYWw7XG4gIHJlZnNbY3VycmVudFNjaGVkdWxlci5rZXldID0gb3B0aW9ucz8uc2NoZWR1bGVyID8/IG5ldyBNaWNyb1NjaGVkdWxlckRlZmF1bHQoKTtcbiAgY29uc3QgZW52ID0gZW52TWFrZShyZWZzKTtcbiAgY29uc3QgaGFuZGxlID0gbmV3IEhhbmRsZUltcGwoY29udHJvbGxlci5zaWduYWwsIGNvbnRyb2xsZXIpO1xuICBlZmZlY3RbcnVuU3ltYm9sXShlbnZTZXQoZW52LCBjdXJyZW50QWJvcnRTaWduYWwsIGhhbmRsZS5fY29udHJvbGxlci5zaWduYWwpLCBleGl0ID0+IHtcbiAgICBoYW5kbGUuZW1pdChleGl0KTtcbiAgICBpZiAob3B0aW9ucz8uc2lnbmFsKSB7XG4gICAgICBvcHRpb25zLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlLnVuc2FmZUludGVycnVwdCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKG9wdGlvbnM/LnNpZ25hbCkge1xuICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBoYW5kbGUudW5zYWZlSW50ZXJydXB0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBoYW5kbGUudW5zYWZlSW50ZXJydXB0LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbi8qKlxuICogRXhlY3V0ZSB0aGUgYE1pY3JvYCBlZmZlY3QgYW5kIHJldHVybiBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlXG4gKiBgTWljcm9FeGl0YCBvZiB0aGUgY29tcHV0YXRpb24uXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Qcm9taXNlRXhpdCA9IChlZmZlY3QsIG9wdGlvbnMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gIGNvbnN0IGhhbmRsZSA9IHJ1bkZvcmsoZWZmZWN0LCBvcHRpb25zKTtcbiAgaGFuZGxlLmFkZE9ic2VydmVyKHJlc29sdmUpO1xufSk7XG4vKipcbiAqIEV4ZWN1dGUgdGhlIGBNaWNyb2AgZWZmZWN0IGFuZCByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZVxuICogc3VjY2Vzc2Z1bCB2YWx1ZSBvZiB0aGUgY29tcHV0YXRpb24uXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Qcm9taXNlID0gKGVmZmVjdCwgb3B0aW9ucykgPT4gcnVuUHJvbWlzZUV4aXQoZWZmZWN0LCBvcHRpb25zKS50aGVuKGV4aXQgPT4ge1xuICBpZiAoZXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgIHRocm93IGV4aXQubGVmdDtcbiAgfVxuICByZXR1cm4gZXhpdC5yaWdodDtcbn0pO1xuLyoqXG4gKiBBdHRlbXB0IHRvIGV4ZWN1dGUgdGhlIGBNaWNyb2AgZWZmZWN0IHN5bmNocm9ub3VzbHkgYW5kIHJldHVybiB0aGUgYE1pY3JvRXhpdGAuXG4gKlxuICogSWYgYW55IGFzeW5jaHJvbm91cyBlZmZlY3RzIGFyZSBlbmNvdW50ZXJlZCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFcbiAqIGBDYXVzZURpZWAgY29udGFpbmluZyB0aGUgYEhhbmRsZWAuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBydW5TeW5jRXhpdCA9IGVmZmVjdCA9PiB7XG4gIGNvbnN0IHNjaGVkdWxlciA9IG5ldyBNaWNyb1NjaGVkdWxlckRlZmF1bHQoKTtcbiAgY29uc3QgaGFuZGxlID0gcnVuRm9yayhlZmZlY3QsIHtcbiAgICBzY2hlZHVsZXJcbiAgfSk7XG4gIHNjaGVkdWxlci5mbHVzaCgpO1xuICBjb25zdCBleGl0ID0gaGFuZGxlLnVuc2FmZVBvbGwoKTtcbiAgaWYgKGV4aXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZXhpdERpZShoYW5kbGUpO1xuICB9XG4gIHJldHVybiBleGl0O1xufTtcbi8qKlxuICogQXR0ZW1wdCB0byBleGVjdXRlIHRoZSBgTWljcm9gIGVmZmVjdCBzeW5jaHJvbm91c2x5IGFuZCByZXR1cm4gdGhlIHN1Y2Nlc3NcbiAqIHZhbHVlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGV4ZWN1dGlvblxuICovXG5leHBvcnQgY29uc3QgcnVuU3luYyA9IGVmZmVjdCA9PiB7XG4gIGNvbnN0IGV4aXQgPSBydW5TeW5jRXhpdChlZmZlY3QpO1xuICBpZiAoZXhpdC5fdGFnID09PSBcIkxlZnRcIikge1xuICAgIHRocm93IGV4aXQubGVmdDtcbiAgfVxuICByZXR1cm4gZXhpdC5yaWdodDtcbn07XG5jb25zdCBZaWVsZGFibGVFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGNsYXNzIFlpZWxkYWJsZUVycm9yIGV4dGVuZHMgZ2xvYmFsVGhpcy5FcnJvciB7XG4gICAgW3J1blN5bWJvbF0oX2Vudiwgb25FeGl0KSB7XG4gICAgICBvbkV4aXQoZXhpdEZhaWwodGhpcykpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgPyBgJHt0aGlzLm5hbWV9OiAke3RoaXMubWVzc2FnZX1gIDogdGhpcy5uYW1lO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzXG4gICAgICB9O1xuICAgIH1cbiAgICBbTm9kZUluc3BlY3RTeW1ib2xdKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnRvU3RyaW5nKCl9XFxuJHtzdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKS5qb2luKFwiXFxuXCIpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuICBPYmplY3QuYXNzaWduKFlpZWxkYWJsZUVycm9yLnByb3RvdHlwZSwgTWljcm9Qcm90bywgU3RydWN0dXJhbFByb3RvdHlwZSk7XG4gIHJldHVybiBZaWVsZGFibGVFcnJvcjtcbn0oKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjb25zdCBFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGFzcyBleHRlbmRzIFlpZWxkYWJsZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KCk7XG4vKipcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yc1xuICovXG5leHBvcnQgY29uc3QgVGFnZ2VkRXJyb3IgPSB0YWcgPT4ge1xuICBjbGFzcyBCYXNlIGV4dGVuZHMgRXJyb3Ige1xuICAgIF90YWcgPSB0YWc7XG4gIH1cbiAgO1xuICBCYXNlLnByb3RvdHlwZS5uYW1lID0gdGFnO1xuICByZXR1cm4gQmFzZTtcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGVja2VkIGV4Y2VwdGlvbiB3aGljaCBvY2N1cnMgd2hlbiBhbiBleHBlY3RlZCBlbGVtZW50IHdhc1xuICogdW5hYmxlIHRvIGJlIGZvdW5kLlxuICpcbiAqIEBzaW5jZSAzLjQuNFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiBleHRlbmRzIC8qI19fUFVSRV9fKi9UYWdnZWRFcnJvcihcIk5vU3VjaEVsZW1lbnRFeGNlcHRpb25cIikge31cbi8qKlxuICogUmVwcmVzZW50cyBhIGNoZWNrZWQgZXhjZXB0aW9uIHdoaWNoIG9jY3VycyB3aGVuIGEgdGltZW91dCBvY2N1cnMuXG4gKlxuICogQHNpbmNlIDMuNC40XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lb3V0RXhjZXB0aW9uIGV4dGVuZHMgLyojX19QVVJFX18qL1RhZ2dlZEVycm9yKFwiVGltZW91dEV4Y2VwdGlvblwiKSB7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWljcm8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Micro.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Option.js":
/*!************************************************!*\
  !*** ./node_modules/effect/dist/esm/Option.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   ap: () => (/* binding */ ap),\n/* harmony export */   as: () => (/* binding */ as),\n/* harmony export */   asVoid: () => (/* binding */ asVoid),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   composeK: () => (/* binding */ composeK),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   containsWith: () => (/* binding */ containsWith),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   firstSomeOf: () => (/* binding */ firstSomeOf),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   fromIterable: () => (/* binding */ fromIterable),\n/* harmony export */   fromNullable: () => (/* binding */ fromNullable),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   getOrNull: () => (/* binding */ getOrNull),\n/* harmony export */   getOrThrow: () => (/* binding */ getOrThrow),\n/* harmony export */   getOrThrowWith: () => (/* binding */ getOrThrowWith),\n/* harmony export */   getOrUndefined: () => (/* binding */ getOrUndefined),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isOption: () => (/* binding */ isOption),\n/* harmony export */   isSome: () => (/* binding */ isSome),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   lift2: () => (/* binding */ lift2),\n/* harmony export */   liftNullable: () => (/* binding */ liftNullable),\n/* harmony export */   liftPredicate: () => (/* binding */ liftPredicate),\n/* harmony export */   liftThrowable: () => (/* binding */ liftThrowable),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   orElse: () => (/* binding */ orElse),\n/* harmony export */   orElseEither: () => (/* binding */ orElseEither),\n/* harmony export */   orElseSome: () => (/* binding */ orElseSome),\n/* harmony export */   partitionMap: () => (/* binding */ partitionMap),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   reduceCompact: () => (/* binding */ reduceCompact),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toRefinement: () => (/* binding */ toRefinement),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   zipLeft: () => (/* binding */ zipLeft),\n/* harmony export */   zipRight: () => (/* binding */ zipRight),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_either_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/either.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/either.js\");\n/* harmony import */ var _internal_option_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n/* harmony import */ var _Order_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Order.js */ \"(ssr)/./node_modules/effect/dist/esm/Order.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n\n\n\n\n\n\n\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst none = () => _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.none;\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 2.0.0\n */\nconst some = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.some;\n/**\n * Tests if a value is a `Option`.\n *\n * @param input - The value to check.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isOption(Option.some(1)), true)\n * assert.deepStrictEqual(Option.isOption(Option.none()), true)\n * assert.deepStrictEqual(Option.isOption({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isOption = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isOption;\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isNone(Option.some(1)), false)\n * assert.deepStrictEqual(Option.isNone(Option.none()), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNone = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isNone;\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isSome(Option.some(1)), true)\n * assert.deepStrictEqual(Option.isSome(Option.none()), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isSome = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isSome;\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(Option.some(1), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(Option.none(), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nconst match = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, {\n  onNone,\n  onSome\n}) => isNone(self) ? onNone() : onSome(self.value));\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const parsePositive = (n: number): Option.Option<number> =>\n *   n > 0 ? Option.some(n) : Option.none()\n *\n * const isPositive = Option.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toRefinement = f => a => isSome(f(a));\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.fromIterable([1, 2, 3]), Option.some(1))\n * assert.deepStrictEqual(Option.fromIterable([]), Option.none())\n *\n * @category constructors\n * @since 2.0.0\n */\nconst fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return none();\n};\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @example\n * import { Option, Either } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Option.getRight(Either.left('err')), Option.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import { Option, Either } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getLeft(Either.right(\"ok\")), Option.none())\n * assert.deepStrictEqual(Option.getLeft(Either.left(\"a\")), Option.some(\"a\"))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.getLeft;\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(pipe(Option.some(1), Option.getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(Option.none(), Option.getOrElse(() => 0)), 0)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone) => isNone(self) ? onNone() : self.value);\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElse(() => Option.none())\n *   ),\n *   Option.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElse(() => Option.none())\n *   ),\n *   Option.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElse(() => Option.some('b'))\n *   ),\n *   Option.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElse(() => Option.some('b'))\n *   ),\n *   Option.some('a')\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => isNone(self) ? that() : self);\n/**\n * Returns the provided default value as `Some` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElseSome(() => 'b')\n *   ),\n *   Option.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElseSome(() => 'b')\n *   ),\n *   Option.some('a')\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElseSome = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone) => isNone(self) ? some(onNone()) : self);\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 2.0.0\n */\nconst orElseEither = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => isNone(self) ? map(that(), _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.right) : map(self, _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.left));\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.firstSomeOf([Option.none(), Option.some(1), Option.some(2)]), Option.some(1))\n *\n * @category error handling\n * @since 2.0.0\n */\nconst firstSomeOf = collection => {\n  let out = none();\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.fromNullable(undefined), Option.none())\n * assert.deepStrictEqual(Option.fromNullable(null), Option.none())\n * assert.deepStrictEqual(Option.fromNullable(1), Option.some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst fromNullable = nullableValue => nullableValue == null ? none() : some(nullableValue);\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = Option.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), Option.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), Option.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrNull(Option.some(1)), 1)\n * assert.deepStrictEqual(Option.getOrNull(Option.none()), null)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrNull = /*#__PURE__*/getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constNull);\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrUndefined(Option.some(1)), 1)\n * assert.deepStrictEqual(Option.getOrUndefined(Option.none()), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nconst getOrUndefined = /*#__PURE__*/getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constUndefined);\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const parse = Option.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), Option.some(1))\n * assert.deepStrictEqual(parse(\"\"), Option.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nconst liftThrowable = f => (...a) => {\n  try {\n    return some(f(...a));\n  } catch (e) {\n    return none();\n  }\n};\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getOrThrowWith = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone) => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onNone();\n});\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\n * assert.throws(() => Option.getOrThrow(Option.none()))\n *\n * @category conversions\n * @since 2.0.0\n */\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a None\"));\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category mapping\n * @since 2.0.0\n */\nconst map = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isNone(self) ? none() : some(f(self.value)));\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst as = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, b) => map(self, () => b));\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category mapping\n * @since 2.0.0\n */\nconst asVoid = /*#__PURE__*/as(undefined);\nconst void_ = /*#__PURE__*/some(undefined);\n\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * Executes a sequence of two `Option`s. The second `Option` can be dependent on the result of the first `Option`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nconst andThen = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => flatMap(self, a => {\n  const b = (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f) ? f(a) : f;\n  return isOption(b) ? b : some(b);\n}));\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some(employee1),\n *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   Option.some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some(employee2),\n *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   Option.none()\n * )\n *\n * @category sequencing\n * @since 2.0.0\n */\nconst flatMapNullable = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst flatten = /*#__PURE__*/flatMap(_Function_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n/**\n * @category zipping\n * @since 2.0.0\n */\nconst zipRight = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => flatMap(self, () => that));\n/**\n * @category sequencing\n * @since 2.0.0\n */\nconst composeK = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (afb, bfc) => a => flatMap(afb(a), bfc));\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category zipping\n * @since 2.0.0\n */\nconst zipLeft = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => tap(self, () => that));\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n *\n * assert.deepStrictEqual(Option.tap(Option.none(), getInteger), Option.none())\n * assert.deepStrictEqual(Option.tap(Option.some(1), getInteger), Option.some(1))\n * assert.deepStrictEqual(Option.tap(Option.some(1.14), getInteger), Option.none())\n *\n * @category sequencing\n * @since 2.0.0\n */\nconst tap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => flatMap(self, a => map(f(a), () => a)));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  if (isNone(self)) {\n    return none();\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * Takes a structure of `Option`s and returns an `Option` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Option` will contain an array.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.all([Option.some(1), Option.some(2)]), Option.some([1, 2]))\n * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.some(\"hello\") }), Option.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.none() }), Option.none())\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nconst all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const o of input) {\n      if (isNone(o)) {\n        return none();\n      }\n      out.push(o.value);\n    }\n    return some(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const o = input[key];\n    if (isNone(o)) {\n      return none();\n    }\n    out[key] = o.value;\n  }\n  return some(out);\n};\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * import { Option } from \"effect\"\n *\n * type Complex = [real: number, imaginary: number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.none(), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.none(), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.some(1), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.some(2), complex), Option.some([1, 2]))\n *\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), complex)(Option.some(2)), Option.some([2, 1]))\n *\n * @category zipping\n * @since 2.0.0\n */\nconst zipWith = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, that, f) => map(product(self, that), ([a, b]) => f(a, b)));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst ap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n * assert.deepStrictEqual(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)), 3)\n *\n * @category folding\n * @since 2.0.0\n */\nconst reduceCompact = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, b, f) => {\n  let out = b;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out = f(out, oa.value);\n    }\n  }\n  return out;\n});\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.toArray(Option.some(1)), [1])\n * assert.deepStrictEqual(Option.toArray(Option.none()), [])\n *\n * @category conversions\n * @since 2.0.0\n */\nconst toArray = self => isNone(self) ? [] : [self.value];\n/**\n * @category filtering\n * @since 2.0.0\n */\nconst partitionMap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => {\n  if (isNone(self)) {\n    return [none(), none()];\n  }\n  const e = f(self.value);\n  return _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)];\n});\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? Option.some(n) : Option.none()\n *\n * assert.deepStrictEqual(Option.filterMap(Option.none(), evenNumber), Option.none())\n * assert.deepStrictEqual(Option.filterMap(Option.some(3), evenNumber), Option.none())\n * assert.deepStrictEqual(Option.filterMap(Option.some(2), evenNumber), Option.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filterMap = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(Option.filter(Option.none(), isEven), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(3), isEven), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(2), isEven), Option.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(Option.filter(Option.none(), isNumber), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some('hello'), isNumber), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(2), isNumber), Option.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nconst filter = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, predicate) => filterMap(self, b => predicate(b) ? _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.some(b) : _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.none));\n/**\n * @example\n * import { Option, Number } from \"effect\"\n *\n * const isEquivalent = Option.getEquivalence(Number.Equivalence)\n * assert.deepStrictEqual(isEquivalent(Option.none(), Option.none()), true)\n * assert.deepStrictEqual(isEquivalent(Option.none(), Option.some(1)), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.none()), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(2)), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(1)), true)\n *\n * @category equivalence\n * @since 2.0.0\n */\nconst getEquivalence = isEquivalent => _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__.make((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { pipe, Option, Number } from \"effect\"\n *\n * const O = Option.getOrder(Number.Order)\n * assert.deepStrictEqual(O(Option.none(), Option.none()), 0)\n * assert.deepStrictEqual(O(Option.none(), Option.some(1)), -1)\n * assert.deepStrictEqual(O(Option.some(1), Option.none()), 1)\n * assert.deepStrictEqual(O(Option.some(1), Option.some(2)), -1)\n * assert.deepStrictEqual(O(Option.some(1), Option.some(1)), 0)\n *\n * @category sorting\n * @since 2.0.0\n */\nconst getOrder = O => _Order_js__WEBPACK_IMPORTED_MODULE_4__.make((self, that) => isSome(self) ? isSome(that) ? O(self.value, that.value) : 1 : -1);\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 2.0.0\n */\nconst lift2 = f => (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that) => zipWith(self, that, f));\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import { Option } from \"effect\"\n *\n * const getOption = Option.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), Option.none())\n * assert.deepStrictEqual(getOption(1), Option.some(1))\n *\n * @category lifting\n * @since 2.0.0\n */\nconst liftPredicate = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (b, predicate) => predicate(b) ? some(b) : none());\n/**\n * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * import { pipe, Option, Number } from \"effect\"\n *\n * assert.deepStrictEqual(pipe(Option.some(2), Option.containsWith(Number.Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(Option.some(1), Option.containsWith(Number.Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(Option.none(), Option.containsWith(Number.Equivalence)(2)), false)\n *\n * @category elements\n * @since 2.0.0\n */\nconst containsWith = isEquivalent => (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));\nconst _equivalence = /*#__PURE__*/_Equal_js__WEBPACK_IMPORTED_MODULE_5__.equivalence();\n/**\n * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nconst contains = /*#__PURE__*/containsWith(_equivalence);\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * import { pipe, Option } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(Option.some(2), Option.exists(isEven)), true)\n * assert.deepStrictEqual(pipe(Option.some(1), Option.exists(isEven)), false)\n * assert.deepStrictEqual(pipe(Option.none(), Option.exists(isEven)), false)\n *\n * @since 2.0.0\n */\nconst exists = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, refinement) => isNone(self) ? false : refinement(self.value));\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst bindTo = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.bindTo(map);\nconst let_ = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.let_(map);\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst bind = /*#__PURE__*/_internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n *\n * @category do notation\n * @since 2.0.0\n */\nconst Do = /*#__PURE__*/some({});\nconst adapter = /*#__PURE__*/_Utils_js__WEBPACK_IMPORTED_MODULE_7__.adapter();\n/**\n * @category generators\n * @since 2.0.0\n */\nconst gen = (...args) => {\n  let f;\n  if (args.length === 1) {\n    f = args[0];\n  } else {\n    f = args[1].bind(args[0]);\n  }\n  const iterator = f(adapter);\n  let state = iterator.next();\n  if (state.done) {\n    return some(state.value);\n  } else {\n    let current = state.value;\n    if (_Utils_js__WEBPACK_IMPORTED_MODULE_7__.isGenKind(current)) {\n      current = current.value;\n    } else {\n      current = _Utils_js__WEBPACK_IMPORTED_MODULE_7__.yieldWrapGet(current);\n    }\n    if (isNone(current)) {\n      return current;\n    }\n    while (!state.done) {\n      state = iterator.next(current.value);\n      if (!state.done) {\n        current = state.value;\n        if (_Utils_js__WEBPACK_IMPORTED_MODULE_7__.isGenKind(current)) {\n          current = current.value;\n        } else {\n          current = _Utils_js__WEBPACK_IMPORTED_MODULE_7__.yieldWrapGet(current);\n        }\n        if (isNone(current)) {\n          return current;\n        }\n      }\n    }\n    return some(state.value);\n  }\n};\n//# sourceMappingURL=Option.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09wdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNZO0FBQ3NDO0FBQy9CO0FBQ1I7QUFDQTtBQUNYO0FBQ0Y7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQixxREFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sYUFBYSxxREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUJBQWlCLHlEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsdURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSx1REFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLHlDQUF5Qyw0REFBNEQsRUFBRSxHQUFHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDREQUE0RCxFQUFFLEdBQUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLGtEQUFJO0FBQ3RDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtB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LE1BQU07QUFDaEMsc0JBQXNCLE1BQU07QUFDNUI7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCO0FBQ3RDLDZCQUE2Qiw4Q0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVEsZ0RBQWE7QUFDckI7QUFDQSxNQUFNO0FBQ04sZ0JBQWdCLG1EQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBYTtBQUN6QjtBQUNBLFVBQVU7QUFDVixvQkFBb0IsbURBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09wdGlvbi5qcz8xMDc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuL0VxdWFsLmpzXCI7XG5pbXBvcnQgKiBhcyBFcXVpdmFsZW5jZSBmcm9tIFwiLi9FcXVpdmFsZW5jZS5qc1wiO1xuaW1wb3J0IHsgY29uc3ROdWxsLCBjb25zdFVuZGVmaW5lZCwgZHVhbCwgaWRlbnRpdHksIGlzRnVuY3Rpb24gfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgZG9Ob3RhdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9kb05vdGF0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBlaXRoZXIgZnJvbSBcIi4vaW50ZXJuYWwvZWl0aGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBvcHRpb24gZnJvbSBcIi4vaW50ZXJuYWwvb3B0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBvcmRlciBmcm9tIFwiLi9PcmRlci5qc1wiO1xuaW1wb3J0ICogYXMgR2VuIGZyb20gXCIuL1V0aWxzLmpzXCI7XG4vKipcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L09wdGlvblwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgT3B0aW9uYCB0aGF0IHJlcHJlc2VudHMgdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG5vbmUgPSAoKSA9PiBvcHRpb24ubm9uZTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgT3B0aW9uYCB0aGF0IHdyYXBzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSBvcHRpb24uc29tZTtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBPcHRpb25gLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNPcHRpb24oT3B0aW9uLnNvbWUoMSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNPcHRpb24oT3B0aW9uLm5vbmUoKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc09wdGlvbih7fSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNPcHRpb24gPSBvcHRpb24uaXNPcHRpb247XG4vKipcbiAqIERldGVybWluZSBpZiBhIGBPcHRpb25gIGlzIGEgYE5vbmVgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGNoZWNrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc05vbmUoT3B0aW9uLnNvbWUoMSkpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmlzTm9uZShPcHRpb24ubm9uZSgpKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm9uZSA9IG9wdGlvbi5pc05vbmU7XG4vKipcbiAqIERldGVybWluZSBpZiBhIGBPcHRpb25gIGlzIGEgYFNvbWVgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGNoZWNrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc1NvbWUoT3B0aW9uLnNvbWUoMSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNTb21lKE9wdGlvbi5ub25lKCkpLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzU29tZSA9IG9wdGlvbi5pc1NvbWU7XG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIGBPcHRpb25gIGFuZCByZXR1cm5zIGVpdGhlciB0aGUgcHJvdmlkZWQgYG9uTm9uZWAgdmFsdWUgb3IgdGhlIHJlc3VsdCBvZiB0aGUgcHJvdmlkZWQgYG9uU29tZWBcbiAqIGZ1bmN0aW9uIHdoZW4gcGFzc2VkIHRoZSBgT3B0aW9uYCdzIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIG1hdGNoXG4gKiBAcGFyYW0gb25Ob25lIC0gVGhlIHZhbHVlIHRvIGJlIHJldHVybmVkIGlmIHRoZSBgT3B0aW9uYCBpcyBgTm9uZWBcbiAqIEBwYXJhbSBvblNvbWUgLSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBgT3B0aW9uYCBpcyBgU29tZWAsIGl0IHdpbGwgYmUgcGFzc2VkIHRoZSBgT3B0aW9uYCdzIHZhbHVlIGFuZCBpdHMgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcGlwZSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShPcHRpb24uc29tZSgxKSwgT3B0aW9uLm1hdGNoKHsgb25Ob25lOiAoKSA9PiAnYSBub25lJywgb25Tb21lOiAoYSkgPT4gYGEgc29tZSBjb250YWluaW5nICR7YX1gIH0pKSxcbiAqICAgJ2Egc29tZSBjb250YWluaW5nIDEnXG4gKiApXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShPcHRpb24ubm9uZSgpLCBPcHRpb24ubWF0Y2goeyBvbk5vbmU6ICgpID0+ICdhIG5vbmUnLCBvblNvbWU6IChhKSA9PiBgYSBzb21lIGNvbnRhaW5pbmcgJHthfWAgfSkpLFxuICogICAnYSBub25lJ1xuICogKVxuICpcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHtcbiAgb25Ob25lLFxuICBvblNvbWVcbn0pID0+IGlzTm9uZShzZWxmKSA/IG9uTm9uZSgpIDogb25Tb21lKHNlbGYudmFsdWUpKTtcbi8qKlxuICogUmV0dXJucyBhIHR5cGUgZ3VhcmQgZnJvbSBhIGBPcHRpb25gIHJldHVybmluZyBmdW5jdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgdHlwZSBndWFyZCBkZWZpbml0aW9uIGlzIHR5cGUtc2FmZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcGFyc2VQb3NpdGl2ZSA9IChuOiBudW1iZXIpOiBPcHRpb24uT3B0aW9uPG51bWJlcj4gPT5cbiAqICAgbiA+IDAgPyBPcHRpb24uc29tZShuKSA6IE9wdGlvbi5ub25lKClcbiAqXG4gKiBjb25zdCBpc1Bvc2l0aXZlID0gT3B0aW9uLnRvUmVmaW5lbWVudChwYXJzZVBvc2l0aXZlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgxKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgtMSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0b1JlZmluZW1lbnQgPSBmID0+IGEgPT4gaXNTb21lKGYoYSkpO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgSXRlcmFibGVgIG9mIHZhbHVlcyBpbnRvIGFuIGBPcHRpb25gLiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgYEl0ZXJhYmxlYCB3cmFwcGVkIGluIGEgYFNvbWVgXG4gKiBpZiB0aGUgYEl0ZXJhYmxlYCBpcyBub3QgZW1wdHksIG90aGVyd2lzZSByZXR1cm5zIGBOb25lYC5cbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlvbiAtIFRoZSBgSXRlcmFibGVgIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBgT3B0aW9uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbUl0ZXJhYmxlKFsxLCAyLCAzXSksIE9wdGlvbi5zb21lKDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbUl0ZXJhYmxlKFtdKSwgT3B0aW9uLm5vbmUoKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21JdGVyYWJsZSA9IGNvbGxlY3Rpb24gPT4ge1xuICBmb3IgKGNvbnN0IGEgb2YgY29sbGVjdGlvbikge1xuICAgIHJldHVybiBzb21lKGEpO1xuICB9XG4gIHJldHVybiBub25lKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBFaXRoZXJgIHRvIGFuIGBPcHRpb25gIGRpc2NhcmRpbmcgdGhlIGVycm9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24sIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldFJpZ2h0KEVpdGhlci5yaWdodCgnb2snKSksIE9wdGlvbi5zb21lKCdvaycpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZ2V0UmlnaHQoRWl0aGVyLmxlZnQoJ2VycicpKSwgT3B0aW9uLm5vbmUoKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0UmlnaHQgPSBlaXRoZXIuZ2V0UmlnaHQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEVpdGhlcmAgdG8gYW4gYE9wdGlvbmAgZGlzY2FyZGluZyB0aGUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiwgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZ2V0TGVmdChFaXRoZXIucmlnaHQoXCJva1wiKSksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5nZXRMZWZ0KEVpdGhlci5sZWZ0KFwiYVwiKSksIE9wdGlvbi5zb21lKFwiYVwiKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0TGVmdCA9IGVpdGhlci5nZXRMZWZ0O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYE9wdGlvbmAgaWYgaXQgaXMgYFNvbWVgLCBvdGhlcndpc2UgcmV0dXJucyBgb25Ob25lYFxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGdldCB0aGUgdmFsdWUgb2YuXG4gKiBAcGFyYW0gb25Ob25lIC0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiBpZiB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5nZXRPckVsc2UoKCkgPT4gMCkpLCAxKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5ub25lKCksIE9wdGlvbi5nZXRPckVsc2UoKCkgPT4gMCkpLCAwKVxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yRWxzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbk5vbmUpID0+IGlzTm9uZShzZWxmKSA/IG9uTm9uZSgpIDogc2VsZi52YWx1ZSk7XG4vKipcbiAqIFJldHVybnMgdGhlIHByb3ZpZGVkIGBPcHRpb25gIGB0aGF0YCBpZiBgc2VsZmAgaXMgYE5vbmVgLCBvdGhlcndpc2UgcmV0dXJucyBgc2VsZmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgYE9wdGlvbmAgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB0aGF0IC0gVGhlIGBPcHRpb25gIHRvIHJldHVybiBpZiBgc2VsZmAgaXMgYE5vbmVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24ubm9uZSgpKVxuICogICApLFxuICogICBPcHRpb24ubm9uZSgpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24ubm9uZSgpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24uc29tZSgnYicpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYicpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24uc29tZSgnYicpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRWxzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBpc05vbmUoc2VsZikgPyB0aGF0KCkgOiBzZWxmKTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdCB2YWx1ZSBhcyBgU29tZWAgaWYgYHNlbGZgIGlzIGBOb25lYCwgb3RoZXJ3aXNlIHJldHVybnMgYHNlbGZgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGZpcnN0IGBPcHRpb25gIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gb25Ob25lIC0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiBpZiB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZVNvbWUoKCkgPT4gJ2InKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYicpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZVNvbWUoKCkgPT4gJ2InKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRWxzZVNvbWUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb25Ob25lKSA9PiBpc05vbmUoc2VsZikgPyBzb21lKG9uTm9uZSgpKSA6IHNlbGYpO1xuLyoqXG4gKiBTaW1pbGFyIHRvIGBvckVsc2VgLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBzaW1wbGUgdW5pb24sIGl0IHJldHVybnMgYW4gYEVpdGhlcmAgb2JqZWN0LFxuICogd2hpY2ggY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggb2YgdGhlIHR3byBgT3B0aW9uYHMgaGFzIGJlZW4gY2hvc2VuLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gaXQncyBpbXBvcnRhbnQgdG8ga25vdyB3aGV0aGVyIHRoZSB2YWx1ZSB3YXMgcmV0cmlldmVkIGZyb20gdGhlIGZpcnN0IGBPcHRpb25gIG9yIHRoZSBzZWNvbmQgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGZpcnN0IGBPcHRpb25gIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gdGhhdCAtIFRoZSBzZWNvbmQgYE9wdGlvbmAgdG8gYmUgY29uc2lkZXJlZCBpZiB0aGUgZmlyc3QgYE9wdGlvbmAgaXMgYE5vbmVgLlxuICpcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBvckVsc2VFaXRoZXIgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gaXNOb25lKHNlbGYpID8gbWFwKHRoYXQoKSwgZWl0aGVyLnJpZ2h0KSA6IG1hcChzZWxmLCBlaXRoZXIubGVmdCkpO1xuLyoqXG4gKiBHaXZlbiBhbiBgSXRlcmFibGVgIGNvbGxlY3Rpb24gb2YgYE9wdGlvbmBzLCByZXR1cm5zIHRoZSBmaXJzdCBgU29tZWAgZm91bmQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGNvbGxlY3Rpb24gLSBBbiBpdGVyYWJsZSBjb2xsZWN0aW9uIG9mIGBPcHRpb25gIHRvIGJlIHNlYXJjaGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maXJzdFNvbWVPZihbT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDIpXSksIE9wdGlvbi5zb21lKDEpKVxuICpcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaXJzdFNvbWVPZiA9IGNvbGxlY3Rpb24gPT4ge1xuICBsZXQgb3V0ID0gbm9uZSgpO1xuICBmb3IgKG91dCBvZiBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGlzU29tZShvdXQpKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgT3B0aW9uYCBmcm9tIGEgbnVsbGFibGUgdHlwZS4gSWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgcmV0dXJucyBgTm9uZWAsIG90aGVyd2lzZVxuICogcmV0dXJucyB0aGUgdmFsdWUgd3JhcHBlZCBpbiBhIGBTb21lYC5cbiAqXG4gKiBAcGFyYW0gbnVsbGFibGVWYWx1ZSAtIFRoZSBudWxsYWJsZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gYE9wdGlvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZyb21OdWxsYWJsZSh1bmRlZmluZWQpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbU51bGxhYmxlKG51bGwpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbU51bGxhYmxlKDEpLCBPcHRpb24uc29tZSgxKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbU51bGxhYmxlID0gbnVsbGFibGVWYWx1ZSA9PiBudWxsYWJsZVZhbHVlID09IG51bGwgPyBub25lKCkgOiBzb21lKG51bGxhYmxlVmFsdWUpO1xuLyoqXG4gKiBUaGlzIEFQSSBpcyB1c2VmdWwgZm9yIGxpZnRpbmcgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYG51bGxgIG9yIGB1bmRlZmluZWRgIGludG8gdGhlIGBPcHRpb25gIGNvbnRleHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHBhcnNlID0gKHM6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gKiAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHMpXG4gKiAgIHJldHVybiBpc05hTihuKSA/IHVuZGVmaW5lZCA6IG5cbiAqIH1cbiAqXG4gKiBjb25zdCBwYXJzZU9wdGlvbiA9IE9wdGlvbi5saWZ0TnVsbGFibGUocGFyc2UpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwYXJzZU9wdGlvbignMScpLCBPcHRpb24uc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGFyc2VPcHRpb24oJ25vdCBhIG51bWJlcicpLCBPcHRpb24ubm9uZSgpKVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0TnVsbGFibGUgPSBmID0+ICguLi5hKSA9PiBmcm9tTnVsbGFibGUoZiguLi5hKSk7XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpZiBpdCBpcyBhIGBTb21lYCwgb3RoZXJ3aXNlIHJldHVybnMgYG51bGxgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yTnVsbChPcHRpb24uc29tZSgxKSksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5nZXRPck51bGwoT3B0aW9uLm5vbmUoKSksIG51bGwpXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JOdWxsID0gLyojX19QVVJFX18qL2dldE9yRWxzZShjb25zdE51bGwpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYE9wdGlvbmAgaWYgaXQgaXMgYSBgU29tZWAsIG90aGVyd2lzZSByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVW5kZWZpbmVkKE9wdGlvbi5zb21lKDEpKSwgMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVW5kZWZpbmVkKE9wdGlvbi5ub25lKCkpLCB1bmRlZmluZWQpXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JVbmRlZmluZWQgPSAvKiNfX1BVUkVfXyovZ2V0T3JFbHNlKGNvbnN0VW5kZWZpbmVkKTtcbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgbGlmdHMgYSBmdW5jdGlvbiB0aGF0IHRocm93cyBleGNlcHRpb25zIGludG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYE9wdGlvbmAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgZm9yIGFueSBmdW5jdGlvbiB0aGF0IG1pZ2h0IHRocm93IGFuIGV4Y2VwdGlvbiwgYWxsb3dpbmcgdGhlIGRldmVsb3BlciB0byBoYW5kbGVcbiAqIHRoZSBleGNlcHRpb24gaW4gYSBtb3JlIGZ1bmN0aW9uYWwgd2F5LlxuICpcbiAqIEBwYXJhbSBmIC0gdGhlIGZ1bmN0aW9uIHRoYXQgY2FuIHRocm93IGV4Y2VwdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHBhcnNlID0gT3B0aW9uLmxpZnRUaHJvd2FibGUoSlNPTi5wYXJzZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBhcnNlKFwiMVwiKSwgT3B0aW9uLnNvbWUoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBhcnNlKFwiXCIpLCBPcHRpb24ubm9uZSgpKVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0VGhyb3dhYmxlID0gZiA9PiAoLi4uYSkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBzb21lKGYoLi4uYSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5vbmUoKTtcbiAgfVxufTtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG9mIGFuIGBPcHRpb25gIG9yIHRocm93cyBpZiB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgLlxuICpcbiAqIElmIGEgZGVmYXVsdCBlcnJvciBpcyBzdWZmaWNpZW50IGZvciB5b3VyIHVzZSBjYXNlIGFuZCB5b3UgZG9uJ3QgbmVlZCB0byBjb25maWd1cmUgdGhlIHRocm93biBlcnJvciwgc2VlIHtAbGluayBnZXRPclRocm93fS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB0byBleHRyYWN0IHRoZSB2YWx1ZSBmcm9tLlxuICogQHBhcmFtIG9uTm9uZSAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgLiBJdCByZXR1cm5zIHRoZSBlcnJvciB0byBiZSB0aHJvd24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIE9wdGlvbi5nZXRPclRocm93V2l0aChPcHRpb24uc29tZSgxKSwgKCkgPT4gbmV3IEVycm9yKCdVbmV4cGVjdGVkIE5vbmUnKSksXG4gKiAgIDFcbiAqIClcbiAqIGFzc2VydC50aHJvd3MoKCkgPT4gT3B0aW9uLmdldE9yVGhyb3dXaXRoKE9wdGlvbi5ub25lKCksICgpID0+IG5ldyBFcnJvcignVW5leHBlY3RlZCBOb25lJykpKVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPclRocm93V2l0aCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbk5vbmUpID0+IHtcbiAgaWYgKGlzU29tZShzZWxmKSkge1xuICAgIHJldHVybiBzZWxmLnZhbHVlO1xuICB9XG4gIHRocm93IG9uTm9uZSgpO1xufSk7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB2YWx1ZSBvZiBhbiBgT3B0aW9uYCBvciB0aHJvd3MgaWYgdGhlIGBPcHRpb25gIGlzIGBOb25lYC5cbiAqXG4gKiBUaGUgdGhyb3duIGVycm9yIGlzIGEgZGVmYXVsdCBlcnJvci4gVG8gY29uZmlndXJlIHRoZSBlcnJvciB0aHJvd24sIHNlZSAge0BsaW5rIGdldE9yVGhyb3dXaXRofS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB0byBleHRyYWN0IHRoZSB2YWx1ZSBmcm9tLlxuICogQHRocm93cyBgRXJyb3IoXCJnZXRPclRocm93IGNhbGxlZCBvbiBhIE5vbmVcIilgXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVGhyb3coT3B0aW9uLnNvbWUoMSkpLCAxKVxuICogYXNzZXJ0LnRocm93cygoKSA9PiBPcHRpb24uZ2V0T3JUaHJvdyhPcHRpb24ubm9uZSgpKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JUaHJvdyA9IC8qI19fUFVSRV9fKi9nZXRPclRocm93V2l0aCgoKSA9PiBuZXcgRXJyb3IoXCJnZXRPclRocm93IGNhbGxlZCBvbiBhIE5vbmVcIikpO1xuLyoqXG4gKiBNYXBzIHRoZSBgU29tZWAgc2lkZSBvZiBhbiBgT3B0aW9uYCB2YWx1ZSB0byBhIG5ldyBgT3B0aW9uYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIEFuIGBPcHRpb25gIHRvIG1hcFxuICogQHBhcmFtIGYgLSBUaGUgZnVuY3Rpb24gdG8gbWFwIG92ZXIgdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYFxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBpc05vbmUoc2VsZikgPyBub25lKCkgOiBzb21lKGYoc2VsZi52YWx1ZSkpKTtcbi8qKlxuICogTWFwcyB0aGUgYFNvbWVgIHZhbHVlIG9mIHRoaXMgYE9wdGlvbmAgdG8gdGhlIHNwZWNpZmllZCBjb25zdGFudCB2YWx1ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcyA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBiKSA9PiBtYXAoc2VsZiwgKCkgPT4gYikpO1xuLyoqXG4gKiBNYXBzIHRoZSBgU29tZWAgdmFsdWUgb2YgdGhpcyBgT3B0aW9uYCB0byB0aGUgYHZvaWRgIGNvbnN0YW50IHZhbHVlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpcyBub3QgbmVlZGVkLCBidXQgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgdGhlIHZhbHVlIGlzIGltcG9ydGFudC5cbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhc1ZvaWQgPSAvKiNfX1BVUkVfXyovYXModW5kZWZpbmVkKTtcbmNvbnN0IHZvaWRfID0gLyojX19QVVJFX18qL3NvbWUodW5kZWZpbmVkKTtcbmV4cG9ydCB7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52b2lkXyBhcyB2b2lkIH07XG4vKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgdmFsdWUgb2YgYW4gYE9wdGlvbmAgYW5kIGZsYXR0ZW5zIHRoZSByZXN1bHQsIGlmIHRoZSBpbnB1dCBpcyBgU29tZWAuXG4gKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBpc05vbmUoc2VsZikgPyBub25lKCkgOiBmKHNlbGYudmFsdWUpKTtcbi8qKlxuICogRXhlY3V0ZXMgYSBzZXF1ZW5jZSBvZiB0d28gYE9wdGlvbmBzLiBUaGUgc2Vjb25kIGBPcHRpb25gIGNhbiBiZSBkZXBlbmRlbnQgb24gdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgYE9wdGlvbmAuXG4gKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYW5kVGhlbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBmbGF0TWFwKHNlbGYsIGEgPT4ge1xuICBjb25zdCBiID0gaXNGdW5jdGlvbihmKSA/IGYoYSkgOiBmO1xuICByZXR1cm4gaXNPcHRpb24oYikgPyBiIDogc29tZShiKTtcbn0pKTtcbi8qKlxuICogVGhpcyBpcyBgZmxhdE1hcGAgKyBgZnJvbU51bGxhYmxlYCwgdXNlZnVsIHdoZW4gd29ya2luZyB3aXRoIG9wdGlvbmFsIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcGlwZSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogaW50ZXJmYWNlIEVtcGxveWVlIHtcbiAqICAgY29tcGFueT86IHtcbiAqICAgICBhZGRyZXNzPzoge1xuICogICAgICAgc3RyZWV0Pzoge1xuICogICAgICAgICBuYW1lPzogc3RyaW5nXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogY29uc3QgZW1wbG95ZWUxOiBFbXBsb3llZSA9IHsgY29tcGFueTogeyBhZGRyZXNzOiB7IHN0cmVldDogeyBuYW1lOiAnaGlnaCBzdHJlZXQnIH0gfSB9IH1cbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKGVtcGxveWVlMSksXG4gKiAgICAgT3B0aW9uLmZsYXRNYXBOdWxsYWJsZShlbXBsb3llZSA9PiBlbXBsb3llZS5jb21wYW55Py5hZGRyZXNzPy5zdHJlZXQ/Lm5hbWUpLFxuICogICApLFxuICogICBPcHRpb24uc29tZSgnaGlnaCBzdHJlZXQnKVxuICogKVxuICpcbiAqIGNvbnN0IGVtcGxveWVlMjogRW1wbG95ZWUgPSB7IGNvbXBhbnk6IHsgYWRkcmVzczogeyBzdHJlZXQ6IHt9IH0gfSB9XG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBPcHRpb24uc29tZShlbXBsb3llZTIpLFxuICogICAgIE9wdGlvbi5mbGF0TWFwTnVsbGFibGUoZW1wbG95ZWUgPT4gZW1wbG95ZWUuY29tcGFueT8uYWRkcmVzcz8uc3RyZWV0Py5uYW1lKSxcbiAqICAgKSxcbiAqICAgT3B0aW9uLm5vbmUoKVxuICogKVxuICpcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXRNYXBOdWxsYWJsZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBpc05vbmUoc2VsZikgPyBub25lKCkgOiBmcm9tTnVsbGFibGUoZihzZWxmLnZhbHVlKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gLyojX19QVVJFX18qL2ZsYXRNYXAoaWRlbnRpdHkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB6aXBSaWdodCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBmbGF0TWFwKHNlbGYsICgpID0+IHRoYXQpKTtcbi8qKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tcG9zZUsgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoYWZiLCBiZmMpID0+IGEgPT4gZmxhdE1hcChhZmIoYSksIGJmYykpO1xuLyoqXG4gKiBTZXF1ZW5jZXMgdGhlIHNwZWNpZmllZCBgdGhhdGAgYE9wdGlvbmAgYnV0IGlnbm9yZXMgaXRzIHZhbHVlLlxuICpcbiAqIEl0IGlzIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gY2hhaW4gbXVsdGlwbGUgb3BlcmF0aW9ucywgYnV0IG9ubHkgY2FyZSBhYm91dCB0aGUgcmVzdWx0IG9mIGBzZWxmYC5cbiAqXG4gKiBAcGFyYW0gdGhhdCAtIFRoZSBgT3B0aW9uYCB0aGF0IHdpbGwgYmUgaWdub3JlZCBpbiB0aGUgY2hhaW4gYW5kIGRpc2NhcmRlZFxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgd2UgY2FyZSBhYm91dFxuICpcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHppcExlZnQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gdGFwKHNlbGYsICgpID0+IHRoYXQpKTtcbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gYGZgIHRvIHRoZSB2YWx1ZSBvZiB0aGUgYE9wdGlvbmAgaWYgaXQgaXMgYFNvbWVgIGFuZCByZXR1cm5zIHRoZSBvcmlnaW5hbCBgT3B0aW9uYFxuICogdW5sZXNzIGBmYCByZXR1cm5zIGBOb25lYCwgaW4gd2hpY2ggY2FzZSBpdCByZXR1cm5zIGBOb25lYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBmb3IgcGVyZm9ybWluZyBhZGRpdGlvbmFsIGNvbXB1dGF0aW9ucyBvbiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGBPcHRpb25gIHdpdGhvdXQgYWZmZWN0aW5nIGl0cyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZiAtIEZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB2YWx1ZSBvZiB0aGUgYE9wdGlvbmAgaWYgaXQgaXMgYFNvbWVgXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB0byBhcHBseSB0aGUgZnVuY3Rpb24gdG9cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZ2V0SW50ZWdlciA9IChuOiBudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobikgPyBPcHRpb24uc29tZShuKSA6IE9wdGlvbi5ub25lKClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50YXAoT3B0aW9uLm5vbmUoKSwgZ2V0SW50ZWdlciksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50YXAoT3B0aW9uLnNvbWUoMSksIGdldEludGVnZXIpLCBPcHRpb24uc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnRhcChPcHRpb24uc29tZSgxLjE0KSwgZ2V0SW50ZWdlciksIE9wdGlvbi5ub25lKCkpXG4gKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdGFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiBtYXAoZihhKSwgKCkgPT4gYSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0ID0gKHNlbGYsIHRoYXQpID0+IGlzU29tZShzZWxmKSAmJiBpc1NvbWUodGhhdCkgPyBzb21lKFtzZWxmLnZhbHVlLCB0aGF0LnZhbHVlXSkgOiBub25lKCk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjdE1hbnkgPSAoc2VsZiwgY29sbGVjdGlvbikgPT4ge1xuICBpZiAoaXNOb25lKHNlbGYpKSB7XG4gICAgcmV0dXJuIG5vbmUoKTtcbiAgfVxuICBjb25zdCBvdXQgPSBbc2VsZi52YWx1ZV07XG4gIGZvciAoY29uc3QgbyBvZiBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGlzTm9uZShvKSkge1xuICAgICAgcmV0dXJuIG5vbmUoKTtcbiAgICB9XG4gICAgb3V0LnB1c2goby52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNvbWUob3V0KTtcbn07XG4vKipcbiAqIFRha2VzIGEgc3RydWN0dXJlIG9mIGBPcHRpb25gcyBhbmQgcmV0dXJucyBhbiBgT3B0aW9uYCBvZiB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUuXG4gKlxuICogLSBJZiBhIHR1cGxlIGlzIHN1cHBsaWVkLCB0aGVuIHRoZSByZXR1cm5lZCBgT3B0aW9uYCB3aWxsIGNvbnRhaW4gYSB0dXBsZSB3aXRoIHRoZSBzYW1lIGxlbmd0aC5cbiAqIC0gSWYgYSBzdHJ1Y3QgaXMgc3VwcGxpZWQsIHRoZW4gdGhlIHJldHVybmVkIGBPcHRpb25gIHdpbGwgY29udGFpbiBhIHN0cnVjdCB3aXRoIHRoZSBzYW1lIGtleXMuXG4gKiAtIElmIGFuIGl0ZXJhYmxlIGlzIHN1cHBsaWVkLCB0aGVuIHRoZSByZXR1cm5lZCBgT3B0aW9uYCB3aWxsIGNvbnRhaW4gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIGZpZWxkcyAtIHRoZSBzdHJ1Y3Qgb2YgYE9wdGlvbmBzIHRvIGJlIHNlcXVlbmNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uYWxsKFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMildKSwgT3B0aW9uLnNvbWUoWzEsIDJdKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmFsbCh7IGE6IE9wdGlvbi5zb21lKDEpLCBiOiBPcHRpb24uc29tZShcImhlbGxvXCIpIH0pLCBPcHRpb24uc29tZSh7IGE6IDEsIGI6IFwiaGVsbG9cIiB9KSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmFsbCh7IGE6IE9wdGlvbi5zb21lKDEpLCBiOiBPcHRpb24ubm9uZSgpIH0pLCBPcHRpb24ubm9uZSgpKVxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5leHBvcnQgY29uc3QgYWxsID0gaW5wdXQgPT4ge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIGlucHV0KSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIChjb25zdCBvIG9mIGlucHV0KSB7XG4gICAgICBpZiAoaXNOb25lKG8pKSB7XG4gICAgICAgIHJldHVybiBub25lKCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChvLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvbWUob3V0KTtcbiAgfVxuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXQpKSB7XG4gICAgY29uc3QgbyA9IGlucHV0W2tleV07XG4gICAgaWYgKGlzTm9uZShvKSkge1xuICAgICAgcmV0dXJuIG5vbmUoKTtcbiAgICB9XG4gICAgb3V0W2tleV0gPSBvLnZhbHVlO1xuICB9XG4gIHJldHVybiBzb21lKG91dCk7XG59O1xuLyoqXG4gKiBaaXBzIHR3byBgT3B0aW9uYCB2YWx1ZXMgdG9nZXRoZXIgdXNpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiwgcmV0dXJuaW5nIGEgbmV3IGBPcHRpb25gIG9mIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIHppcCBvcGVyYXRpb25cbiAqIEBwYXJhbSB0aGF0IC0gVGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgemlwIG9wZXJhdGlvblxuICogQHBhcmFtIGYgLSBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSB2YWx1ZXMgb2YgdGhlIHR3byBgT3B0aW9uYHNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogdHlwZSBDb21wbGV4ID0gW3JlYWw6IG51bWJlciwgaW1hZ2luYXJ5OiBudW1iZXJdXG4gKlxuICogY29uc3QgY29tcGxleCA9IChyZWFsOiBudW1iZXIsIGltYWdpbmFyeTogbnVtYmVyKTogQ29tcGxleCA9PiBbcmVhbCwgaW1hZ2luYXJ5XVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLm5vbmUoKSwgY29tcGxleCksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi56aXBXaXRoKE9wdGlvbi5zb21lKDEpLCBPcHRpb24ubm9uZSgpLCBjb21wbGV4KSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSksIGNvbXBsZXgpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uemlwV2l0aChPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMiksIGNvbXBsZXgpLCBPcHRpb24uc29tZShbMSwgMl0pKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLnNvbWUoMSksIGNvbXBsZXgpKE9wdGlvbi5zb21lKDIpKSwgT3B0aW9uLnNvbWUoWzIsIDFdKSlcbiAqXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB6aXBXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRoYXQsIGYpID0+IG1hcChwcm9kdWN0KHNlbGYsIHRoYXQpLCAoW2EsIGJdKSA9PiBmKGEsIGIpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gemlwV2l0aChzZWxmLCB0aGF0LCAoZiwgYSkgPT4gZihhKSkpO1xuLyoqXG4gKiBSZWR1Y2VzIGFuIGBJdGVyYWJsZWAgb2YgYE9wdGlvbjxBPmAgdG8gYSBzaW5nbGUgdmFsdWUgb2YgdHlwZSBgQmAsIGVsZW1lbnRzIHRoYXQgYXJlIGBOb25lYCBhcmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBJdGVyYWJsZSBvZiBgT3B0aW9uPEE+YCB0byBiZSByZWR1Y2VkLlxuICogQHBhcmFtIGIgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gKiBAcGFyYW0gZiAtIFRoZSByZWR1Y2luZyBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlIG9mIGFuIGBPcHRpb248QT5gLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBpdGVyYWJsZSA9IFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMiksIE9wdGlvbi5ub25lKCldXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoaXRlcmFibGUsIE9wdGlvbi5yZWR1Y2VDb21wYWN0KDAsIChiLCBhKSA9PiBiICsgYSkpLCAzKVxuICpcbiAqIEBjYXRlZ29yeSBmb2xkaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZHVjZUNvbXBhY3QgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgYiwgZikgPT4ge1xuICBsZXQgb3V0ID0gYjtcbiAgZm9yIChjb25zdCBvYSBvZiBzZWxmKSB7XG4gICAgaWYgKGlzU29tZShvYSkpIHtcbiAgICAgIG91dCA9IGYob3V0LCBvYS52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbi8qKlxuICogVHJhbnNmb3JtcyBhbiBgT3B0aW9uYCBpbnRvIGFuIGBBcnJheWAuXG4gKiBJZiB0aGUgaW5wdXQgaXMgYE5vbmVgLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqIElmIHRoZSBpbnB1dCBpcyBgU29tZWAsIHRoZSB2YWx1ZSBpcyB3cmFwcGVkIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGNvbnZlcnQgdG8gYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnRvQXJyYXkoT3B0aW9uLnNvbWUoMSkpLCBbMV0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50b0FycmF5KE9wdGlvbi5ub25lKCkpLCBbXSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdG9BcnJheSA9IHNlbGYgPT4gaXNOb25lKHNlbGYpID8gW10gOiBbc2VsZi52YWx1ZV07XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcGFydGl0aW9uTWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgaWYgKGlzTm9uZShzZWxmKSkge1xuICAgIHJldHVybiBbbm9uZSgpLCBub25lKCldO1xuICB9XG4gIGNvbnN0IGUgPSBmKHNlbGYudmFsdWUpO1xuICByZXR1cm4gZWl0aGVyLmlzTGVmdChlKSA/IFtzb21lKGUubGVmdCksIG5vbmUoKV0gOiBbbm9uZSgpLCBzb21lKGUucmlnaHQpXTtcbn0pO1xuLyoqXG4gKiBNYXBzIG92ZXIgdGhlIHZhbHVlIG9mIGFuIGBPcHRpb25gIGFuZCBmaWx0ZXJzIG91dCBgTm9uZWBzLlxuICpcbiAqIFVzZWZ1bCB3aGVuIGluIGFkZGl0aW9uIHRvIGZpbHRlcmluZyB5b3UgYWxzbyB3YW50IHRvIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgYE9wdGlvbmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gbWFwIG92ZXIuXG4gKiBAcGFyYW0gZiAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZXZlbk51bWJlciA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwID8gT3B0aW9uLnNvbWUobikgOiBPcHRpb24ubm9uZSgpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyTWFwKE9wdGlvbi5ub25lKCksIGV2ZW5OdW1iZXIpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyTWFwKE9wdGlvbi5zb21lKDMpLCBldmVuTnVtYmVyKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlck1hcChPcHRpb24uc29tZSgyKSwgZXZlbk51bWJlciksIE9wdGlvbi5zb21lKDIpKVxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyTWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTm9uZShzZWxmKSA/IG5vbmUoKSA6IGYoc2VsZi52YWx1ZSkpO1xuLyoqXG4gKiBGaWx0ZXJzIGFuIGBPcHRpb25gIHVzaW5nIGEgcHJlZGljYXRlLiBJZiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQgb3IgdGhlIGBPcHRpb25gIGlzIGBOb25lYCByZXR1cm5zIGBOb25lYC5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIGBPcHRpb25gIGluIGFkZGl0aW9uIHRvIGZpbHRlcmluZywgc2VlIGBmaWx0ZXJNYXBgLlxuICpcbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgYE9wdGlvbmAgdmFsdWUuXG4gKiBAcGFyYW0gZmIgLSBUaGUgYE9wdGlvbmAgdG8gZmlsdGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiAvLyBwcmVkaWNhdGVcbiAqIGNvbnN0IGlzRXZlbiA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyKE9wdGlvbi5ub25lKCksIGlzRXZlbiksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoMyksIGlzRXZlbiksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoMiksIGlzRXZlbiksIE9wdGlvbi5zb21lKDIpKVxuICpcbiAqIC8vIHJlZmluZW1lbnRcbiAqIGNvbnN0IGlzTnVtYmVyID0gKHY6IHVua25vd24pOiB2IGlzIG51bWJlciA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlcihPcHRpb24ubm9uZSgpLCBpc051bWJlciksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoJ2hlbGxvJyksIGlzTnVtYmVyKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlcihPcHRpb24uc29tZSgyKSwgaXNOdW1iZXIpLCBPcHRpb24uc29tZSgyKSlcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IGZpbHRlck1hcChzZWxmLCBiID0+IHByZWRpY2F0ZShiKSA/IG9wdGlvbi5zb21lKGIpIDogb3B0aW9uLm5vbmUpKTtcbi8qKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgaXNFcXVpdmFsZW50ID0gT3B0aW9uLmdldEVxdWl2YWxlbmNlKE51bWJlci5FcXVpdmFsZW5jZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5ub25lKCksIE9wdGlvbi5ub25lKCkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0VxdWl2YWxlbnQoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSkpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5zb21lKDEpLCBPcHRpb24ubm9uZSgpKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRXF1aXZhbGVudChPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMikpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5zb21lKDEpLCBPcHRpb24uc29tZSgxKSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGVxdWl2YWxlbmNlXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVxdWl2YWxlbmNlID0gaXNFcXVpdmFsZW50ID0+IEVxdWl2YWxlbmNlLm1ha2UoKHgsIHkpID0+IGlzTm9uZSh4KSA/IGlzTm9uZSh5KSA6IGlzTm9uZSh5KSA/IGZhbHNlIDogaXNFcXVpdmFsZW50KHgudmFsdWUsIHkudmFsdWUpKTtcbi8qKlxuICogVGhlIGBPcmRlcmAgaW5zdGFuY2UgYWxsb3dzIGBPcHRpb25gIHZhbHVlcyB0byBiZSBjb21wYXJlZCB3aXRoXG4gKiBgY29tcGFyZWAsIHdoZW5ldmVyIHRoZXJlIGlzIGFuIGBPcmRlcmAgaW5zdGFuY2UgZm9yXG4gKiB0aGUgdHlwZSB0aGUgYE9wdGlvbmAgY29udGFpbnMuXG4gKlxuICogYE5vbmVgIGlzIGNvbnNpZGVyZWQgdG8gYmUgbGVzcyB0aGFuIGFueSBgU29tZWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHBpcGUsIE9wdGlvbiwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgTyA9IE9wdGlvbi5nZXRPcmRlcihOdW1iZXIuT3JkZXIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLm5vbmUoKSwgT3B0aW9uLm5vbmUoKSksIDApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSkpLCAtMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTyhPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDIpKSwgLTEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDEpKSwgMClcbiAqXG4gKiBAY2F0ZWdvcnkgc29ydGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPcmRlciA9IE8gPT4gb3JkZXIubWFrZSgoc2VsZiwgdGhhdCkgPT4gaXNTb21lKHNlbGYpID8gaXNTb21lKHRoYXQpID8gTyhzZWxmLnZhbHVlLCB0aGF0LnZhbHVlKSA6IDEgOiAtMSk7XG4vKipcbiAqIExpZnRzIGEgYmluYXJ5IGZ1bmN0aW9uIGludG8gYE9wdGlvbmAuXG4gKlxuICogQHBhcmFtIGYgLSBUaGUgZnVuY3Rpb24gdG8gbGlmdC5cbiAqXG4gKiBAY2F0ZWdvcnkgbGlmdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0MiA9IGYgPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gemlwV2l0aChzZWxmLCB0aGF0LCBmKSk7XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBgUHJlZGljYXRlYCBmdW5jdGlvbiBpbnRvIGEgYFNvbWVgIG9mIHRoZSBpbnB1dCB2YWx1ZSBpZiB0aGUgcHJlZGljYXRlIHJldHVybnMgYHRydWVgIG9yIGBOb25lYFxuICogaWYgdGhlIHByZWRpY2F0ZSByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgYFByZWRpY2F0ZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYEFgIGFuZCByZXR1cm5zIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZ2V0T3B0aW9uID0gT3B0aW9uLmxpZnRQcmVkaWNhdGUoKG46IG51bWJlcikgPT4gbiA+PSAwKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0T3B0aW9uKC0xKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0T3B0aW9uKDEpLCBPcHRpb24uc29tZSgxKSlcbiAqXG4gKiBAY2F0ZWdvcnkgbGlmdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0UHJlZGljYXRlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKGIsIHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKGIpID8gc29tZShiKSA6IG5vbmUoKSk7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGBPcHRpb25gIGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgdXNpbmcgYSBwcm92aWRlZCBgaXNFcXVpdmFsZW50YCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gZXF1aXZhbGVudCAtIEFuIGBFcXVpdmFsZW5jZWAgaW5zdGFuY2UgdG8gY29tcGFyZSB2YWx1ZXMgb2YgdGhlIGBPcHRpb25gLlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gYXBwbHkgdGhlIGNvbXBhcmlzb24gdG8uXG4gKiBAcGFyYW0gYSAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIGBPcHRpb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24sIE51bWJlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24uc29tZSgyKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24uc29tZSgxKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRhaW5zV2l0aCA9IGlzRXF1aXZhbGVudCA9PiBkdWFsKDIsIChzZWxmLCBhKSA9PiBpc05vbmUoc2VsZikgPyBmYWxzZSA6IGlzRXF1aXZhbGVudChzZWxmLnZhbHVlLCBhKSk7XG5jb25zdCBfZXF1aXZhbGVuY2UgPSAvKiNfX1BVUkVfXyovRXF1YWwuZXF1aXZhbGVuY2UoKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFuIGBPcHRpb25gIGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgdXNpbmcgdGhlIGRlZmF1bHQgYEVxdWl2YWxlbmNlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29udGFpbnMgPSAvKiNfX1BVUkVfXyovY29udGFpbnNXaXRoKF9lcXVpdmFsZW5jZSk7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaW4gYW4gYE9wdGlvbmAgdHlwZSBtZWV0cyBhIGNlcnRhaW4gcHJlZGljYXRlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGNoZWNrLlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIFRoZSBjb25kaXRpb24gdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHBpcGUsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzRXZlbiA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5zb21lKDIpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5zb21lKDEpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24ubm9uZSgpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCBmYWxzZSlcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXN0cyA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCByZWZpbmVtZW50KSA9PiBpc05vbmUoc2VsZikgPyBmYWxzZSA6IHJlZmluZW1lbnQoc2VsZi52YWx1ZSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZG8gbm90YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogVGhlIFwiZG8gc2ltdWxhdGlvblwiIGluIEVmZmVjdCBhbGxvd3MgeW91IHRvIHdyaXRlIGNvZGUgaW4gYSBtb3JlIGRlY2xhcmF0aXZlIHN0eWxlLCBzaW1pbGFyIHRvIHRoZSBcImRvIG5vdGF0aW9uXCIgaW4gb3RoZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLiBJdCBwcm92aWRlcyBhIHdheSB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlbSB1c2luZyBmdW5jdGlvbnMgbGlrZSBgYmluZGAgYW5kIGBsZXRgLlxuICpcbiAqIEhlcmUncyBob3cgdGhlIGRvIHNpbXVsYXRpb24gd29ya3M6XG4gKlxuICogMS4gU3RhcnQgdGhlIGRvIHNpbXVsYXRpb24gdXNpbmcgdGhlIGBEb2AgdmFsdWVcbiAqIDIuIFdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiB1c2UgdGhlIGBiaW5kYCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gYE9wdGlvbmAgdmFsdWVzXG4gKiAzLiBZb3UgY2FuIGFjY3VtdWxhdGUgbXVsdGlwbGUgYGJpbmRgIHN0YXRlbWVudHMgdG8gZGVmaW5lIG11bHRpcGxlIHZhcmlhYmxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gKiA0LiBJbnNpZGUgdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBsZXRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBzaW1wbGUgdmFsdWVzXG4gKiA1LiBSZWd1bGFyIGBPcHRpb25gIGZ1bmN0aW9ucyBsaWtlIGBtYXBgIGFuZCBgZmlsdGVyYCBjYW4gc3RpbGwgYmUgdXNlZCB3aXRoaW4gdGhlIGRvIHNpbXVsYXRpb24uIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIHJlY2VpdmUgdGhlIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhcyBhcmd1bWVudHMgd2l0aGluIHRoZSBzY29wZVxuICpcbiAqIEBzZWUge0BsaW5rIERvfVxuICogQHNlZSB7QGxpbmsgYmluZH1cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24sIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBPcHRpb24uRG8sXG4gKiAgIE9wdGlvbi5iaW5kKFwieFwiLCAoKSA9PiBPcHRpb24uc29tZSgyKSksXG4gKiAgIE9wdGlvbi5iaW5kKFwieVwiLCAoKSA9PiBPcHRpb24uc29tZSgzKSksXG4gKiAgIE9wdGlvbi5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSksXG4gKiAgIE9wdGlvbi5maWx0ZXIoKHsgeCwgeSB9KSA9PiB4ICogeSA+IDUpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRUbyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmJpbmRUbyhtYXApO1xuY29uc3QgbGV0XyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmxldF8obWFwKTtcbmV4cG9ydCB7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBpbiBFZmZlY3QgYWxsb3dzIHlvdSB0byB3cml0ZSBjb2RlIGluIGEgbW9yZSBkZWNsYXJhdGl2ZSBzdHlsZSwgc2ltaWxhciB0byB0aGUgXCJkbyBub3RhdGlvblwiIGluIG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcy4gSXQgcHJvdmlkZXMgYSB3YXkgdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYGJpbmRgIGFuZCBgbGV0YC5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBPcHRpb25gIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGJpbmR9XG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IE9wdGlvbiwgcGlwZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpcGUoXG4gKiAgIE9wdGlvbi5EbyxcbiAqICAgT3B0aW9uLmJpbmQoXCJ4XCIsICgpID0+IE9wdGlvbi5zb21lKDIpKSxcbiAqICAgT3B0aW9uLmJpbmQoXCJ5XCIsICgpID0+IE9wdGlvbi5zb21lKDMpKSxcbiAqICAgT3B0aW9uLmxldChcInN1bVwiLCAoeyB4LCB5IH0pID0+IHggKyB5KSxcbiAqICAgT3B0aW9uLmZpbHRlcigoeyB4LCB5IH0pID0+IHggKiB5ID4gNSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBPcHRpb24uc29tZSh7IHg6IDIsIHk6IDMsIHN1bTogNSB9KSlcbiAqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjAuMFxuICovXG5sZXRfIGFzIGxldCB9O1xuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgT3B0aW9uYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqIDUuIFJlZ3VsYXIgYE9wdGlvbmAgZnVuY3Rpb25zIGxpa2UgYG1hcGAgYW5kIGBmaWx0ZXJgIGNhbiBzdGlsbCBiZSB1c2VkIHdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbi4gVGhlc2UgZnVuY3Rpb25zIHdpbGwgcmVjZWl2ZSB0aGUgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGFzIGFyZ3VtZW50cyB3aXRoaW4gdGhlIHNjb3BlXG4gKlxuICogQHNlZSB7QGxpbmsgRG99XG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKiBAc2VlIHtAbGluayBsZXRfIGxldH1cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3B0aW9uLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgT3B0aW9uLkRvLFxuICogICBPcHRpb24uYmluZChcInhcIiwgKCkgPT4gT3B0aW9uLnNvbWUoMikpLFxuICogICBPcHRpb24uYmluZChcInlcIiwgKCkgPT4gT3B0aW9uLnNvbWUoMykpLFxuICogICBPcHRpb24ubGV0KFwic3VtXCIsICh7IHgsIHkgfSkgPT4geCArIHkpLFxuICogICBPcHRpb24uZmlsdGVyKCh7IHgsIHkgfSkgPT4geCAqIHkgPiA1KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKHsgeDogMiwgeTogMywgc3VtOiA1IH0pKVxuICpcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kID0gLyojX19QVVJFX18qL2RvTm90YXRpb24uYmluZChtYXAsIGZsYXRNYXApO1xuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgT3B0aW9uYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqIDUuIFJlZ3VsYXIgYE9wdGlvbmAgZnVuY3Rpb25zIGxpa2UgYG1hcGAgYW5kIGBmaWx0ZXJgIGNhbiBzdGlsbCBiZSB1c2VkIHdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbi4gVGhlc2UgZnVuY3Rpb25zIHdpbGwgcmVjZWl2ZSB0aGUgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGFzIGFyZ3VtZW50cyB3aXRoaW4gdGhlIHNjb3BlXG4gKlxuICogQHNlZSB7QGxpbmsgYmluZFRvfVxuICogQHNlZSB7QGxpbmsgYmluZH1cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBPcHRpb24sIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBPcHRpb24uRG8sXG4gKiAgIE9wdGlvbi5iaW5kKFwieFwiLCAoKSA9PiBPcHRpb24uc29tZSgyKSksXG4gKiAgIE9wdGlvbi5iaW5kKFwieVwiLCAoKSA9PiBPcHRpb24uc29tZSgzKSksXG4gKiAgIE9wdGlvbi5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSksXG4gKiAgIE9wdGlvbi5maWx0ZXIoKHsgeCwgeSB9KSA9PiB4ICogeSA+IDUpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IERvID0gLyojX19QVVJFX18qL3NvbWUoe30pO1xuY29uc3QgYWRhcHRlciA9IC8qI19fUFVSRV9fKi9HZW4uYWRhcHRlcigpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZ2VuZXJhdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZW4gPSAoLi4uYXJncykgPT4ge1xuICBsZXQgZjtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgZiA9IGFyZ3NbMF07XG4gIH0gZWxzZSB7XG4gICAgZiA9IGFyZ3NbMV0uYmluZChhcmdzWzBdKTtcbiAgfVxuICBjb25zdCBpdGVyYXRvciA9IGYoYWRhcHRlcik7XG4gIGxldCBzdGF0ZSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgaWYgKHN0YXRlLmRvbmUpIHtcbiAgICByZXR1cm4gc29tZShzdGF0ZS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzdGF0ZS52YWx1ZTtcbiAgICBpZiAoR2VuLmlzR2VuS2luZChjdXJyZW50KSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBHZW4ueWllbGRXcmFwR2V0KGN1cnJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNOb25lKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgd2hpbGUgKCFzdGF0ZS5kb25lKSB7XG4gICAgICBzdGF0ZSA9IGl0ZXJhdG9yLm5leHQoY3VycmVudC52YWx1ZSk7XG4gICAgICBpZiAoIXN0YXRlLmRvbmUpIHtcbiAgICAgICAgY3VycmVudCA9IHN0YXRlLnZhbHVlO1xuICAgICAgICBpZiAoR2VuLmlzR2VuS2luZChjdXJyZW50KSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQgPSBHZW4ueWllbGRXcmFwR2V0KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vbmUoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc29tZShzdGF0ZS52YWx1ZSk7XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcHRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Option.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Order.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Order.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Date: () => (/* binding */ Date),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   combineAll: () => (/* binding */ combineAll),\n/* harmony export */   combineMany: () => (/* binding */ combineMany),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   greaterThan: () => (/* binding */ greaterThan),\n/* harmony export */   greaterThanOrEqualTo: () => (/* binding */ greaterThanOrEqualTo),\n/* harmony export */   lessThan: () => (/* binding */ lessThan),\n/* harmony export */   lessThanOrEqualTo: () => (/* binding */ lessThanOrEqualTo),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   reverse: () => (/* binding */ reverse),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   tuple: () => (/* binding */ tuple)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\n * An order is defined by a relation `<=`, which obeys the following laws:\n *\n * - either `x <= y` or `y <= x` (totality)\n * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n *\n * The truth table for compare is defined as follows:\n *\n * | `x <= y` | `x >= y` | Ordering |                       |\n * | -------- | -------- | -------- | --------------------- |\n * | `true`   | `true`   | `0`      | corresponds to x == y |\n * | `true`   | `false`  | `< 0`    | corresponds to x < y  |\n * | `false`  | `true`   | `> 0`    | corresponds to x > y  |\n *\n * @since 2.0.0\n */\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst make = compare => (self, that) => self === that ? 0 : compare(self, that);\n/**\n * @category instances\n * @since 2.0.0\n */\nconst string = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nconst number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nconst boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nconst bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @since 2.0.0\n */\nconst reverse = O => make((self, that) => O(that, self));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combine = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => make((a1, a2) => {\n  const out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  return that(a1, a2);\n}));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineMany = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection) => make((a1, a2) => {\n  let out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  for (const O of collection) {\n    out = O(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n  }\n  return out;\n}));\n/**\n * @since 2.0.0\n */\nconst empty = () => make(() => 0);\n/**\n * @category combining\n * @since 2.0.0\n */\nconst combineAll = collection => combineMany(empty(), collection);\n/**\n * @category mapping\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f) => make((b1, b2) => self(f(b1), f(b2))));\n/**\n * @category instances\n * @since 2.0.0\n */\nconst Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => make(([xa, xb], [ya, yb]) => {\n  const o = self(xa, ya);\n  return o !== 0 ? o : that(xb, yb);\n}));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const O of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      const o = O(x[collectionLength], y[collectionLength]);\n      if (o !== 0) {\n        return o;\n      }\n      collectionLength++;\n    }\n    return 0;\n  });\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection) => {\n  const O = all(collection);\n  return make((x, y) => {\n    const o = self(x[0], y[0]);\n    return o !== 0 ? o : O(x.slice(1), y.slice(1));\n  });\n});\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst array = O => make((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number(aLen, bLen);\n});\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      const o = fields[key](self[key], that[key]);\n      if (o !== 0) {\n        return o;\n      }\n    }\n    return 0;\n  });\n};\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */\nconst lessThan = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => O(self, that) === -1);\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */\nconst greaterThan = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => O(self, that) === 1);\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */\nconst lessThanOrEqualTo = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => O(self, that) !== 1);\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */\nconst greaterThanOrEqualTo = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => O(self, that) !== -1);\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nconst min = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => self === that || O(self, that) < 1 ? self : that);\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nconst max = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => self === that || O(self, that) > -1 ? self : that);\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @example\n * import { Order, Number } from \"effect\"\n *\n * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n *\n * @since 2.0.0\n */\nconst clamp = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */\nconst between = O => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));\n//# sourceMappingURL=Order.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09yZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsa0RBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxrREFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLGtEQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixrREFBSTtBQUN4QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsa0RBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0Isa0RBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixrREFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGtEQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0Msa0RBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlCQUFpQixrREFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUJBQWlCLGtEQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLGtEQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsa0RBQUk7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vT3JkZXIuanM/NGMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgT3JkZXJgIHR5cGUgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBkZWZpbmUgYSB0b3RhbCBvcmRlcmluZyBvbiBzb21lIHR5cGUgYEFgLlxuICogQW4gb3JkZXIgaXMgZGVmaW5lZCBieSBhIHJlbGF0aW9uIGA8PWAsIHdoaWNoIG9iZXlzIHRoZSBmb2xsb3dpbmcgbGF3czpcbiAqXG4gKiAtIGVpdGhlciBgeCA8PSB5YCBvciBgeSA8PSB4YCAodG90YWxpdHkpXG4gKiAtIGlmIGB4IDw9IHlgIGFuZCBgeSA8PSB4YCwgdGhlbiBgeCA9PSB5YCAoYW50aXN5bW1ldHJ5KVxuICogLSBpZiBgeCA8PSB5YCBhbmQgYHkgPD0gemAsIHRoZW4gYHggPD0gemAgKHRyYW5zaXRpdml0eSlcbiAqXG4gKiBUaGUgdHJ1dGggdGFibGUgZm9yIGNvbXBhcmUgaXMgZGVmaW5lZCBhcyBmb2xsb3dzOlxuICpcbiAqIHwgYHggPD0geWAgfCBgeCA+PSB5YCB8IE9yZGVyaW5nIHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYHRydWVgICAgfCBgdHJ1ZWAgICB8IGAwYCAgICAgIHwgY29ycmVzcG9uZHMgdG8geCA9PSB5IHxcbiAqIHwgYHRydWVgICAgfCBgZmFsc2VgICB8IGA8IDBgICAgIHwgY29ycmVzcG9uZHMgdG8geCA8IHkgIHxcbiAqIHwgYGZhbHNlYCAgfCBgdHJ1ZWAgICB8IGA+IDBgICAgIHwgY29ycmVzcG9uZHMgdG8geCA+IHkgIHxcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0IHsgZHVhbCB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG4vKipcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFrZSA9IGNvbXBhcmUgPT4gKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgPyAwIDogY29tcGFyZShzZWxmLCB0aGF0KTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSAvKiNfX1BVUkVfXyovbWFrZSgoc2VsZiwgdGhhdCkgPT4gc2VsZiA8IHRoYXQgPyAtMSA6IDEpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IC8qI19fUFVSRV9fKi9tYWtlKChzZWxmLCB0aGF0KSA9PiBzZWxmIDwgdGhhdCA/IC0xIDogMSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbiA9IC8qI19fUFVSRV9fKi9tYWtlKChzZWxmLCB0aGF0KSA9PiBzZWxmIDwgdGhhdCA/IC0xIDogMSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYmlnaW50ID0gLyojX19QVVJFX18qL21ha2UoKHNlbGYsIHRoYXQpID0+IHNlbGYgPCB0aGF0ID8gLTEgOiAxKTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZXZlcnNlID0gTyA9PiBtYWtlKChzZWxmLCB0aGF0KSA9PiBPKHRoYXQsIHNlbGYpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IG1ha2UoKGExLCBhMikgPT4ge1xuICBjb25zdCBvdXQgPSBzZWxmKGExLCBhMik7XG4gIGlmIChvdXQgIT09IDApIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiB0aGF0KGExLCBhMik7XG59KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tYmluZU1hbnkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgY29sbGVjdGlvbikgPT4gbWFrZSgoYTEsIGEyKSA9PiB7XG4gIGxldCBvdXQgPSBzZWxmKGExLCBhMik7XG4gIGlmIChvdXQgIT09IDApIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZvciAoY29uc3QgTyBvZiBjb2xsZWN0aW9uKSB7XG4gICAgb3V0ID0gTyhhMSwgYTIpO1xuICAgIGlmIChvdXQgIT09IDApIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59KSk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZW1wdHkgPSAoKSA9PiBtYWtlKCgpID0+IDApO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVBbGwgPSBjb2xsZWN0aW9uID0+IGNvbWJpbmVNYW55KGVtcHR5KCksIGNvbGxlY3Rpb24pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJbnB1dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBtYWtlKChiMSwgYjIpID0+IHNlbGYoZihiMSksIGYoYjIpKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IERhdGUgPSAvKiNfX1BVUkVfXyovbWFwSW5wdXQobnVtYmVyLCBkYXRlID0+IGRhdGUuZ2V0VGltZSgpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IG1ha2UoKFt4YSwgeGJdLCBbeWEsIHliXSkgPT4ge1xuICBjb25zdCBvID0gc2VsZih4YSwgeWEpO1xuICByZXR1cm4gbyAhPT0gMCA/IG8gOiB0aGF0KHhiLCB5Yik7XG59KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWxsID0gY29sbGVjdGlvbiA9PiB7XG4gIHJldHVybiBtYWtlKCh4LCB5KSA9PiB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBsZXQgY29sbGVjdGlvbkxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBPIG9mIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uTGVuZ3RoID49IGxlbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSBPKHhbY29sbGVjdGlvbkxlbmd0aF0sIHlbY29sbGVjdGlvbkxlbmd0aF0pO1xuICAgICAgaWYgKG8gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBjb2xsZWN0aW9uTGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjdE1hbnkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgY29sbGVjdGlvbikgPT4ge1xuICBjb25zdCBPID0gYWxsKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gbWFrZSgoeCwgeSkgPT4ge1xuICAgIGNvbnN0IG8gPSBzZWxmKHhbMF0sIHlbMF0pO1xuICAgIHJldHVybiBvICE9PSAwID8gbyA6IE8oeC5zbGljZSgxKSwgeS5zbGljZSgxKSk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFNpbWlsYXIgdG8gYFByb21pc2UuYWxsYCBidXQgb3BlcmF0ZXMgb24gYE9yZGVyYHMuXG4gKlxuICogYGBgXG4gKiBbT3JkZXI8QT4sIE9yZGVyPEI+LCAuLi5dIC0+IE9yZGVyPFtBLCBCLCAuLi5dPlxuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBPcmRlcmAgZm9yIGEgdHVwbGUgb2YgdmFsdWVzIGJhc2VkIG9uIHRoZSBnaXZlbiBgT3JkZXJgcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSB0dXBsZS5cbiAqIFRoZSByZXR1cm5lZCBgT3JkZXJgIGNvbXBhcmVzIHR3byB0dXBsZXMgb2YgdGhlIHNhbWUgdHlwZSBieSBhcHBseWluZyB0aGUgY29ycmVzcG9uZGluZyBgT3JkZXJgIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgdHVwbGUuXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb21wYXJlIHR3byB0dXBsZXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgeW91IGhhdmUgYSBzcGVjaWZpYyB3YXkgb2YgY29tcGFyaW5nIGVhY2ggZWxlbWVudFxuICogb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZSA9ICguLi5lbGVtZW50cykgPT4gYWxsKGVsZW1lbnRzKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBPcmRlcmAgZm9yIGFuIGFycmF5IG9mIHZhbHVlcyBiYXNlZCBvbiBhIGdpdmVuIGBPcmRlcmAgZm9yIHRoZSBlbGVtZW50cyBvZiB0aGUgYXJyYXkuXG4gKiBUaGUgcmV0dXJuZWQgYE9yZGVyYCBjb21wYXJlcyB0d28gYXJyYXlzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBgT3JkZXJgIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlzLlxuICogSWYgYWxsIGVsZW1lbnRzIGFyZSBlcXVhbCwgdGhlIGFycmF5cyBhcmUgdGhlbiBjb21wYXJlZCBiYXNlZCBvbiB0aGVpciBsZW5ndGguXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb21wYXJlIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgeW91IGhhdmUgYSBzcGVjaWZpYyB3YXkgb2YgY29tcGFyaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFycmF5ID0gTyA9PiBtYWtlKChzZWxmLCB0aGF0KSA9PiB7XG4gIGNvbnN0IGFMZW4gPSBzZWxmLmxlbmd0aDtcbiAgY29uc3QgYkxlbiA9IHRoYXQubGVuZ3RoO1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihhTGVuLCBiTGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IG8gPSBPKHNlbGZbaV0sIHRoYXRbaV0pO1xuICAgIGlmIChvICE9PSAwKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcihhTGVuLCBiTGVuKTtcbn0pO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYE9yZGVyYCBmb3IgYSBzdHJ1Y3Qgb2YgdmFsdWVzIGJhc2VkIG9uIHRoZSBnaXZlbiBgT3JkZXJgc1xuICogZm9yIGVhY2ggcHJvcGVydHkgaW4gdGhlIHN0cnVjdC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc3RydWN0ID0gZmllbGRzID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gIHJldHVybiBtYWtlKChzZWxmLCB0aGF0KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgbyA9IGZpZWxkc1trZXldKHNlbGZba2V5XSwgdGhhdFtrZXldKTtcbiAgICAgIGlmIChvICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9zdHJpY3RseSBsZXNzIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZXNzVGhhbiA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSA9PT0gLTEpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9zdHJpY3RseSBncmVhdGVyIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbiA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSA9PT0gMSk7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBvbmUgdmFsdWUgaXMgX25vbi1zdHJpY3RseSBsZXNzIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZXNzVGhhbk9yRXF1YWxUbyA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSAhPT0gMSk7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBvbmUgdmFsdWUgaXMgX25vbi1zdHJpY3RseSBncmVhdGVyIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbk9yRXF1YWxUbyA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSAhPT0gLTEpO1xuLyoqXG4gKiBUYWtlIHRoZSBtaW5pbXVtIG9mIHR3byB2YWx1ZXMuIElmIHRoZXkgYXJlIGNvbnNpZGVyZWQgZXF1YWwsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBjaG9zZW4uXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtaW4gPSBPID0+IGR1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgfHwgTyhzZWxmLCB0aGF0KSA8IDEgPyBzZWxmIDogdGhhdCk7XG4vKipcbiAqIFRha2UgdGhlIG1heGltdW0gb2YgdHdvIHZhbHVlcy4gSWYgdGhleSBhcmUgY29uc2lkZXJlZCBlcXVhbCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGNob3Nlbi5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1heCA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gc2VsZiA9PT0gdGhhdCB8fCBPKHNlbGYsIHRoYXQpID4gLTEgPyBzZWxmIDogdGhhdCk7XG4vKipcbiAqIENsYW1wIGEgdmFsdWUgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgT3JkZXIsIE51bWJlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGNsYW1wID0gT3JkZXIuY2xhbXAoTnVtYmVyLk9yZGVyKSh7IG1pbmltdW06IDEsIG1heGltdW06IDUgfSlcbiAqXG4gKiBhc3NlcnQuZXF1YWwoY2xhbXAoMyksIDMpXG4gKiBhc3NlcnQuZXF1YWwoY2xhbXAoMCksIDEpXG4gKiBhc3NlcnQuZXF1YWwoY2xhbXAoNiksIDUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjbGFtcCA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWluKE8pKG9wdGlvbnMubWF4aW11bSwgbWF4KE8pKG9wdGlvbnMubWluaW11bSwgc2VsZikpKTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bSAoaW5jbHVzaXZlKS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJldHdlZW4gPSBPID0+IGR1YWwoMiwgKHNlbGYsIG9wdGlvbnMpID0+ICFsZXNzVGhhbihPKShzZWxmLCBvcHRpb25zLm1pbmltdW0pICYmICFncmVhdGVyVGhhbihPKShzZWxmLCBvcHRpb25zLm1heGltdW0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Order.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Pipeable.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Pipeable.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pipeArguments: () => (/* binding */ pipeArguments)\n/* harmony export */ });\n/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n */\nconst pipeArguments = (self, args) => {\n  switch (args.length) {\n    case 0:\n      return self;\n    case 1:\n      return args[0](self);\n    case 2:\n      return args[1](args[0](self));\n    case 3:\n      return args[2](args[1](args[0](self)));\n    case 4:\n      return args[3](args[2](args[1](args[0](self))));\n    case 5:\n      return args[4](args[3](args[2](args[1](args[0](self)))));\n    case 6:\n      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));\n    case 7:\n      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));\n    case 8:\n      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));\n    case 9:\n      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));\n    default:\n      {\n        let ret = self;\n        for (let i = 0, len = args.length; i < len; i++) {\n          ret = args[i](ret);\n        }\n        return ret;\n      }\n  }\n};\n//# sourceMappingURL=Pipeable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1BpcGVhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1BpcGVhYmxlLmpzP2M1ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHBpcGVBcmd1bWVudHMgPSAoc2VsZiwgYXJncykgPT4ge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGFyZ3NbMF0oc2VsZik7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGFyZ3NbMV0oYXJnc1swXShzZWxmKSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGFyZ3NbMl0oYXJnc1sxXShhcmdzWzBdKHNlbGYpKSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGFyZ3NbM10oYXJnc1syXShhcmdzWzFdKGFyZ3NbMF0oc2VsZikpKSk7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGFyZ3NbNF0oYXJnc1szXShhcmdzWzJdKGFyZ3NbMV0oYXJnc1swXShzZWxmKSkpKSk7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGFyZ3NbNV0oYXJnc1s0XShhcmdzWzNdKGFyZ3NbMl0oYXJnc1sxXShhcmdzWzBdKHNlbGYpKSkpKSk7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGFyZ3NbNl0oYXJnc1s1XShhcmdzWzRdKGFyZ3NbM10oYXJnc1syXShhcmdzWzFdKGFyZ3NbMF0oc2VsZikpKSkpKSk7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGFyZ3NbN10oYXJnc1s2XShhcmdzWzVdKGFyZ3NbNF0oYXJnc1szXShhcmdzWzJdKGFyZ3NbMV0oYXJnc1swXShzZWxmKSkpKSkpKSk7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIGFyZ3NbOF0oYXJnc1s3XShhcmdzWzZdKGFyZ3NbNV0oYXJnc1s0XShhcmdzWzNdKGFyZ3NbMl0oYXJnc1sxXShhcmdzWzBdKHNlbGYpKSkpKSkpKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJldCA9IHNlbGY7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcmV0ID0gYXJnc1tpXShyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaXBlYWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Pipeable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Predicate.js":
/*!***************************************************!*\
  !*** ./node_modules/effect/dist/esm/Predicate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   eqv: () => (/* binding */ eqv),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   hasProperty: () => (/* binding */ hasProperty),\n/* harmony export */   implies: () => (/* binding */ implies),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isIterable: () => (/* binding */ isIterable),\n/* harmony export */   isMap: () => (/* binding */ isMap),\n/* harmony export */   isNever: () => (/* binding */ isNever),\n/* harmony export */   isNotNull: () => (/* binding */ isNotNull),\n/* harmony export */   isNotNullable: () => (/* binding */ isNotNullable),\n/* harmony export */   isNotUndefined: () => (/* binding */ isNotUndefined),\n/* harmony export */   isNull: () => (/* binding */ isNull),\n/* harmony export */   isNullable: () => (/* binding */ isNullable),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   isReadonlyRecord: () => (/* binding */ isReadonlyRecord),\n/* harmony export */   isRecord: () => (/* binding */ isRecord),\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isSymbol: () => (/* binding */ isSymbol),\n/* harmony export */   isTagged: () => (/* binding */ isTagged),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   isTupleOf: () => (/* binding */ isTupleOf),\n/* harmony export */   isTupleOfAtLeast: () => (/* binding */ isTupleOfAtLeast),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isUnknown: () => (/* binding */ isUnknown),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   nand: () => (/* binding */ nand),\n/* harmony export */   nor: () => (/* binding */ nor),\n/* harmony export */   not: () => (/* binding */ not),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   xor: () => (/* binding */ xor)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * @since 2.0.0\n */\n\n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.\n * @param f - a function to transform `B` to `A`.\n *\n * @example\n * import { Predicate, Number } from \"effect\"\n *\n * const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst mapInput = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f) => b => self(f(b)));\n/**\n * Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n *\n * An `Array` is considered to be a `TupleOf` if its length is exactly `N`.\n *\n * @param self - The `Array` to check.\n * @param n - The exact number of elements that the `Array` should have to be considered a `TupleOf`.\n *\n * @example\n * import { isTupleOf } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number]\n * }\n *\n * @category guards\n * @since 3.3.0\n */\nconst isTupleOf = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n) => self.length === n);\n/**\n * Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n *\n * An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.\n *\n * @param self - The `Array` to check.\n * @param n - The minimum number of elements that the `Array` should have to be considered a `TupleOfAtLeast`.\n *\n * @example\n * import { isTupleOfAtLeast } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number, ...number[]]\n * }\n *\n * @category guards\n * @since 3.3.0\n */\nconst isTupleOfAtLeast = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n) => self.length >= n);\n/**\n * Tests if a value is `truthy`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isTruthy } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTruthy(1), true)\n * assert.deepStrictEqual(isTruthy(0), false)\n * assert.deepStrictEqual(isTruthy(\"\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isTruthy = input => !!input;\n/**\n * Tests if a value is a `Set`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSet(new Set([1, 2])), true)\n * assert.deepStrictEqual(isSet(new Set()), true)\n * assert.deepStrictEqual(isSet({}), false)\n * assert.deepStrictEqual(isSet(null), false)\n * assert.deepStrictEqual(isSet(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isSet = input => input instanceof Set;\n/**\n * Tests if a value is a `Map`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isMap(new Map()), true)\n * assert.deepStrictEqual(isMap({}), false)\n * assert.deepStrictEqual(isMap(null), false)\n * assert.deepStrictEqual(isMap(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isMap = input => input instanceof Map;\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isString = input => typeof input === \"string\";\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNumber = input => typeof input === \"number\";\n/**\n * Tests if a value is a `boolean`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isBoolean = input => typeof input === \"boolean\";\n/**\n * Tests if a value is a `bigint`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n *\n * assert.deepStrictEqual(isBigInt(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isBigInt = input => typeof input === \"bigint\";\n/**\n * Tests if a value is a `symbol`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isSymbol = input => typeof input === \"symbol\";\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isFunction = _Function_js__WEBPACK_IMPORTED_MODULE_0__.isFunction;\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUndefined = input => input === undefined;\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotUndefined = input => input !== undefined;\n/**\n * Tests if a value is `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNull = input => input === null;\n/**\n * Tests if a value is not `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotNull = input => input !== null;\n/**\n * A guard that always fails.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNever = _ => false;\n/**\n * A guard that always succeeds.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUnknown = _ => true;\nconst isRecordOrArray = input => typeof input === \"object\" && input !== null;\n/**\n * Tests if a value is an `object`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isObject = input => isRecordOrArray(input) || isFunction(input);\n/**\n * Checks whether a value is an `object` containing a specified property key.\n *\n * @param property - The field to check within the object.\n * @param self - The value to examine.\n *\n * @category guards\n * @since 2.0.0\n */\nconst hasProperty = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, property) => isObject(self) && property in self);\n/**\n * Tests if a value is an `object` with a property `_tag` that matches the given tag.\n *\n * @param input - The value to test.\n * @param tag - The tag to test for.\n *\n * @example\n * import { isTagged } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTagged(1, \"a\"), false)\n * assert.deepStrictEqual(isTagged(null, \"a\"), false)\n * assert.deepStrictEqual(isTagged({}, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\n * assert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isTagged = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, tag) => hasProperty(self, \"_tag\") && self[\"_tag\"] === tag);\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNullable = input => input === null || input === undefined;\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isNotNullable = input => input !== null && input !== undefined;\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isError } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isError = input => input instanceof Error;\n/**\n * A guard that succeeds when the input is a `Uint8Array`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.deepStrictEqual(isUint8Array(null), false)\n * assert.deepStrictEqual(isUint8Array({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isUint8Array = input => input instanceof Uint8Array;\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isDate = input => input instanceof Date;\n/**\n * A guard that succeeds when the input is an `Iterable`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isIterable([]), true)\n * assert.deepStrictEqual(isIterable(new Set()), true)\n *\n * assert.deepStrictEqual(isIterable(null), false)\n * assert.deepStrictEqual(isIterable({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isIterable = input => hasProperty(input, Symbol.iterator);\n/**\n * A guard that succeeds when the input is a record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n * assert.deepStrictEqual(isRecord(() => null), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isRecord = input => isRecordOrArray(input) && !Array.isArray(input);\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isReadonlyRecord = isRecord;\n/**\n * A guard that succeeds when the input is a Promise.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isPromise({}), false)\n * assert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n *\n * @category guards\n * @since 2.0.0\n */\nconst isPromise = input => hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch);\n/**\n * @category guards\n * @since 2.0.0\n */\nconst isPromiseLike = input => hasProperty(input, \"then\") && isFunction(input.then);\n/**\n * @since 2.0.0\n */\nconst compose = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (ab, bc) => a => ab(a) && bc(a));\n/**\n * @category combining\n * @since 2.0.0\n */\nconst product = (self, that) => ([a, b]) => self(a) && that(b);\n/**\n * @category combining\n * @since 2.0.0\n */\nconst all = collection => {\n  return as => {\n    let collectionIndex = 0;\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break;\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false;\n      }\n      collectionIndex++;\n    }\n    return true;\n  };\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nconst productMany = (self, collection) => {\n  const rest = all(collection);\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail);\n};\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```\n * [Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * [Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n * ```\n *\n * @since 2.0.0\n */\nconst tuple = (...elements) => all(elements);\n/**\n * ```\n * { ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n * { a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n * { ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: С; ... }>\n * ```\n *\n * @since 2.0.0\n */\nconst struct = fields => {\n  const keys = Object.keys(fields);\n  return a => {\n    for (const key of keys) {\n      if (!fields[key](a[key])) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n/**\n * Negates the result of a given predicate.\n *\n * @param self - A predicate.\n *\n * @example\n * import { Predicate, Number } from \"effect\"\n *\n * const isPositive = Predicate.not(Number.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst not = self => a => !self(a);\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import { Predicate, Number } from \"effect\"\n *\n * const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst or = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => self(a) || that(a));\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import { Predicate } from \"effect\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst and = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => self(a) && that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst xor = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => self(a) !== that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst eqv = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => self(a) === that(a));\n/**\n * Represents the logical implication combinator for predicates. In formal\n * logic, the implication operator `->` denotes that if the first proposition\n * (antecedent) is true, then the second proposition (consequent) must also be\n * true. In simpler terms, `p implies q` can be interpreted as \"if p then q\". If\n * the first predicate holds, then the second predicate must hold\n * for the given context.\n *\n * In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.\n *\n * Note that if the antecedent is `false`, the result is `true` by default\n * because the outcome of the consequent cannot be determined.\n *\n * This function is useful in situations where you need to enforce rules or\n * constraints that are contingent on certain conditions.\n * It proves especially helpful in defining property tests.\n *\n * The example below illustrates the transitive property of order using the\n * `implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`\n * must be true.\n *\n * @example\n * import { Predicate } from \"effect\"\n *\n * type Triple = {\n *   readonly a: number\n *   readonly b: number\n *   readonly c: number\n * }\n *\n * const transitivity = Predicate.implies(\n *   // antecedent\n *   (input: Triple) => input.a <= input.b && input.b <= input.c,\n *   // consequent\n *   (input: Triple) => input.a <= input.c\n * )\n *\n * assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n * // antecedent is `false`, so the result is `true`\n * assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nconst implies = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (antecedent, consequent) => a => antecedent(a) ? consequent(a) : true);\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst nor = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => !(self(a) || that(a)));\n/**\n * @category combinators\n * @since 2.0.0\n */\nconst nand = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that) => a => !(self(a) && that(a)));\n/**\n * @category elements\n * @since 2.0.0\n */\nconst every = collection => a => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @category elements\n * @since 2.0.0\n */\nconst some = collection => a => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true;\n    }\n  }\n  return false;\n};\n//# sourceMappingURL=Predicate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1ByZWRpY2F0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLGtEQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGtEQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0Msa0RBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7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LFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsa0RBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsa0RBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsa0RBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vUHJlZGljYXRlLmpzP2Y4NDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0IHsgZHVhbCwgaXNGdW5jdGlvbiBhcyBpc0Z1bmN0aW9uXyB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG4vKipcbiAqIEdpdmVuIGEgYFByZWRpY2F0ZTxBPmAgcmV0dXJucyBhIGBQcmVkaWNhdGU8Qj5gXG4gKlxuICogQHBhcmFtIHNlbGYgLSB0aGUgYFByZWRpY2F0ZTxBPmAgdG8gYmUgdHJhbnNmb3JtZWQgdG8gYFByZWRpY2F0ZTxCPmAuXG4gKiBAcGFyYW0gZiAtIGEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGBCYCB0byBgQWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbWluTGVuZ3RoMyA9IFByZWRpY2F0ZS5tYXBJbnB1dChOdW1iZXIuZ3JlYXRlclRoYW4oMiksIChzOiBzdHJpbmcpID0+IHMubGVuZ3RoKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWluTGVuZ3RoMyhcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFhXCIpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFhYVwiKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFwSW5wdXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gYiA9PiBzZWxmKGYoYikpKTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBBcnJheWAgaXMgYSB0dXBsZSB3aXRoIGV4YWN0bHkgYE5gIGVsZW1lbnRzLCBuYXJyb3dpbmcgZG93biB0aGUgdHlwZSB0byBgVHVwbGVPZmAuXG4gKlxuICogQW4gYEFycmF5YCBpcyBjb25zaWRlcmVkIHRvIGJlIGEgYFR1cGxlT2ZgIGlmIGl0cyBsZW5ndGggaXMgZXhhY3RseSBgTmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEFycmF5YCB0byBjaGVjay5cbiAqIEBwYXJhbSBuIC0gVGhlIGV4YWN0IG51bWJlciBvZiBlbGVtZW50cyB0aGF0IHRoZSBgQXJyYXlgIHNob3VsZCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgYSBgVHVwbGVPZmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzVHVwbGVPZiB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVHVwbGVPZihbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgMiksIGZhbHNlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgNCksIGZhbHNlKTtcbiAqXG4gKiBjb25zdCBhcnI6IG51bWJlcltdID0gWzEsIDIsIDNdO1xuICogaWYgKGlzVHVwbGVPZihhcnIsIDMpKSB7XG4gKiAgIGNvbnNvbGUubG9nKGFycik7XG4gKiAgIC8vIF4/IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICogfVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAzLjMuMFxuICovXG5leHBvcnQgY29uc3QgaXNUdXBsZU9mID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+IHNlbGYubGVuZ3RoID09PSBuKTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBBcnJheWAgaXMgYSB0dXBsZSB3aXRoIGF0IGxlYXN0IGBOYCBlbGVtZW50cywgbmFycm93aW5nIGRvd24gdGhlIHR5cGUgdG8gYFR1cGxlT2ZBdExlYXN0YC5cbiAqXG4gKiBBbiBgQXJyYXlgIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBgVHVwbGVPZkF0TGVhc3RgIGlmIGl0cyBsZW5ndGggaXMgYXQgbGVhc3QgYE5gLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBBcnJheWAgdG8gY2hlY2suXG4gKiBAcGFyYW0gbiAtIFRoZSBtaW5pbXVtIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IHRoZSBgQXJyYXlgIHNob3VsZCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgYSBgVHVwbGVPZkF0TGVhc3RgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc1R1cGxlT2ZBdExlYXN0IH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDIpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDQpLCBmYWxzZSk7XG4gKlxuICogY29uc3QgYXJyOiBudW1iZXJbXSA9IFsxLCAyLCAzLCA0XTtcbiAqIGlmIChpc1R1cGxlT2ZBdExlYXN0KGFyciwgMykpIHtcbiAqICAgY29uc29sZS5sb2coYXJyKTtcbiAqICAgLy8gXj8gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIC4uLm51bWJlcltdXVxuICogfVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAzLjMuMFxuICovXG5leHBvcnQgY29uc3QgaXNUdXBsZU9mQXRMZWFzdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBuKSA9PiBzZWxmLmxlbmd0aCA+PSBuKTtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBgdHJ1dGh5YC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNUcnV0aHkgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RydXRoeSgxKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUcnV0aHkoMCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RydXRoeShcIlwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1RydXRoeSA9IGlucHV0ID0+ICEhaW5wdXQ7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgU2V0YC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNTZXQgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChuZXcgU2V0KFsxLCAyXSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChuZXcgU2V0KCkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldCh7fSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzU2V0KHVuZGVmaW5lZCksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNTZXQgPSBpbnB1dCA9PiBpbnB1dCBpbnN0YW5jZW9mIFNldDtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBNYXBgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc01hcCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKG5ldyBNYXAoKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKHt9KSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNNYXAodW5kZWZpbmVkKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc01hcCA9IGlucHV0ID0+IGlucHV0IGluc3RhbmNlb2YgTWFwO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNTdHJpbmcoXCJhXCIpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNTdHJpbmcoMSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCI7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgbnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc051bWJlcigyKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVtYmVyKFwiMlwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc051bWJlciA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIjtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBib29sZWFuYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNCb29sZWFuIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCb29sZWFuKHRydWUpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCb29sZWFuKFwidHJ1ZVwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jvb2xlYW4gPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYGJpZ2ludGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzQmlnSW50IH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCaWdJbnQoMW4pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCaWdJbnQoMSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNCaWdJbnQgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwiYmlnaW50XCI7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgc3ltYm9sYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNTeW1ib2wgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1N5bWJvbChTeW1ib2wuZm9yKFwiYVwiKSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1N5bWJvbChcImFcIiksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNTeW1ib2wgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwic3ltYm9sXCI7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgZnVuY3Rpb25gLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNGdW5jdGlvbihpc0Z1bmN0aW9uKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRnVuY3Rpb24oXCJmdW5jdGlvblwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gaXNGdW5jdGlvbl87XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmRlZmluZWQodW5kZWZpbmVkKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5kZWZpbmVkKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmRlZmluZWQoXCJ1bmRlZmluZWRcIiksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNVbmRlZmluZWQgPSBpbnB1dCA9PiBpbnB1dCA9PT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNOb3RVbmRlZmluZWQgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdFVuZGVmaW5lZChudWxsKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3RVbmRlZmluZWQoXCJ1bmRlZmluZWRcIiksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdFVuZGVmaW5lZCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm90VW5kZWZpbmVkID0gaW5wdXQgPT4gaW5wdXQgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBgbnVsbGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzTnVsbCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbChudWxsKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsKFwibnVsbFwiKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc051bGwgPSBpbnB1dCA9PiBpbnB1dCA9PT0gbnVsbDtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBub3QgYG51bGxgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc05vdE51bGwgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdE51bGwodW5kZWZpbmVkKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsKFwibnVsbFwiKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTm90TnVsbChudWxsKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc05vdE51bGwgPSBpbnB1dCA9PiBpbnB1dCAhPT0gbnVsbDtcbi8qKlxuICogQSBndWFyZCB0aGF0IGFsd2F5cyBmYWlscy5cbiAqXG4gKiBAcGFyYW0gXyAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc05ldmVyIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOZXZlcihudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTmV2ZXIodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTmV2ZXIoe30pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOZXZlcihbXSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNOZXZlciA9IF8gPT4gZmFsc2U7XG4vKipcbiAqIEEgZ3VhcmQgdGhhdCBhbHdheXMgc3VjY2VlZHMuXG4gKlxuICogQHBhcmFtIF8gLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNVbmtub3duIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmtub3duKG51bGwpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1Vua25vd24odW5kZWZpbmVkKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5rbm93bih7fSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5rbm93bihbXSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Vua25vd24gPSBfID0+IHRydWU7XG5jb25zdCBpc1JlY29yZE9yQXJyYXkgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgaW5wdXQgIT09IG51bGw7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gYG9iamVjdGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNPYmplY3Qoe30pLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc09iamVjdChbXSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc09iamVjdChudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzT2JqZWN0KHVuZGVmaW5lZCksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSBpbnB1dCA9PiBpc1JlY29yZE9yQXJyYXkoaW5wdXQpIHx8IGlzRnVuY3Rpb24oaW5wdXQpO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIGFuIGBvYmplY3RgIGNvbnRhaW5pbmcgYSBzcGVjaWZpZWQgcHJvcGVydHkga2V5LlxuICpcbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBmaWVsZCB0byBjaGVjayB3aXRoaW4gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHZhbHVlIHRvIGV4YW1pbmUuXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcm9wZXJ0eSkgPT4gaXNPYmplY3Qoc2VsZikgJiYgcHJvcGVydHkgaW4gc2VsZik7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gYG9iamVjdGAgd2l0aCBhIHByb3BlcnR5IGBfdGFnYCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIHRhZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBwYXJhbSB0YWcgLSBUaGUgdGFnIHRvIHRlc3QgZm9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc1RhZ2dlZCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVGFnZ2VkKDEsIFwiYVwiKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVGFnZ2VkKG51bGwsIFwiYVwiKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVGFnZ2VkKHt9LCBcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZCh7IGE6IFwiYVwiIH0sIFwiYVwiKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVGFnZ2VkKHsgX3RhZzogXCJhXCIgfSwgXCJhXCIpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZChcImFcIikoeyBfdGFnOiBcImFcIiB9KSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGFnZ2VkID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRhZykgPT4gaGFzUHJvcGVydHkoc2VsZiwgXCJfdGFnXCIpICYmIHNlbGZbXCJfdGFnXCJdID09PSB0YWcpO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc051bGxhYmxlIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsYWJsZShudWxsKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsYWJsZSh1bmRlZmluZWQpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsYWJsZSh7fSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc051bGxhYmxlKFtdKSwgZmFsc2UpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc051bGxhYmxlID0gaW5wdXQgPT4gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZDtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzTm90TnVsbGFibGUgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdE51bGxhYmxlKHt9KSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsYWJsZShbXSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdE51bGxhYmxlKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsYWJsZSh1bmRlZmluZWQpLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm90TnVsbGFibGUgPSBpbnB1dCA9PiBpbnB1dCAhPT0gbnVsbCAmJiBpbnB1dCAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYW4gYEVycm9yYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRXJyb3IobmV3IEVycm9yKCkpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcnJvcihudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRXJyb3Ioe30pLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXJyb3IgPSBpbnB1dCA9PiBpbnB1dCBpbnN0YW5jZW9mIEVycm9yO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzVWludDhBcnJheSB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVWludDhBcnJheShuZXcgVWludDhBcnJheSgpKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVWludDhBcnJheShudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVWludDhBcnJheSh7fSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNVaW50OEFycmF5ID0gaW5wdXQgPT4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSBgRGF0ZWAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzRGF0ZSB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRGF0ZShuZXcgRGF0ZSgpKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRGF0ZShudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRGF0ZSh7fSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNEYXRlID0gaW5wdXQgPT4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYW4gYEl0ZXJhYmxlYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNJdGVyYWJsZSB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzSXRlcmFibGUoW10pLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0l0ZXJhYmxlKG5ldyBTZXQoKSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0l0ZXJhYmxlKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNJdGVyYWJsZSh7fSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNJdGVyYWJsZSA9IGlucHV0ID0+IGhhc1Byb3BlcnR5KGlucHV0LCBTeW1ib2wuaXRlcmF0b3IpO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSByZWNvcmQuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGlzUmVjb3JkIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQoe30pLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlY29yZCh7IGE6IDEgfSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlY29yZChbXSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlY29yZChbMSwgMiwgM10pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQobnVsbCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlY29yZCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQoKCkgPT4gbnVsbCksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNSZWNvcmQgPSBpbnB1dCA9PiBpc1JlY29yZE9yQXJyYXkoaW5wdXQpICYmICFBcnJheS5pc0FycmF5KGlucHV0KTtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIGEgcmVhZG9ubHkgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpc1JlYWRvbmx5UmVjb3JkIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWFkb25seVJlY29yZCh7fSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVhZG9ubHlSZWNvcmQoeyBhOiAxIH0pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWFkb25seVJlY29yZChbXSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlYWRvbmx5UmVjb3JkKFsxLCAyLCAzXSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlYWRvbmx5UmVjb3JkKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWFkb25seVJlY29yZCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUmVhZG9ubHlSZWNvcmQgPSBpc1JlY29yZDtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIGEgUHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQcm9taXNlKHt9KSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUHJvbWlzZShQcm9taXNlLnJlc29sdmUoXCJoZWxsb1wiKSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgXCJ0aGVuXCIpICYmIFwiY2F0Y2hcIiBpbiBpbnB1dCAmJiBpc0Z1bmN0aW9uKGlucHV0LnRoZW4pICYmIGlzRnVuY3Rpb24oaW5wdXQuY2F0Y2gpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZUxpa2UgPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgXCJ0aGVuXCIpICYmIGlzRnVuY3Rpb24oaW5wdXQudGhlbik7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tcG9zZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChhYiwgYmMpID0+IGEgPT4gYWIoYSkgJiYgYmMoYSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3QgPSAoc2VsZiwgdGhhdCkgPT4gKFthLCBiXSkgPT4gc2VsZihhKSAmJiB0aGF0KGIpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IGNvbGxlY3Rpb24gPT4ge1xuICByZXR1cm4gYXMgPT4ge1xuICAgIGxldCBjb2xsZWN0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgcCBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbkluZGV4ID49IGFzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChwKGFzW2NvbGxlY3Rpb25JbmRleF0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb2xsZWN0aW9uSW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3RNYW55ID0gKHNlbGYsIGNvbGxlY3Rpb24pID0+IHtcbiAgY29uc3QgcmVzdCA9IGFsbChjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIChbaGVhZCwgLi4udGFpbF0pID0+IHNlbGYoaGVhZCkgPT09IGZhbHNlID8gZmFsc2UgOiByZXN0KHRhaWwpO1xufTtcbi8qKlxuICogU2ltaWxhciB0byBgUHJvbWlzZS5hbGxgIGJ1dCBvcGVyYXRlcyBvbiBgUHJlZGljYXRlYHMuXG4gKlxuICogYGBgXG4gKiBbUmVmaW5lbWVudDxBLCBCPiwgUmVmaW5lbWVudDxDLCBEPiwgLi4uXSAtPiBSZWZpbmVtZW50PFtBLCBDLCAuLi5dLCBbQiwgRCwgLi4uXT5cbiAqIFtQcmVkaWNhdGU8QT4sIFByZWRpY2F0ZTxCPiwgLi4uXSAtPiBQcmVkaWNhdGU8W0EsIEIsIC4uLl0+XG4gKiBbUmVmaW5lbWVudDxBLCBCPiwgUHJlZGljYXRlPEM+LCAuLi5dIC0+IFJlZmluZW1lbnQ8W0EsIEMsIC4uLl0sIFtCLCBDLCAuLi5dPlxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZSA9ICguLi5lbGVtZW50cykgPT4gYWxsKGVsZW1lbnRzKTtcbi8qKlxuICogYGBgXG4gKiB7IGFiOiBSZWZpbmVtZW50PEEsIEI+OyBjZDogUmVmaW5lbWVudDxDLCBEPiwgLi4uIH0gLT4gUmVmaW5lbWVudDx7IGFiOiBBOyBjZDogQzsgLi4uIH0sIHsgYWI6IEI7IGNkOiBEOyAuLi4gfT5cbiAqIHsgYTogUHJlZGljYXRlPEEsIEI+OyBiOiBQcmVkaWNhdGU8Qj4sIC4uLiB9IC0+IFByZWRpY2F0ZTx7IGE6IEE7IGI6IEI7IC4uLiB9PlxuICogeyBhYjogUmVmaW5lbWVudDxBLCBCPjsgYzogUHJlZGljYXRlPEM+LCAuLi4gfSAtPiBSZWZpbmVtZW50PHsgYWI6IEE7IGM6IEM7IC4uLiB9LCB7IGFiOiBCOyBjOiDQoTsgLi4uIH0+XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cnVjdCA9IGZpZWxkcyA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuICByZXR1cm4gYSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKCFmaWVsZHNba2V5XShhW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59O1xuLyoqXG4gKiBOZWdhdGVzIHRoZSByZXN1bHQgb2YgYSBnaXZlbiBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBIHByZWRpY2F0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgUHJlZGljYXRlLCBOdW1iZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBpc1Bvc2l0aXZlID0gUHJlZGljYXRlLm5vdChOdW1iZXIubGVzc1RoYW4oMCkpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1Bvc2l0aXZlKC0xKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUG9zaXRpdmUoMCksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUG9zaXRpdmUoMSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdCA9IHNlbGYgPT4gYSA9PiAhc2VsZihhKTtcbi8qKlxuICogQ29tYmluZXMgdHdvIHByZWRpY2F0ZXMgaW50byBhIG5ldyBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHByZWRpY2F0ZXMgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSB0aGF0IC0gQSBwcmVkaWNhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3Qgbm9uWmVybyA9IFByZWRpY2F0ZS5vcihOdW1iZXIubGVzc1RoYW4oMCksIE51bWJlci5ncmVhdGVyVGhhbigwKSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG5vblplcm8oLTEpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChub25aZXJvKDApLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobm9uWmVybygxKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgb3IgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gYSA9PiBzZWxmKGEpIHx8IHRoYXQoYSkpO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gcHJlZGljYXRlcyBpbnRvIGEgbmV3IHByZWRpY2F0ZSB0aGF0IHJldHVybnMgYHRydWVgIGlmIGJvdGggb2YgdGhlIHByZWRpY2F0ZXMgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSB0aGF0IC0gQSBwcmVkaWNhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG1pbkxlbmd0aCA9IChuOiBudW1iZXIpID0+IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoID49IG5cbiAqIGNvbnN0IG1heExlbmd0aCA9IChuOiBudW1iZXIpID0+IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoIDw9IG5cbiAqXG4gKiBjb25zdCBsZW5ndGggPSAobjogbnVtYmVyKSA9PiBQcmVkaWNhdGUuYW5kKG1pbkxlbmd0aChuKSwgbWF4TGVuZ3RoKG4pKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobGVuZ3RoKDIpKFwiYWFcIiksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGxlbmd0aCgyKShcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChsZW5ndGgoMikoXCJhYWFcIiksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhbmQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gYSA9PiBzZWxmKGEpICYmIHRoYXQoYSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgeG9yID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gc2VsZihhKSAhPT0gdGhhdChhKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlcXYgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gYSA9PiBzZWxmKGEpID09PSB0aGF0KGEpKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9naWNhbCBpbXBsaWNhdGlvbiBjb21iaW5hdG9yIGZvciBwcmVkaWNhdGVzLiBJbiBmb3JtYWxcbiAqIGxvZ2ljLCB0aGUgaW1wbGljYXRpb24gb3BlcmF0b3IgYC0+YCBkZW5vdGVzIHRoYXQgaWYgdGhlIGZpcnN0IHByb3Bvc2l0aW9uXG4gKiAoYW50ZWNlZGVudCkgaXMgdHJ1ZSwgdGhlbiB0aGUgc2Vjb25kIHByb3Bvc2l0aW9uIChjb25zZXF1ZW50KSBtdXN0IGFsc28gYmVcbiAqIHRydWUuIEluIHNpbXBsZXIgdGVybXMsIGBwIGltcGxpZXMgcWAgY2FuIGJlIGludGVycHJldGVkIGFzIFwiaWYgcCB0aGVuIHFcIi4gSWZcbiAqIHRoZSBmaXJzdCBwcmVkaWNhdGUgaG9sZHMsIHRoZW4gdGhlIHNlY29uZCBwcmVkaWNhdGUgbXVzdCBob2xkXG4gKiBmb3IgdGhlIGdpdmVuIGNvbnRleHQuXG4gKlxuICogSW4gcHJhY3RpY2FsIHRlcm1zIHdpdGhpbiBUeXBlU2NyaXB0LCBgcCBpbXBsaWVzIHFgIGlzIGVxdWl2YWxlbnQgdG8gYCFwIHx8IChwICYmIHEpYC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgdGhlIGFudGVjZWRlbnQgaXMgYGZhbHNlYCwgdGhlIHJlc3VsdCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdFxuICogYmVjYXVzZSB0aGUgb3V0Y29tZSBvZiB0aGUgY29uc2VxdWVudCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIHRvIGVuZm9yY2UgcnVsZXMgb3JcbiAqIGNvbnN0cmFpbnRzIHRoYXQgYXJlIGNvbnRpbmdlbnQgb24gY2VydGFpbiBjb25kaXRpb25zLlxuICogSXQgcHJvdmVzIGVzcGVjaWFsbHkgaGVscGZ1bCBpbiBkZWZpbmluZyBwcm9wZXJ0eSB0ZXN0cy5cbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBpbGx1c3RyYXRlcyB0aGUgdHJhbnNpdGl2ZSBwcm9wZXJ0eSBvZiBvcmRlciB1c2luZyB0aGVcbiAqIGBpbXBsaWVzYCBmdW5jdGlvbi4gSW4gc2ltcGxlIHRlcm1zLCBpZiBgYSA8PSBiYCBhbmQgYGIgPD0gY2AsIHRoZW4gYGEgPD0gY2BcbiAqIG11c3QgYmUgdHJ1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogdHlwZSBUcmlwbGUgPSB7XG4gKiAgIHJlYWRvbmx5IGE6IG51bWJlclxuICogICByZWFkb25seSBiOiBudW1iZXJcbiAqICAgcmVhZG9ubHkgYzogbnVtYmVyXG4gKiB9XG4gKlxuICogY29uc3QgdHJhbnNpdGl2aXR5ID0gUHJlZGljYXRlLmltcGxpZXMoXG4gKiAgIC8vIGFudGVjZWRlbnRcbiAqICAgKGlucHV0OiBUcmlwbGUpID0+IGlucHV0LmEgPD0gaW5wdXQuYiAmJiBpbnB1dC5iIDw9IGlucHV0LmMsXG4gKiAgIC8vIGNvbnNlcXVlbnRcbiAqICAgKGlucHV0OiBUcmlwbGUpID0+IGlucHV0LmEgPD0gaW5wdXQuY1xuICogKVxuICpcbiAqIGFzc2VydC5lcXVhbCh0cmFuc2l0aXZpdHkoeyBhOiAxLCBiOiAyLCBjOiAzIH0pLCB0cnVlKVxuICogLy8gYW50ZWNlZGVudCBpcyBgZmFsc2VgLCBzbyB0aGUgcmVzdWx0IGlzIGB0cnVlYFxuICogYXNzZXJ0LmVxdWFsKHRyYW5zaXRpdml0eSh7IGE6IDEsIGI6IDAsIGM6IDAgfSksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGltcGxpZXMgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoYW50ZWNlZGVudCwgY29uc2VxdWVudCkgPT4gYSA9PiBhbnRlY2VkZW50KGEpID8gY29uc2VxdWVudChhKSA6IHRydWUpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgbm9yID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gIShzZWxmKGEpIHx8IHRoYXQoYSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG5hbmQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gYSA9PiAhKHNlbGYoYSkgJiYgdGhhdChhKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSBjb2xsZWN0aW9uID0+IGEgPT4ge1xuICBmb3IgKGNvbnN0IHAgb2YgY29sbGVjdGlvbikge1xuICAgIGlmICghcChhKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gY29sbGVjdGlvbiA9PiBhID0+IHtcbiAgZm9yIChjb25zdCBwIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocChhKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVkaWNhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Predicate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Utils.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenKindImpl: () => (/* binding */ GenKindImpl),\n/* harmony export */   GenKindTypeId: () => (/* binding */ GenKindTypeId),\n/* harmony export */   PCGRandom: () => (/* binding */ PCGRandom),\n/* harmony export */   SingleShotGen: () => (/* binding */ SingleShotGen),\n/* harmony export */   YieldWrap: () => (/* binding */ YieldWrap),\n/* harmony export */   YieldWrapTypeId: () => (/* binding */ YieldWrapTypeId),\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   internalCall: () => (/* binding */ internalCall),\n/* harmony export */   isGenKind: () => (/* binding */ isGenKind),\n/* harmony export */   makeGenKind: () => (/* binding */ makeGenKind),\n/* harmony export */   structuralRegion: () => (/* binding */ structuralRegion),\n/* harmony export */   structuralRegionState: () => (/* binding */ structuralRegionState),\n/* harmony export */   yieldWrapGet: () => (/* binding */ yieldWrapGet)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/errors.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/**\n * @since 2.0.0\n */\n\n\n\n\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */\n/**\n * @category symbols\n * @since 2.0.0\n */\nconst GenKindTypeId = /*#__PURE__*/Symbol.for(\"effect/Gen/GenKind\");\n/**\n * @category predicates\n * @since 3.0.6\n */\nconst isGenKind = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(u) && GenKindTypeId in u;\n/**\n * @category constructors\n * @since 2.0.0\n */\nclass GenKindImpl {\n  value;\n  constructor(\n  /**\n   * @since 2.0.0\n   */\n  value) {\n    this.value = value;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [GenKindTypeId] = GenKindTypeId;\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nclass SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  /**\n   * @since 2.0.0\n   */\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  /**\n   * @since 2.0.0\n   */\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  /**\n   * @since 2.0.0\n   */\n  throw(e) {\n    throw e;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nconst makeGenKind = kind => new GenKindImpl(kind);\n/**\n * @category adapters\n * @since 2.0.0\n */\nconst adapter = () => function () {\n  let x = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x);\n  }\n  return new GenKindImpl(x);\n};\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nclass PCGRandom {\n  _state;\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedLo) && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incLo) && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max) {\n    if (!max) {\n      return this._next();\n    }\n    max = max >>> 0;\n    if ((max & max - 1) === 0) {\n      return this._next() & max - 1; // fast path for power of 2\n    }\n    let num = 0;\n    const skew = (-max >>> 0) % max >>> 0;\n    for (num = this._next(); num < skew; num = this._next()) {\n      // this loop will rarely execute more than twice,\n      // and is intentionally empty\n    }\n    return num % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n/**\n * @since 3.0.6\n */\nconst YieldWrapTypeId = /*#__PURE__*/Symbol.for(\"effect/Utils/YieldWrap\");\n/**\n * @since 3.0.6\n */\nclass YieldWrap {\n  /**\n   * @since 3.0.6\n   */\n  #value;\n  constructor(value) {\n    this.#value = value;\n  }\n  /**\n   * @since 3.0.6\n   */\n  [YieldWrapTypeId]() {\n    return this.#value;\n  }\n}\n/**\n * @since 3.0.6\n */\nfunction yieldWrapGet(self) {\n  if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n    return self[YieldWrapTypeId]();\n  }\n  throw new Error((0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_2__.getBugErrorMessage)(\"yieldWrapGet\"));\n}\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nconst structuralRegionState = /*#__PURE__*/(0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_3__.globalValue)(\"effect/Utils/isStructuralRegion\", () => ({\n  enabled: false,\n  tester: undefined\n}));\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nconst structuralRegion = (body, tester) => {\n  const current = structuralRegionState.enabled;\n  const currentTester = structuralRegionState.tester;\n  structuralRegionState.enabled = true;\n  if (tester) {\n    structuralRegionState.tester = tester;\n  }\n  try {\n    return body();\n  } finally {\n    structuralRegionState.enabled = current;\n    structuralRegionState.tester = currentTester;\n  }\n};\nconst tracingFunction = name => {\n  const wrap = {\n    [name](body) {\n      return body();\n    }\n  };\n  return function (fn) {\n    return wrap[name](fn);\n  };\n};\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */\nconst internalCall = /*#__PURE__*/tracingFunction(\"effect_internal_function\");\n//# sourceMappingURL=Utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3lDO0FBQ007QUFDVztBQUNKO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1Qix1REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEseURBQVUsWUFBWSx5REFBVTtBQUN4QztBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQVUsV0FBVyx5REFBVTtBQUN2QztBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQyw0REFBVztBQUM3RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9VdGlscy5qcz8zNGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSBcIi4vRnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IGdsb2JhbFZhbHVlIH0gZnJvbSBcIi4vR2xvYmFsVmFsdWUuanNcIjtcbmltcG9ydCB7IGdldEJ1Z0Vycm9yTWVzc2FnZSB9IGZyb20gXCIuL2ludGVybmFsL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgaXNOdWxsYWJsZSwgaXNPYmplY3QgfSBmcm9tIFwiLi9QcmVkaWNhdGUuanNcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBUaG9tIENoaW92b2xvbmksIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKiBBIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGJhc2VkIG9uIHRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUENHIGFsZ29yaXRobSxcbiAqIGFzIGRlc2NyaWJlZCBoZXJlOiBodHRwOi8vd3d3LnBjZy1yYW5kb20ub3JnL1xuICpcbiAqIEFkYXB0ZWQgZm9yIFR5cGVTY3JpcHQgZnJvbSBUaG9tJ3Mgb3JpZ2luYWwgY29kZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdGhvbWNjL3BjZy1yYW5kb21cbiAqXG4gKiBmb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZnJwdG9vbHNcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuLyoqXG4gKiBAY2F0ZWdvcnkgc3ltYm9sc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBHZW5LaW5kVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvR2VuL0dlbktpbmRcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBwcmVkaWNhdGVzXG4gKiBAc2luY2UgMy4wLjZcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR2VuS2luZCA9IHUgPT4gaXNPYmplY3QodSkgJiYgR2VuS2luZFR5cGVJZCBpbiB1O1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNsYXNzIEdlbktpbmRJbXBsIHtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKFxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICB2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBnZXQgX0YoKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfUigpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfTygpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfRSgpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtHZW5LaW5kVHlwZUlkXSA9IEdlbktpbmRUeXBlSWQ7XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgU2luZ2xlU2hvdEdlbih0aGlzKTtcbiAgfVxufVxuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbmdsZVNob3RHZW4ge1xuICBzZWxmO1xuICBjYWxsZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgbmV4dChhKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGVkID8ge1xuICAgICAgdmFsdWU6IGEsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfSA6ICh0aGlzLmNhbGxlZCA9IHRydWUsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnNlbGYsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHJldHVybihhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgdGhyb3coZSkge1xuICAgIHRocm93IGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5nbGVTaG90R2VuKHRoaXMuc2VsZik7XG4gIH1cbn1cbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlR2VuS2luZCA9IGtpbmQgPT4gbmV3IEdlbktpbmRJbXBsKGtpbmQpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWRhcHRlciA9ICgpID0+IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHggPSBhcmd1bWVudHNbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXSh4KTtcbiAgfVxuICByZXR1cm4gbmV3IEdlbktpbmRJbXBsKHgpO1xufTtcbmNvbnN0IGRlZmF1bHRJbmNIaSA9IDB4MTQwNTdiN2U7XG5jb25zdCBkZWZhdWx0SW5jTG8gPSAweGY3Njc4MTRmO1xuY29uc3QgTVVMX0hJID0gMHg1ODUxZjQyZCA+Pj4gMDtcbmNvbnN0IE1VTF9MTyA9IDB4NGM5NTdmMmQgPj4+IDA7XG5jb25zdCBCSVRfNTMgPSA5MDA3MTk5MjU0NzQwOTkyLjA7XG5jb25zdCBCSVRfMjcgPSAxMzQyMTc3MjguMDtcbi8qKlxuICogUENHIGlzIGEgZmFtaWx5IG9mIHNpbXBsZSBmYXN0IHNwYWNlLWVmZmljaWVudCBzdGF0aXN0aWNhbGx5IGdvb2QgYWxnb3JpdGhtc1xuICogZm9yIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbi4gVW5saWtlIG1hbnkgZ2VuZXJhbC1wdXJwb3NlIFJOR3MsIHRoZXkgYXJlIGFsc29cbiAqIGhhcmQgdG8gcHJlZGljdC5cbiAqXG4gKiBAY2F0ZWdvcnkgbW9kZWxcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY2xhc3MgUENHUmFuZG9tIHtcbiAgX3N0YXRlO1xuICBjb25zdHJ1Y3RvcihzZWVkSGksIHNlZWRMbywgaW5jSGksIGluY0xvKSB7XG4gICAgaWYgKGlzTnVsbGFibGUoc2VlZExvKSAmJiBpc051bGxhYmxlKHNlZWRIaSkpIHtcbiAgICAgIHNlZWRMbyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmID4+PiAwO1xuICAgICAgc2VlZEhpID0gMDtcbiAgICB9IGVsc2UgaWYgKGlzTnVsbGFibGUoc2VlZExvKSkge1xuICAgICAgc2VlZExvID0gc2VlZEhpO1xuICAgICAgc2VlZEhpID0gMDtcbiAgICB9XG4gICAgaWYgKGlzTnVsbGFibGUoaW5jTG8pICYmIGlzTnVsbGFibGUoaW5jSGkpKSB7XG4gICAgICBpbmNMbyA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbM10gOiBkZWZhdWx0SW5jTG87XG4gICAgICBpbmNIaSA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbMl0gOiBkZWZhdWx0SW5jSGk7XG4gICAgfSBlbHNlIGlmIChpc051bGxhYmxlKGluY0xvKSkge1xuICAgICAgaW5jTG8gPSBpbmNIaTtcbiAgICAgIGluY0hpID0gMDtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgSW50MzJBcnJheShbMCwgMCwgaW5jSGkgPj4+IDAsICgoaW5jTG8gfHwgMCkgfCAxKSA+Pj4gMF0pO1xuICAgIHRoaXMuX25leHQoKTtcbiAgICBhZGQ2NCh0aGlzLl9zdGF0ZSwgdGhpcy5fc3RhdGVbMF0sIHRoaXMuX3N0YXRlWzFdLCBzZWVkSGkgPj4+IDAsIHNlZWRMbyA+Pj4gMCk7XG4gICAgdGhpcy5fbmV4dCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhcyBhXG4gICAqIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9zdGF0ZVswXSwgdGhpcy5fc3RhdGVbMV0sIHRoaXMuX3N0YXRlWzJdLCB0aGlzLl9zdGF0ZVszXV07XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmUgc3RhdGUgcHJldmlvdXNseSByZXRyaWV2ZWQgdXNpbmcgYGdldFN0YXRlKClgLlxuICAgKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5fc3RhdGVbMF0gPSBzdGF0ZVswXTtcbiAgICB0aGlzLl9zdGF0ZVsxXSA9IHN0YXRlWzFdO1xuICAgIHRoaXMuX3N0YXRlWzJdID0gc3RhdGVbMl07XG4gICAgdGhpcy5fc3RhdGVbM10gPSBzdGF0ZVszXSB8IDE7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHVuaWZvcm1seSBkaXN0cmlidXRlZCAzMiBiaXQgaW50ZWdlciBiZXR3ZWVuIFswLCBtYXgpLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgZ2V0dGVyXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgaW50ZWdlcihtYXgpIHtcbiAgICBpZiAoIW1heCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25leHQoKTtcbiAgICB9XG4gICAgbWF4ID0gbWF4ID4+PiAwO1xuICAgIGlmICgobWF4ICYgbWF4IC0gMSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZXh0KCkgJiBtYXggLSAxOyAvLyBmYXN0IHBhdGggZm9yIHBvd2VyIG9mIDJcbiAgICB9XG4gICAgbGV0IG51bSA9IDA7XG4gICAgY29uc3Qgc2tldyA9ICgtbWF4ID4+PiAwKSAlIG1heCA+Pj4gMDtcbiAgICBmb3IgKG51bSA9IHRoaXMuX25leHQoKTsgbnVtIDwgc2tldzsgbnVtID0gdGhpcy5fbmV4dCgpKSB7XG4gICAgICAvLyB0aGlzIGxvb3Agd2lsbCByYXJlbHkgZXhlY3V0ZSBtb3JlIHRoYW4gdHdpY2UsXG4gICAgICAvLyBhbmQgaXMgaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICByZXR1cm4gbnVtICUgbWF4O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgSUVFRS03NTQgZG91YmxlIGJldHdlZW4gMC4wIGFuZCAxLjAsIHdpdGhcbiAgICogNTMgYml0cyBvZiBwcmVjaXNpb24gKGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2EgaXMgcmFuZG9taXplZCkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgbnVtYmVyKCkge1xuICAgIGNvbnN0IGhpID0gKHRoaXMuX25leHQoKSAmIDB4MDNmZmZmZmYpICogMS4wO1xuICAgIGNvbnN0IGxvID0gKHRoaXMuX25leHQoKSAmIDB4MDdmZmZmZmYpICogMS4wO1xuICAgIHJldHVybiAoaGkgKiBCSVRfMjcgKyBsbykgLyBCSVRfNTM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbmV4dCgpIHtcbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGUgKHdoYXQgd2UnbGwgdXNlIGZvciB0aGlzIG51bWJlcilcbiAgICBjb25zdCBvbGRIaSA9IHRoaXMuX3N0YXRlWzBdID4+PiAwO1xuICAgIGNvbnN0IG9sZExvID0gdGhpcy5fc3RhdGVbMV0gPj4+IDA7XG4gICAgLy8gY2h1cm4gTENHLlxuICAgIG11bDY0KHRoaXMuX3N0YXRlLCBvbGRIaSwgb2xkTG8sIE1VTF9ISSwgTVVMX0xPKTtcbiAgICBhZGQ2NCh0aGlzLl9zdGF0ZSwgdGhpcy5fc3RhdGVbMF0sIHRoaXMuX3N0YXRlWzFdLCB0aGlzLl9zdGF0ZVsyXSwgdGhpcy5fc3RhdGVbM10pO1xuICAgIC8vIGdldCBsZWFzdCBzaWcuIDMyIGJpdHMgb2YgKChvbGRzdGF0ZSA+PiAxOCkgXiBvbGRzdGF0ZSkgPj4gMjdcbiAgICBsZXQgeHNIaSA9IG9sZEhpID4+PiAxODtcbiAgICBsZXQgeHNMbyA9IChvbGRMbyA+Pj4gMTggfCBvbGRIaSA8PCAxNCkgPj4+IDA7XG4gICAgeHNIaSA9ICh4c0hpIF4gb2xkSGkpID4+PiAwO1xuICAgIHhzTG8gPSAoeHNMbyBeIG9sZExvKSA+Pj4gMDtcbiAgICBjb25zdCB4b3JzaGlmdGVkID0gKHhzTG8gPj4+IDI3IHwgeHNIaSA8PCA1KSA+Pj4gMDtcbiAgICAvLyByb3RhdGUgeG9yc2hpZnRlZCByaWdodCBhIHJhbmRvbSBhbW91bnQsIGJhc2VkIG9uIHRoZSBtb3N0IHNpZy4gNSBiaXRzXG4gICAgLy8gYml0cyBvZiB0aGUgb2xkIHN0YXRlLlxuICAgIGNvbnN0IHJvdCA9IG9sZEhpID4+PiAyNztcbiAgICBjb25zdCByb3QyID0gKC1yb3QgPj4+IDAgJiAzMSkgPj4+IDA7XG4gICAgcmV0dXJuICh4b3JzaGlmdGVkID4+PiByb3QgfCB4b3JzaGlmdGVkIDw8IHJvdDIpID4+PiAwO1xuICB9XG59XG5mdW5jdGlvbiBtdWw2NChvdXQsIGFIaSwgYUxvLCBiSGksIGJMbykge1xuICBsZXQgYzEgPSAoYUxvID4+PiAxNikgKiAoYkxvICYgMHhmZmZmKSA+Pj4gMDtcbiAgbGV0IGMwID0gKGFMbyAmIDB4ZmZmZikgKiAoYkxvID4+PiAxNikgPj4+IDA7XG4gIGxldCBsbyA9IChhTG8gJiAweGZmZmYpICogKGJMbyAmIDB4ZmZmZikgPj4+IDA7XG4gIGxldCBoaSA9IChhTG8gPj4+IDE2KSAqIChiTG8gPj4+IDE2KSArICgoYzAgPj4+IDE2KSArIChjMSA+Pj4gMTYpKSA+Pj4gMDtcbiAgYzAgPSBjMCA8PCAxNiA+Pj4gMDtcbiAgbG8gPSBsbyArIGMwID4+PiAwO1xuICBpZiAobG8gPj4+IDAgPCBjMCA+Pj4gMCkge1xuICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICB9XG4gIGMxID0gYzEgPDwgMTYgPj4+IDA7XG4gIGxvID0gbG8gKyBjMSA+Pj4gMDtcbiAgaWYgKGxvID4+PiAwIDwgYzEgPj4+IDApIHtcbiAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgfVxuICBoaSA9IGhpICsgTWF0aC5pbXVsKGFMbywgYkhpKSA+Pj4gMDtcbiAgaGkgPSBoaSArIE1hdGguaW11bChhSGksIGJMbykgPj4+IDA7XG4gIG91dFswXSA9IGhpO1xuICBvdXRbMV0gPSBsbztcbn1cbi8vIGFkZCB0d28gNjQgYml0IG51bWJlcnMgKGdpdmVuIGluIHBhcnRzKSwgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW4gYG91dGAuXG5mdW5jdGlvbiBhZGQ2NChvdXQsIGFIaSwgYUxvLCBiSGksIGJMbykge1xuICBsZXQgaGkgPSBhSGkgKyBiSGkgPj4+IDA7XG4gIGNvbnN0IGxvID0gYUxvICsgYkxvID4+PiAwO1xuICBpZiAobG8gPj4+IDAgPCBhTG8gPj4+IDApIHtcbiAgICBoaSA9IGhpICsgMSB8IDA7XG4gIH1cbiAgb3V0WzBdID0gaGk7XG4gIG91dFsxXSA9IGxvO1xufVxuLyoqXG4gKiBAc2luY2UgMy4wLjZcbiAqL1xuZXhwb3J0IGNvbnN0IFlpZWxkV3JhcFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L1V0aWxzL1lpZWxkV3JhcFwiKTtcbi8qKlxuICogQHNpbmNlIDMuMC42XG4gKi9cbmV4cG9ydCBjbGFzcyBZaWVsZFdyYXAge1xuICAvKipcbiAgICogQHNpbmNlIDMuMC42XG4gICAqL1xuICAjdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy4jdmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDMuMC42XG4gICAqL1xuICBbWWllbGRXcmFwVHlwZUlkXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogQHNpbmNlIDMuMC42XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5aWVsZFdyYXBHZXQoc2VsZikge1xuICBpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZiAhPT0gbnVsbCAmJiBZaWVsZFdyYXBUeXBlSWQgaW4gc2VsZikge1xuICAgIHJldHVybiBzZWxmW1lpZWxkV3JhcFR5cGVJZF0oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoZ2V0QnVnRXJyb3JNZXNzYWdlKFwieWllbGRXcmFwR2V0XCIpKTtcbn1cbi8qKlxuICogTm90ZTogdGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBtYWRlIGF2YWlsYWJsZSB0byBhbGxvdyBjdXN0b20gbWF0Y2hlcnMgaW4gdGVzdHMsIG5vdCB0byBiZSBkaXJlY3RseSB1c2VkIHlldCBpbiB1c2VyIGNvZGVcbiAqXG4gKiBAc2luY2UgMy4xLjFcbiAqIEBzdGF0dXMgZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbW9kaWZpZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUgPSAvKiNfX1BVUkVfXyovZ2xvYmFsVmFsdWUoXCJlZmZlY3QvVXRpbHMvaXNTdHJ1Y3R1cmFsUmVnaW9uXCIsICgpID0+ICh7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICB0ZXN0ZXI6IHVuZGVmaW5lZFxufSkpO1xuLyoqXG4gKiBOb3RlOiB0aGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIG1hZGUgYXZhaWxhYmxlIHRvIGFsbG93IGN1c3RvbSBtYXRjaGVycyBpbiB0ZXN0cywgbm90IHRvIGJlIGRpcmVjdGx5IHVzZWQgeWV0IGluIHVzZXIgY29kZVxuICpcbiAqIEBzaW5jZSAzLjEuMVxuICogQHN0YXR1cyBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtb2RpZmllcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cnVjdHVyYWxSZWdpb24gPSAoYm9keSwgdGVzdGVyKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnQgPSBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZDtcbiAgY29uc3QgY3VycmVudFRlc3RlciA9IHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXI7XG4gIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS5lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKHRlc3Rlcikge1xuICAgIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIgPSB0ZXN0ZXI7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYm9keSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS5lbmFibGVkID0gY3VycmVudDtcbiAgICBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID0gY3VycmVudFRlc3RlcjtcbiAgfVxufTtcbmNvbnN0IHRyYWNpbmdGdW5jdGlvbiA9IG5hbWUgPT4ge1xuICBjb25zdCB3cmFwID0ge1xuICAgIFtuYW1lXShib2R5KSB7XG4gICAgICByZXR1cm4gYm9keSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB3cmFwW25hbWVdKGZuKTtcbiAgfTtcbn07XG4vKipcbiAqIEBzaW5jZSAzLjIuMlxuICogQHN0YXR1cyBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSB0cmFjaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbENhbGwgPSAvKiNfX1BVUkVfXyovdHJhY2luZ0Z1bmN0aW9uKFwiZWZmZWN0X2ludGVybmFsX2Z1bmN0aW9uXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/context.js":
/*!**********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/context.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextProto: () => (/* binding */ ContextProto),\n/* harmony export */   STMTypeId: () => (/* binding */ STMTypeId),\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   TagProto: () => (/* binding */ TagProto),\n/* harmony export */   TagTypeId: () => (/* binding */ TagTypeId),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getOption: () => (/* binding */ getOption),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   isContext: () => (/* binding */ isContext),\n/* harmony export */   isTag: () => (/* binding */ isTag),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   makeContext: () => (/* binding */ makeContext),\n/* harmony export */   makeGenericTag: () => (/* binding */ makeGenericTag),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   unsafeGet: () => (/* binding */ unsafeGet)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _option_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n\n\n\n\n\n\n\n\n/** @internal */\nconst TagTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Tag\");\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n/** @internal */\nconst STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\n/** @internal */\nconst TagProto = {\n  ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n  _tag: \"Tag\",\n  _op: \"Tag\",\n  [STMTypeId]: _effectable_js__WEBPACK_IMPORTED_MODULE_0__.effectVariance,\n  [TagTypeId]: {\n    _Service: _ => _,\n    _Identifier: _ => _\n  },\n  toString() {\n    return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Tag\",\n      key: this.key,\n      stack: this.stack\n    };\n  },\n  [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  of(self) {\n    return self;\n  },\n  context(self) {\n    return make(this, self);\n  }\n};\n/** @internal */\nconst makeGenericTag = key => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  const tag = Object.create(TagProto);\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  tag.key = key;\n  return tag;\n};\n/** @internal */\nconst Tag = id => () => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function TagClass() {}\n  Object.setPrototypeOf(TagClass, TagProto);\n  TagClass.key = id;\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return TagClass;\n};\n/** @internal */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Context\");\n/** @internal */\nconst ContextProto = {\n  [TypeId]: {\n    _Services: _ => _\n  },\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !_Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_3__.number(this.unsafeMap.size));\n  },\n  pipe() {\n    return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_4__.pipeArguments)(this, arguments);\n  },\n  toString() {\n    return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)\n    };\n  },\n  [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n/** @internal */\nconst makeContext = unsafeMap => {\n  const context = Object.create(ContextProto);\n  context.unsafeMap = unsafeMap;\n  return context;\n};\nconst serviceNotFoundError = tag => {\n  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`);\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\");\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/);\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`;\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\");\n    lines.splice(1, 3);\n    error.stack = lines.join(\"\\n\");\n  }\n  return error;\n};\n/** @internal */\nconst isContext = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.hasProperty)(u, TypeId);\n/** @internal */\nconst isTag = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.hasProperty)(u, TagTypeId);\nconst _empty = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());\n/** @internal */\nconst empty = () => _empty;\n/** @internal */\nconst make = (tag, service) => makeContext(new Map([[tag.key, service]]));\n/** @internal */\nconst add = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag.key, service);\n  return makeContext(map);\n});\n/** @internal */\nconst unsafeGet = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    throw serviceNotFoundError(tag);\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nconst get = unsafeGet;\n/** @internal */\nconst getOrElse = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(3, (self, tag, orElse) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return orElse();\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nconst getOption = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return _option_js__WEBPACK_IMPORTED_MODULE_7__.none;\n  }\n  return _option_js__WEBPACK_IMPORTED_MODULE_7__.some(self.unsafeMap.get(tag.key));\n});\n/** @internal */\nconst merge = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n/** @internal */\nconst pick = (...tags) => self => {\n  const tagSet = new Set(tags.map(_ => _.key));\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return makeContext(newEnv);\n};\n/** @internal */\nconst omit = (...tags) => self => {\n  const newEnv = new Map(self.unsafeMap);\n  for (const tag of tags) {\n    newEnv.delete(tag.key);\n  }\n  return makeContext(newEnv);\n};\n//# sourceMappingURL=context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNDO0FBQ0g7QUFDbUM7QUFDdkI7QUFDRDtBQUNvQjtBQUM1QjtBQUN0QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1AsS0FBSywyREFBZTtBQUNwQjtBQUNBO0FBQ0EsZUFBZSwwREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLHVEQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRyw4REFBaUI7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLDZDQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZDQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcsNENBQVc7QUFDZCxXQUFXLDRDQUFXLE9BQU8sNENBQVc7QUFDeEMsR0FBRztBQUNIO0FBQ0EsV0FBVywyREFBYTtBQUN4QixHQUFHO0FBQ0g7QUFDQSxXQUFXLHVEQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbURBQU07QUFDckQ7QUFDQSxHQUFHO0FBQ0gsR0FBRyw4REFBaUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZSxnQkFBZ0IsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QiwwREFBVztBQUN6QztBQUNPLG1CQUFtQiwwREFBVztBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTyx5QkFBeUIsa0RBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ08sK0JBQStCLGtEQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNPLCtCQUErQixrREFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLCtCQUErQixrREFBSTtBQUMxQztBQUNBLFdBQVcsNENBQVc7QUFDdEI7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCLENBQUM7QUFDRDtBQUNPLDJCQUEyQixrREFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvY29udGV4dC5qcz80YjI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuLi9FcXVhbC5qc1wiO1xuaW1wb3J0IHsgZHVhbCB9IGZyb20gXCIuLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tIFwiLi4vSGFzaC5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0LCBOb2RlSW5zcGVjdFN5bWJvbCwgdG9KU09OIH0gZnJvbSBcIi4uL0luc3BlY3RhYmxlLmpzXCI7XG5pbXBvcnQgeyBwaXBlQXJndW1lbnRzIH0gZnJvbSBcIi4uL1BpcGVhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSB9IGZyb20gXCIuLi9QcmVkaWNhdGUuanNcIjtcbmltcG9ydCB7IEVmZmVjdFByb3RvdHlwZSwgZWZmZWN0VmFyaWFuY2UgfSBmcm9tIFwiLi9lZmZlY3RhYmxlLmpzXCI7XG5pbXBvcnQgKiBhcyBvcHRpb24gZnJvbSBcIi4vb3B0aW9uLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgVGFnVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvQ29udGV4dC9UYWdcIik7XG4vKiogQGludGVybmFsICovXG5jb25zdCBTVE1TeW1ib2xLZXkgPSBcImVmZmVjdC9TVE1cIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTVE1UeXBlSWQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihTVE1TeW1ib2xLZXkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFRhZ1Byb3RvID0ge1xuICAuLi5FZmZlY3RQcm90b3R5cGUsXG4gIF90YWc6IFwiVGFnXCIsXG4gIF9vcDogXCJUYWdcIixcbiAgW1NUTVR5cGVJZF06IGVmZmVjdFZhcmlhbmNlLFxuICBbVGFnVHlwZUlkXToge1xuICAgIF9TZXJ2aWNlOiBfID0+IF8sXG4gICAgX0lkZW50aWZpZXI6IF8gPT4gX1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMudG9KU09OKCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJUYWdcIixcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH0sXG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH0sXG4gIG9mKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgY29udGV4dChzZWxmKSB7XG4gICAgcmV0dXJuIG1ha2UodGhpcywgc2VsZik7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWFrZUdlbmVyaWNUYWcgPSBrZXkgPT4ge1xuICBjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMjtcbiAgY29uc3QgY3JlYXRpb25FcnJvciA9IG5ldyBFcnJvcigpO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgY29uc3QgdGFnID0gT2JqZWN0LmNyZWF0ZShUYWdQcm90byk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YWcsIFwic3RhY2tcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGlvbkVycm9yLnN0YWNrO1xuICAgIH1cbiAgfSk7XG4gIHRhZy5rZXkgPSBrZXk7XG4gIHJldHVybiB0YWc7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFRhZyA9IGlkID0+ICgpID0+IHtcbiAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDI7XG4gIGNvbnN0IGNyZWF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIFRhZ0NsYXNzKCkge31cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFRhZ0NsYXNzLCBUYWdQcm90byk7XG4gIFRhZ0NsYXNzLmtleSA9IGlkO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFnQ2xhc3MsIFwic3RhY2tcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGlvbkVycm9yLnN0YWNrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBUYWdDbGFzcztcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvQ29udGV4dFwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBDb250ZXh0UHJvdG8gPSB7XG4gIFtUeXBlSWRdOiB7XG4gICAgX1NlcnZpY2VzOiBfID0+IF9cbiAgfSxcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIGlmIChpc0NvbnRleHQodGhhdCkpIHtcbiAgICAgIGlmICh0aGlzLnVuc2FmZU1hcC5zaXplID09PSB0aGF0LnVuc2FmZU1hcC5zaXplKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB0aGlzLnVuc2FmZU1hcC5rZXlzKCkpIHtcbiAgICAgICAgICBpZiAoIXRoYXQudW5zYWZlTWFwLmhhcyhrKSB8fCAhRXF1YWwuZXF1YWxzKHRoaXMudW5zYWZlTWFwLmdldChrKSwgdGhhdC51bnNhZmVNYXAuZ2V0KGspKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBIYXNoLmNhY2hlZCh0aGlzLCBIYXNoLm51bWJlcih0aGlzLnVuc2FmZU1hcC5zaXplKSk7XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHBpcGVBcmd1bWVudHModGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiQ29udGV4dFwiLFxuICAgICAgc2VydmljZXM6IEFycmF5LmZyb20odGhpcy51bnNhZmVNYXApLm1hcCh0b0pTT04pXG4gICAgfTtcbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfVxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWtlQ29udGV4dCA9IHVuc2FmZU1hcCA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKENvbnRleHRQcm90byk7XG4gIGNvbnRleHQudW5zYWZlTWFwID0gdW5zYWZlTWFwO1xuICByZXR1cm4gY29udGV4dDtcbn07XG5jb25zdCBzZXJ2aWNlTm90Rm91bmRFcnJvciA9IHRhZyA9PiB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBTZXJ2aWNlIG5vdCBmb3VuZCR7dGFnLmtleSA/IGA6ICR7U3RyaW5nKHRhZy5rZXkpfWAgOiBcIlwifWApO1xuICBpZiAodGFnLnN0YWNrKSB7XG4gICAgY29uc3QgbGluZXMgPSB0YWcuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGNvbnN0IGFmdGVyQXQgPSBsaW5lc1syXS5tYXRjaCgvYXQgKC4qKS8pO1xuICAgICAgaWYgKGFmdGVyQXQpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgKyBgIChkZWZpbmVkIGF0ICR7YWZ0ZXJBdFsxXX0pYDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgY29uc3QgbGluZXMgPSBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICBsaW5lcy5zcGxpY2UoMSwgMyk7XG4gICAgZXJyb3Iuc3RhY2sgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNDb250ZXh0ID0gdSA9PiBoYXNQcm9wZXJ0eSh1LCBUeXBlSWQpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGlzVGFnID0gdSA9PiBoYXNQcm9wZXJ0eSh1LCBUYWdUeXBlSWQpO1xuY29uc3QgX2VtcHR5ID0gLyojX19QVVJFX18qL21ha2VDb250ZXh0KCAvKiNfX1BVUkVfXyovbmV3IE1hcCgpKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlbXB0eSA9ICgpID0+IF9lbXB0eTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gKHRhZywgc2VydmljZSkgPT4gbWFrZUNvbnRleHQobmV3IE1hcChbW3RhZy5rZXksIHNlcnZpY2VdXSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0YWcsIHNlcnZpY2UpID0+IHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcChzZWxmLnVuc2FmZU1hcCk7XG4gIG1hcC5zZXQodGFnLmtleSwgc2VydmljZSk7XG4gIHJldHVybiBtYWtlQ29udGV4dChtYXApO1xufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdW5zYWZlR2V0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRhZykgPT4ge1xuICBpZiAoIXNlbGYudW5zYWZlTWFwLmhhcyh0YWcua2V5KSkge1xuICAgIHRocm93IHNlcnZpY2VOb3RGb3VuZEVycm9yKHRhZyk7XG4gIH1cbiAgcmV0dXJuIHNlbGYudW5zYWZlTWFwLmdldCh0YWcua2V5KTtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGdldCA9IHVuc2FmZUdldDtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGFnLCBvckVsc2UpID0+IHtcbiAgaWYgKCFzZWxmLnVuc2FmZU1hcC5oYXModGFnLmtleSkpIHtcbiAgICByZXR1cm4gb3JFbHNlKCk7XG4gIH1cbiAgcmV0dXJuIHNlbGYudW5zYWZlTWFwLmdldCh0YWcua2V5KTtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGdldE9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0YWcpID0+IHtcbiAgaWYgKCFzZWxmLnVuc2FmZU1hcC5oYXModGFnLmtleSkpIHtcbiAgICByZXR1cm4gb3B0aW9uLm5vbmU7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi5zb21lKHNlbGYudW5zYWZlTWFwLmdldCh0YWcua2V5KSk7XG59KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtZXJnZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoc2VsZi51bnNhZmVNYXApO1xuICBmb3IgKGNvbnN0IFt0YWcsIHNdIG9mIHRoYXQudW5zYWZlTWFwKSB7XG4gICAgbWFwLnNldCh0YWcsIHMpO1xuICB9XG4gIHJldHVybiBtYWtlQ29udGV4dChtYXApO1xufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcGljayA9ICguLi50YWdzKSA9PiBzZWxmID0+IHtcbiAgY29uc3QgdGFnU2V0ID0gbmV3IFNldCh0YWdzLm1hcChfID0+IF8ua2V5KSk7XG4gIGNvbnN0IG5ld0VudiA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBbdGFnLCBzXSBvZiBzZWxmLnVuc2FmZU1hcC5lbnRyaWVzKCkpIHtcbiAgICBpZiAodGFnU2V0Lmhhcyh0YWcpKSB7XG4gICAgICBuZXdFbnYuc2V0KHRhZywgcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYWtlQ29udGV4dChuZXdFbnYpO1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBvbWl0ID0gKC4uLnRhZ3MpID0+IHNlbGYgPT4ge1xuICBjb25zdCBuZXdFbnYgPSBuZXcgTWFwKHNlbGYudW5zYWZlTWFwKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgIG5ld0Vudi5kZWxldGUodGFnLmtleSk7XG4gIH1cbiAgcmV0dXJuIG1ha2VDb250ZXh0KG5ld0Vudik7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js":
/*!*************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/doNotation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   let_: () => (/* binding */ let_)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n\n/** @internal */\nconst let_ = map => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, name, f) => map(self, a => Object.assign({}, a, {\n  [name]: f(a)\n})));\n/** @internal */\nconst bindTo = map => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, name) => map(self, a => ({\n  [name]: a\n})));\n/** @internal */\nconst bind = (map, flatMap) => (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, name, f) => flatMap(self, a => map(f(a), b => Object.assign({}, a, {\n  [name]: b\n}))));\n//# sourceMappingURL=doNotation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2RvTm90YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUN0QztBQUNPLG9CQUFvQixrREFBSSxzREFBc0Q7QUFDckY7QUFDQSxDQUFDO0FBQ0Q7QUFDTyxzQkFBc0Isa0RBQUk7QUFDakM7QUFDQSxDQUFDO0FBQ0Q7QUFDTywrQkFBK0Isa0RBQUkseUVBQXlFO0FBQ25IO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2RvTm90YXRpb24uanM/ZDMwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkdWFsIH0gZnJvbSBcIi4uL0Z1bmN0aW9uLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbGV0XyA9IG1hcCA9PiBkdWFsKDMsIChzZWxmLCBuYW1lLCBmKSA9PiBtYXAoc2VsZiwgYSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCB7XG4gIFtuYW1lXTogZihhKVxufSkpKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBiaW5kVG8gPSBtYXAgPT4gZHVhbCgyLCAoc2VsZiwgbmFtZSkgPT4gbWFwKHNlbGYsIGEgPT4gKHtcbiAgW25hbWVdOiBhXG59KSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJpbmQgPSAobWFwLCBmbGF0TWFwKSA9PiBkdWFsKDMsIChzZWxmLCBuYW1lLCBmKSA9PiBmbGF0TWFwKHNlbGYsIGEgPT4gbWFwKGYoYSksIGIgPT4gT2JqZWN0LmFzc2lnbih7fSwgYSwge1xuICBbbmFtZV06IGJcbn0pKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9Ob3RhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/effectable.js":
/*!*************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/effectable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base: () => (/* binding */ Base),\n/* harmony export */   ChannelTypeId: () => (/* binding */ ChannelTypeId),\n/* harmony export */   CommitPrototype: () => (/* binding */ CommitPrototype),\n/* harmony export */   EffectPrototype: () => (/* binding */ EffectPrototype),\n/* harmony export */   EffectTypeId: () => (/* binding */ EffectTypeId),\n/* harmony export */   SinkTypeId: () => (/* binding */ SinkTypeId),\n/* harmony export */   StreamTypeId: () => (/* binding */ StreamTypeId),\n/* harmony export */   StructuralBase: () => (/* binding */ StructuralBase),\n/* harmony export */   StructuralCommitPrototype: () => (/* binding */ StructuralCommitPrototype),\n/* harmony export */   StructuralPrototype: () => (/* binding */ StructuralPrototype),\n/* harmony export */   effectVariance: () => (/* binding */ effectVariance)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/* harmony import */ var _opCodes_effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./opCodes/effect.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/version.js\");\n\n\n\n\n\n\n/** @internal */\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n/** @internal */\nconst StreamTypeId = /*#__PURE__*/Symbol.for(\"effect/Stream\");\n/** @internal */\nconst SinkTypeId = /*#__PURE__*/Symbol.for(\"effect/Sink\");\n/** @internal */\nconst ChannelTypeId = /*#__PURE__*/Symbol.for(\"effect/Channel\");\n/** @internal */\nconst effectVariance = {\n  /* c8 ignore next */\n  _R: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _,\n  _V: /*#__PURE__*/_version_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentVersion()\n};\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: _ => _,\n  /* c8 ignore next */\n  _In: _ => _,\n  /* c8 ignore next */\n  _L: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\nconst channelVariance = {\n  /* c8 ignore next */\n  _Env: _ => _,\n  /* c8 ignore next */\n  _InErr: _ => _,\n  /* c8 ignore next */\n  _InElem: _ => _,\n  /* c8 ignore next */\n  _InDone: _ => _,\n  /* c8 ignore next */\n  _OutErr: _ => _,\n  /* c8 ignore next */\n  _OutElem: _ => _,\n  /* c8 ignore next */\n  _OutDone: _ => _\n};\n/** @internal */\nconst EffectPrototype = {\n  [EffectTypeId]: effectVariance,\n  [StreamTypeId]: effectVariance,\n  [SinkTypeId]: sinkVariance,\n  [ChannelTypeId]: channelVariance,\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_1__.symbol](that) {\n    return this === that;\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_2__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_2__.random(this));\n  },\n  [Symbol.iterator]() {\n    return new _Utils_js__WEBPACK_IMPORTED_MODULE_3__.SingleShotGen(new _Utils_js__WEBPACK_IMPORTED_MODULE_3__.YieldWrap(this));\n  },\n  pipe() {\n    return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_4__.pipeArguments)(this, arguments);\n  }\n};\n/** @internal */\nconst StructuralPrototype = {\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_2__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_2__.structure(this));\n  },\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_1__.symbol](that) {\n    const selfKeys = Object.keys(this);\n    const thatKeys = Object.keys(that);\n    if (selfKeys.length !== thatKeys.length) {\n      return false;\n    }\n    for (const key of selfKeys) {\n      if (!(key in that && _Equal_js__WEBPACK_IMPORTED_MODULE_1__.equals(this[key], that[key]))) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n/** @internal */\nconst CommitPrototype = {\n  ...EffectPrototype,\n  _op: _opCodes_effect_js__WEBPACK_IMPORTED_MODULE_5__.OP_COMMIT\n};\n/** @internal */\nconst StructuralCommitPrototype = {\n  ...CommitPrototype,\n  ...StructuralPrototype\n};\n/** @internal */\nconst Base = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = CommitPrototype;\n  return Base;\n}();\n/** @internal */\nconst StructuralBase = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = StructuralCommitPrototype;\n  return Base;\n}();\n//# sourceMappingURL=effectable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VmZmVjdGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRjtBQUNZO0FBQ1E7QUFDUjtBQUNQO0FBQ3hDO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBWTtBQUNmO0FBQ0EsR0FBRztBQUNILEdBQUcsNENBQVc7QUFDZCxXQUFXLDRDQUFXLE9BQU8sNENBQVc7QUFDeEMsR0FBRztBQUNIO0FBQ0EsZUFBZSxvREFBYSxLQUFLLGdEQUFTO0FBQzFDLEdBQUc7QUFDSDtBQUNBLFdBQVcsMkRBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ087QUFDUCxHQUFHLDRDQUFXO0FBQ2QsV0FBVyw0Q0FBVyxPQUFPLCtDQUFjO0FBQzNDLEdBQUc7QUFDSCxHQUFHLDZDQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLE9BQU8seURBQWlCO0FBQ3hCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lZmZlY3RhYmxlLmpzPzRjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXF1YWwgZnJvbSBcIi4uL0VxdWFsLmpzXCI7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gXCIuLi9IYXNoLmpzXCI7XG5pbXBvcnQgeyBwaXBlQXJndW1lbnRzIH0gZnJvbSBcIi4uL1BpcGVhYmxlLmpzXCI7XG5pbXBvcnQgeyBTaW5nbGVTaG90R2VuLCBZaWVsZFdyYXAgfSBmcm9tIFwiLi4vVXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIE9wQ29kZXMgZnJvbSBcIi4vb3BDb2Rlcy9lZmZlY3QuanNcIjtcbmltcG9ydCAqIGFzIHZlcnNpb24gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IEVmZmVjdFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0VmZmVjdFwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1UeXBlSWQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9TdHJlYW1cIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgU2lua1R5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L1NpbmtcIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgQ2hhbm5lbFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0NoYW5uZWxcIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZWZmZWN0VmFyaWFuY2UgPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9SOiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9FOiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9BOiBfID0+IF8sXG4gIF9WOiAvKiNfX1BVUkVfXyovdmVyc2lvbi5nZXRDdXJyZW50VmVyc2lvbigpXG59O1xuY29uc3Qgc2lua1ZhcmlhbmNlID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfQTogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW46IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0w6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0U6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX1I6IF8gPT4gX1xufTtcbmNvbnN0IGNoYW5uZWxWYXJpYW5jZSA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0VudjogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW5FcnI6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0luRWxlbTogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW5Eb25lOiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9PdXRFcnI6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX091dEVsZW06IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX091dERvbmU6IF8gPT4gX1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBFZmZlY3RQcm90b3R5cGUgPSB7XG4gIFtFZmZlY3RUeXBlSWRdOiBlZmZlY3RWYXJpYW5jZSxcbiAgW1N0cmVhbVR5cGVJZF06IGVmZmVjdFZhcmlhbmNlLFxuICBbU2lua1R5cGVJZF06IHNpbmtWYXJpYW5jZSxcbiAgW0NoYW5uZWxUeXBlSWRdOiBjaGFubmVsVmFyaWFuY2UsXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gdGhhdDtcbiAgfSxcbiAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICByZXR1cm4gSGFzaC5jYWNoZWQodGhpcywgSGFzaC5yYW5kb20odGhpcykpO1xuICB9LFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IFNpbmdsZVNob3RHZW4obmV3IFlpZWxkV3JhcCh0aGlzKSk7XG4gIH0sXG4gIHBpcGUoKSB7XG4gICAgcmV0dXJuIHBpcGVBcmd1bWVudHModGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTdHJ1Y3R1cmFsUHJvdG90eXBlID0ge1xuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBIYXNoLmNhY2hlZCh0aGlzLCBIYXNoLnN0cnVjdHVyZSh0aGlzKSk7XG4gIH0sXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICBjb25zdCBzZWxmS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGNvbnN0IHRoYXRLZXlzID0gT2JqZWN0LmtleXModGhhdCk7XG4gICAgaWYgKHNlbGZLZXlzLmxlbmd0aCAhPT0gdGhhdEtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHNlbGZLZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhhdCAmJiBFcXVhbC5lcXVhbHModGhpc1trZXldLCB0aGF0W2tleV0pKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IENvbW1pdFByb3RvdHlwZSA9IHtcbiAgLi4uRWZmZWN0UHJvdG90eXBlLFxuICBfb3A6IE9wQ29kZXMuT1BfQ09NTUlUXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFN0cnVjdHVyYWxDb21taXRQcm90b3R5cGUgPSB7XG4gIC4uLkNvbW1pdFByb3RvdHlwZSxcbiAgLi4uU3RydWN0dXJhbFByb3RvdHlwZVxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZSgpIHt9XG4gIEJhc2UucHJvdG90eXBlID0gQ29tbWl0UHJvdG90eXBlO1xuICByZXR1cm4gQmFzZTtcbn0oKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTdHJ1Y3R1cmFsQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2UoKSB7fVxuICBCYXNlLnByb3RvdHlwZSA9IFN0cnVjdHVyYWxDb21taXRQcm90b3R5cGU7XG4gIHJldHVybiBCYXNlO1xufSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWZmZWN0YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/either.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/either.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isEither: () => (/* binding */ isEither),\n/* harmony export */   isLeft: () => (/* binding */ isLeft),\n/* harmony export */   isRight: () => (/* binding */ isRight),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   right: () => (/* binding */ right)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _option_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n/**\n * @since 2.0.0\n */\n\n\n\n\n\n\n\n/**\n * @internal\n */\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Either\");\nconst CommonProto = {\n  ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n  [TypeId]: {\n    _R: _ => _\n  },\n  [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n  }\n};\nconst RightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol](that) {\n    return isEither(that) && isRight(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.right, that.right);\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.right));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.right)\n    };\n  }\n});\nconst LeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol](that) {\n    return isEither(that) && isLeft(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.left, that.left);\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.left));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.left)\n    };\n  }\n});\n/** @internal */\nconst isEither = input => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(input, TypeId);\n/** @internal */\nconst isLeft = ma => ma._tag === \"Left\";\n/** @internal */\nconst isRight = ma => ma._tag === \"Right\";\n/** @internal */\nconst left = left => {\n  const a = Object.create(LeftProto);\n  a.left = left;\n  return a;\n};\n/** @internal */\nconst right = right => {\n  const a = Object.create(RightProto);\n  a.right = right;\n  return a;\n};\n/** @internal */\nconst getLeft = self => isRight(self) ? _option_js__WEBPACK_IMPORTED_MODULE_5__.none : _option_js__WEBPACK_IMPORTED_MODULE_5__.some(self.left);\n/** @internal */\nconst getRight = self => isLeft(self) ? _option_js__WEBPACK_IMPORTED_MODULE_5__.none : _option_js__WEBPACK_IMPORTED_MODULE_5__.some(self.right);\n/** @internal */\nconst fromOption = /*#__PURE__*/(0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, onNone) => _option_js__WEBPACK_IMPORTED_MODULE_5__.isNone(self) ? left(onNone()) : right(self.value));\n//# sourceMappingURL=either.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VpdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3FDO0FBQ0M7QUFDSDtBQUNtQztBQUN4QjtBQUNJO0FBQ1o7QUFDdEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLEtBQUssMkRBQWU7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLDhEQUFpQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsdURBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkNBQVk7QUFDZiw4Q0FBOEMsNkNBQVk7QUFDMUQsR0FBRztBQUNILEdBQUcsNENBQVc7QUFDZCxXQUFXLDZDQUFZLENBQUMsMENBQVMsYUFBYSwwQ0FBUztBQUN2RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFNO0FBQ25CO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBWTtBQUNmLDZDQUE2Qyw2Q0FBWTtBQUN6RCxHQUFHO0FBQ0gsR0FBRyw0Q0FBVztBQUNkLFdBQVcsNkNBQVksQ0FBQywwQ0FBUyxhQUFhLDBDQUFTO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLDBCQUEwQiwwREFBVztBQUM1QztBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0NBQXdDLDRDQUFXLEdBQUcsNENBQVc7QUFDeEU7QUFDTyx3Q0FBd0MsNENBQVcsR0FBRyw0Q0FBVztBQUN4RTtBQUNPLGdDQUFnQyxrREFBSSxzQkFBc0IsOENBQWE7QUFDOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvZWl0aGVyLmpzP2JlMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgRXF1YWwgZnJvbSBcIi4uL0VxdWFsLmpzXCI7XG5pbXBvcnQgeyBkdWFsIH0gZnJvbSBcIi4uL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gXCIuLi9IYXNoLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXQsIE5vZGVJbnNwZWN0U3ltYm9sLCB0b0pTT04gfSBmcm9tIFwiLi4vSW5zcGVjdGFibGUuanNcIjtcbmltcG9ydCB7IGhhc1Byb3BlcnR5IH0gZnJvbSBcIi4uL1ByZWRpY2F0ZS5qc1wiO1xuaW1wb3J0IHsgRWZmZWN0UHJvdG90eXBlIH0gZnJvbSBcIi4vZWZmZWN0YWJsZS5qc1wiO1xuaW1wb3J0ICogYXMgb3B0aW9uIGZyb20gXCIuL29wdGlvbi5qc1wiO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0VpdGhlclwiKTtcbmNvbnN0IENvbW1vblByb3RvID0ge1xuICAuLi5FZmZlY3RQcm90b3R5cGUsXG4gIFtUeXBlSWRdOiB7XG4gICAgX1I6IF8gPT4gX1xuICB9LFxuICBbTm9kZUluc3BlY3RTeW1ib2xdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMudG9KU09OKCkpO1xuICB9XG59O1xuY29uc3QgUmlnaHRQcm90byA9IC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKCAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShDb21tb25Qcm90byksIHtcbiAgX3RhZzogXCJSaWdodFwiLFxuICBfb3A6IFwiUmlnaHRcIixcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIHJldHVybiBpc0VpdGhlcih0aGF0KSAmJiBpc1JpZ2h0KHRoYXQpICYmIEVxdWFsLmVxdWFscyh0aGlzLnJpZ2h0LCB0aGF0LnJpZ2h0KTtcbiAgfSxcbiAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICByZXR1cm4gSGFzaC5jb21iaW5lKEhhc2guaGFzaCh0aGlzLl90YWcpKShIYXNoLmhhc2godGhpcy5yaWdodCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJFaXRoZXJcIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIHJpZ2h0OiB0b0pTT04odGhpcy5yaWdodClcbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IExlZnRQcm90byA9IC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKCAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShDb21tb25Qcm90byksIHtcbiAgX3RhZzogXCJMZWZ0XCIsXG4gIF9vcDogXCJMZWZ0XCIsXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICByZXR1cm4gaXNFaXRoZXIodGhhdCkgJiYgaXNMZWZ0KHRoYXQpICYmIEVxdWFsLmVxdWFscyh0aGlzLmxlZnQsIHRoYXQubGVmdCk7XG4gIH0sXG4gIFtIYXNoLnN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIEhhc2guY29tYmluZShIYXNoLmhhc2godGhpcy5fdGFnKSkoSGFzaC5oYXNoKHRoaXMubGVmdCkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJFaXRoZXJcIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIGxlZnQ6IHRvSlNPTih0aGlzLmxlZnQpXG4gICAgfTtcbiAgfVxufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNFaXRoZXIgPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgVHlwZUlkKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc0xlZnQgPSBtYSA9PiBtYS5fdGFnID09PSBcIkxlZnRcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc1JpZ2h0ID0gbWEgPT4gbWEuX3RhZyA9PT0gXCJSaWdodFwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGxlZnQgPSBsZWZ0ID0+IHtcbiAgY29uc3QgYSA9IE9iamVjdC5jcmVhdGUoTGVmdFByb3RvKTtcbiAgYS5sZWZ0ID0gbGVmdDtcbiAgcmV0dXJuIGE7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHJpZ2h0ID0gcmlnaHQgPT4ge1xuICBjb25zdCBhID0gT2JqZWN0LmNyZWF0ZShSaWdodFByb3RvKTtcbiAgYS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gYTtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZ2V0TGVmdCA9IHNlbGYgPT4gaXNSaWdodChzZWxmKSA/IG9wdGlvbi5ub25lIDogb3B0aW9uLnNvbWUoc2VsZi5sZWZ0KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBnZXRSaWdodCA9IHNlbGYgPT4gaXNMZWZ0KHNlbGYpID8gb3B0aW9uLm5vbmUgOiBvcHRpb24uc29tZShzZWxmLnJpZ2h0KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBmcm9tT3B0aW9uID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9uTm9uZSkgPT4gb3B0aW9uLmlzTm9uZShzZWxmKSA/IGxlZnQob25Ob25lKCkpIDogcmlnaHQoc2VsZi52YWx1ZSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWl0aGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/either.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js":
/*!******************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/base64.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n/** @internal */\nconst encode = bytes => {\n  const length = bytes.length;\n  let result = \"\";\n  let i;\n  for (i = 2; i < length; i += 3) {\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n    result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];\n    result += base64abc[bytes[i] & 0x3f];\n  }\n  if (i === length + 1) {\n    // 1 octet yet to write\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === length) {\n    // 2 octets yet to write\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n    result += base64abc[(bytes[i - 1] & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n};\n/** @internal */\nconst decode = str => {\n  const length = str.length;\n  if (length % 4 !== 0) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, `Length must be a multiple of 4, but is ${length}`));\n  }\n  const index = str.indexOf(\"=\");\n  if (index !== -1 && (index < length - 2 || index === length - 2 && str[length - 1] !== \"=\")) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, \"Found a '=' character, but it is not at the end\"));\n  }\n  try {\n    const missingOctets = str.endsWith(\"==\") ? 2 : str.endsWith(\"=\") ? 1 : 0;\n    const result = new Uint8Array(3 * (length / 4));\n    for (let i = 0, j = 0; i < length; i += 4, j += 3) {\n      const buffer = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));\n      result[j] = buffer >> 16;\n      result[j + 1] = buffer >> 8 & 0xff;\n      result[j + 2] = buffer & 0xff;\n    }\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.right(result.subarray(0, result.length - missingOctets));\n  } catch (e) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, e instanceof Error ? e.message : \"Invalid input\"));\n  }\n};\n/** @internal */\nfunction getBase64Code(charCode) {\n  if (charCode >= base64codes.length) {\n    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);\n  }\n  const code = base64codes[charCode];\n  if (code === 255) {\n    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);\n  }\n  return code;\n}\n/** @internal */\nconst base64abc = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"+\", \"/\"];\n/** @internal */\nconst base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ0k7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxXQUFXLDRDQUFXLENBQUMsMkRBQWUsZ0RBQWdELE9BQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBVyxDQUFDLDJEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkNBQVk7QUFDdkIsSUFBSTtBQUNKLFdBQVcsNENBQVcsQ0FBQywyREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhCQUE4QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvZW5jb2RpbmcvYmFzZTY0LmpzP2QxYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRWl0aGVyIGZyb20gXCIuLi8uLi9FaXRoZXIuanNcIjtcbmltcG9ydCB7IERlY29kZUV4Y2VwdGlvbiB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IGJ5dGVzID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbYnl0ZXNbaSAtIDJdID4+IDJdO1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbKGJ5dGVzW2kgLSAyXSAmIDB4MDMpIDw8IDQgfCBieXRlc1tpIC0gMV0gPj4gNF07XG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soYnl0ZXNbaSAtIDFdICYgMHgwZikgPDwgMiB8IGJ5dGVzW2ldID4+IDZdO1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbYnl0ZXNbaV0gJiAweDNmXTtcbiAgfVxuICBpZiAoaSA9PT0gbGVuZ3RoICsgMSkge1xuICAgIC8vIDEgb2N0ZXQgeWV0IHRvIHdyaXRlXG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1tieXRlc1tpIC0gMl0gPj4gMl07XG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soYnl0ZXNbaSAtIDJdICYgMHgwMykgPDwgNF07XG4gICAgcmVzdWx0ICs9IFwiPT1cIjtcbiAgfVxuICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgLy8gMiBvY3RldHMgeWV0IHRvIHdyaXRlXG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1tieXRlc1tpIC0gMl0gPj4gMl07XG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soYnl0ZXNbaSAtIDJdICYgMHgwMykgPDwgNCB8IGJ5dGVzW2kgLSAxXSA+PiA0XTtcbiAgICByZXN1bHQgKz0gYmFzZTY0YWJjWyhieXRlc1tpIC0gMV0gJiAweDBmKSA8PCAyXTtcbiAgICByZXN1bHQgKz0gXCI9XCI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gc3RyID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0ciwgYExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCwgYnV0IGlzICR7bGVuZ3RofWApKTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKFwiPVwiKTtcbiAgaWYgKGluZGV4ICE9PSAtMSAmJiAoaW5kZXggPCBsZW5ndGggLSAyIHx8IGluZGV4ID09PSBsZW5ndGggLSAyICYmIHN0cltsZW5ndGggLSAxXSAhPT0gXCI9XCIpKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHIsIFwiRm91bmQgYSAnPScgY2hhcmFjdGVyLCBidXQgaXQgaXMgbm90IGF0IHRoZSBlbmRcIikpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgbWlzc2luZ09jdGV0cyA9IHN0ci5lbmRzV2l0aChcIj09XCIpID8gMiA6IHN0ci5lbmRzV2l0aChcIj1cIikgPyAxIDogMDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzICogKGxlbmd0aCAvIDQpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBnZXRCYXNlNjRDb2RlKHN0ci5jaGFyQ29kZUF0KGkpKSA8PCAxOCB8IGdldEJhc2U2NENvZGUoc3RyLmNoYXJDb2RlQXQoaSArIDEpKSA8PCAxMiB8IGdldEJhc2U2NENvZGUoc3RyLmNoYXJDb2RlQXQoaSArIDIpKSA8PCA2IHwgZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpICsgMykpO1xuICAgICAgcmVzdWx0W2pdID0gYnVmZmVyID4+IDE2O1xuICAgICAgcmVzdWx0W2ogKyAxXSA9IGJ1ZmZlciA+PiA4ICYgMHhmZjtcbiAgICAgIHJlc3VsdFtqICsgMl0gPSBidWZmZXIgJiAweGZmO1xuICAgIH1cbiAgICByZXR1cm4gRWl0aGVyLnJpZ2h0KHJlc3VsdC5zdWJhcnJheSgwLCByZXN1bHQubGVuZ3RoIC0gbWlzc2luZ09jdGV0cykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHIsIGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiSW52YWxpZCBpbnB1dFwiKSk7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBnZXRCYXNlNjRDb2RlKGNoYXJDb2RlKSB7XG4gIGlmIChjaGFyQ29kZSA+PSBiYXNlNjRjb2Rlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfWApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBiYXNlNjRjb2Rlc1tjaGFyQ29kZV07XG4gIGlmIChjb2RlID09PSAyNTUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfWApO1xuICB9XG4gIHJldHVybiBjb2RlO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgYmFzZTY0YWJjID0gW1wiQVwiLCBcIkJcIiwgXCJDXCIsIFwiRFwiLCBcIkVcIiwgXCJGXCIsIFwiR1wiLCBcIkhcIiwgXCJJXCIsIFwiSlwiLCBcIktcIiwgXCJMXCIsIFwiTVwiLCBcIk5cIiwgXCJPXCIsIFwiUFwiLCBcIlFcIiwgXCJSXCIsIFwiU1wiLCBcIlRcIiwgXCJVXCIsIFwiVlwiLCBcIldcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLCBcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIrXCIsIFwiL1wiXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGJhc2U2NGNvZGVzID0gWzI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgNjIsIDI1NSwgMjU1LCAyNTUsIDYzLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSwgMjU1LCAyNTUsIDI1NSwgMCwgMjU1LCAyNTUsIDI1NSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/base64Url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n\n/** @internal */\nconst encode = data => _base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(data).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n/** @internal */\nconst decode = str => {\n  const length = str.length;\n  if (length % 4 === 1) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_1__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_2__.DecodeException)(str, `Length should be a multiple of 4, but is ${length}`));\n  }\n  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(str)) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_1__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_2__.DecodeException)(str, \"Invalid input\"));\n  }\n  // Some variants allow or require omitting the padding '=' signs\n  let sanitized = length % 4 === 2 ? `${str}==` : length % 4 === 3 ? `${str}=` : str;\n  sanitized = sanitized.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return _base64_js__WEBPACK_IMPORTED_MODULE_0__.decode(sanitized);\n};\n//# sourceMappingURL=base64Url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NFVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQztBQUNKO0FBQ1E7QUFDOUM7QUFDTyx1QkFBdUIsOENBQWE7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQSxXQUFXLDRDQUFXLENBQUMsMkRBQWUsa0RBQWtELE9BQU87QUFDL0Y7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQixXQUFXLDRDQUFXLENBQUMsMkRBQWU7QUFDdEM7QUFDQTtBQUNBLHdDQUF3QyxJQUFJLDRCQUE0QixJQUFJO0FBQzVFO0FBQ0EsU0FBUyw4Q0FBYTtBQUN0QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NFVybC5qcz81MTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVpdGhlciBmcm9tIFwiLi4vLi4vRWl0aGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBEZWNvZGVFeGNlcHRpb24gfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBkYXRhID0+IEJhc2U2NC5lbmNvZGUoZGF0YSkucmVwbGFjZSgvPS9nLCBcIlwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gc3RyID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0ciwgYExlbmd0aCBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiA0LCBidXQgaXMgJHtsZW5ndGh9YCkpO1xuICB9XG4gIGlmICghL15bLV9BLVowLTldKj89ezAsMn0kL2kudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHIsIFwiSW52YWxpZCBpbnB1dFwiKSk7XG4gIH1cbiAgLy8gU29tZSB2YXJpYW50cyBhbGxvdyBvciByZXF1aXJlIG9taXR0aW5nIHRoZSBwYWRkaW5nICc9JyBzaWduc1xuICBsZXQgc2FuaXRpemVkID0gbGVuZ3RoICUgNCA9PT0gMiA/IGAke3N0cn09PWAgOiBsZW5ndGggJSA0ID09PSAzID8gYCR7c3RyfT1gIDogc3RyO1xuICBzYW5pdGl6ZWQgPSBzYW5pdGl6ZWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHJldHVybiBCYXNlNjQuZGVjb2RlKHNhbml0aXplZCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0VXJsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js":
/*!******************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeException: () => (/* binding */ DecodeException),\n/* harmony export */   DecodeExceptionTypeId: () => (/* binding */ DecodeExceptionTypeId),\n/* harmony export */   decoder: () => (/* binding */ decoder),\n/* harmony export */   encoder: () => (/* binding */ encoder),\n/* harmony export */   isDecodeException: () => (/* binding */ isDecodeException)\n/* harmony export */ });\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n\n/** @internal */\nconst DecodeExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Encoding/errors/Decode\");\n/** @internal */\nconst DecodeException = (input, message) => {\n  const out = {\n    _tag: \"DecodeException\",\n    [DecodeExceptionTypeId]: DecodeExceptionTypeId,\n    input\n  };\n  if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isString)(message)) {\n    out.message = message;\n  }\n  return out;\n};\n/** @internal */\nconst isDecodeException = u => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(u, DecodeExceptionTypeId);\n/** @interal */\nconst encoder = /*#__PURE__*/new TextEncoder();\n/** @interal */\nconst decoder = /*#__PURE__*/new TextDecoder();\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFDM0Q7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQVc7QUFDakQ7QUFDTztBQUNQO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lbmNvZGluZy9jb21tb24uanM/MmZmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNTdHJpbmcgfSBmcm9tIFwiLi4vLi4vUHJlZGljYXRlLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgRGVjb2RlRXhjZXB0aW9uVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvRW5jb2RpbmcvZXJyb3JzL0RlY29kZVwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb24gPSAoaW5wdXQsIG1lc3NhZ2UpID0+IHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIF90YWc6IFwiRGVjb2RlRXhjZXB0aW9uXCIsXG4gICAgW0RlY29kZUV4Y2VwdGlvblR5cGVJZF06IERlY29kZUV4Y2VwdGlvblR5cGVJZCxcbiAgICBpbnB1dFxuICB9O1xuICBpZiAoaXNTdHJpbmcobWVzc2FnZSkpIHtcbiAgICBvdXQubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNEZWNvZGVFeGNlcHRpb24gPSB1ID0+IGhhc1Byb3BlcnR5KHUsIERlY29kZUV4Y2VwdGlvblR5cGVJZCk7XG4vKiogQGludGVyYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qL25ldyBUZXh0RW5jb2RlcigpO1xuLyoqIEBpbnRlcmFsICovXG5leHBvcnQgY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi9uZXcgVGV4dERlY29kZXIoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js":
/*!***************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/hex.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n/** @internal */\nconst encode = bytes => {\n  let result = \"\";\n  for (let i = 0; i < bytes.length; ++i) {\n    result += bytesToHex[bytes[i]];\n  }\n  return result;\n};\n/** @internal */\nconst decode = str => {\n  const bytes = new TextEncoder().encode(str);\n  if (bytes.length % 2 !== 0) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, `Length must be a multiple of 2, but is ${bytes.length}`));\n  }\n  try {\n    const length = bytes.length / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      const a = fromHexChar(bytes[i * 2]);\n      const b = fromHexChar(bytes[i * 2 + 1]);\n      result[i] = a << 4 | b;\n    }\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.right(result);\n  } catch (e) {\n    return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, e instanceof Error ? e.message : \"Invalid input\"));\n  }\n};\n/** @internal */\nconst bytesToHex = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\n/** @internal */\nconst fromHexChar = byte => {\n  // '0' <= byte && byte <= '9'\n  if (48 <= byte && byte <= 57) {\n    return byte - 48;\n  }\n  // 'a' <= byte && byte <= 'f'\n  if (97 <= byte && byte <= 102) {\n    return byte - 97 + 10;\n  }\n  // 'A' <= byte && byte <= 'F'\n  if (65 <= byte && byte <= 70) {\n    return byte - 65 + 10;\n  }\n  throw new TypeError(\"Invalid input\");\n};\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ0k7QUFDOUM7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsV0FBVyw0Q0FBVyxDQUFDLDJEQUFlLGdEQUFnRCxhQUFhO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFZO0FBQ3ZCLElBQUk7QUFDSixXQUFXLDRDQUFXLENBQUMsMkRBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZS1sZWFybmluZy13ZWJhcHBsaWNhdGlvbi1sbXMvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2hleC5qcz9jMDVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVpdGhlciBmcm9tIFwiLi4vLi4vRWl0aGVyLmpzXCI7XG5pbXBvcnQgeyBEZWNvZGVFeGNlcHRpb24gfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBieXRlcyA9PiB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0ICs9IGJ5dGVzVG9IZXhbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IHN0ciA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gIGlmIChieXRlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHIsIGBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIsIGJ1dCBpcyAke2J5dGVzLmxlbmd0aH1gKSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYSA9IGZyb21IZXhDaGFyKGJ5dGVzW2kgKiAyXSk7XG4gICAgICBjb25zdCBiID0gZnJvbUhleENoYXIoYnl0ZXNbaSAqIDIgKyAxXSk7XG4gICAgICByZXN1bHRbaV0gPSBhIDw8IDQgfCBiO1xuICAgIH1cbiAgICByZXR1cm4gRWl0aGVyLnJpZ2h0KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0ciwgZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogXCJJbnZhbGlkIGlucHV0XCIpKTtcbiAgfVxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGJ5dGVzVG9IZXggPSBbXCIwMFwiLCBcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjBhXCIsIFwiMGJcIiwgXCIwY1wiLCBcIjBkXCIsIFwiMGVcIiwgXCIwZlwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiLCBcIjEzXCIsIFwiMTRcIiwgXCIxNVwiLCBcIjE2XCIsIFwiMTdcIiwgXCIxOFwiLCBcIjE5XCIsIFwiMWFcIiwgXCIxYlwiLCBcIjFjXCIsIFwiMWRcIiwgXCIxZVwiLCBcIjFmXCIsIFwiMjBcIiwgXCIyMVwiLCBcIjIyXCIsIFwiMjNcIiwgXCIyNFwiLCBcIjI1XCIsIFwiMjZcIiwgXCIyN1wiLCBcIjI4XCIsIFwiMjlcIiwgXCIyYVwiLCBcIjJiXCIsIFwiMmNcIiwgXCIyZFwiLCBcIjJlXCIsIFwiMmZcIiwgXCIzMFwiLCBcIjMxXCIsIFwiMzJcIiwgXCIzM1wiLCBcIjM0XCIsIFwiMzVcIiwgXCIzNlwiLCBcIjM3XCIsIFwiMzhcIiwgXCIzOVwiLCBcIjNhXCIsIFwiM2JcIiwgXCIzY1wiLCBcIjNkXCIsIFwiM2VcIiwgXCIzZlwiLCBcIjQwXCIsIFwiNDFcIiwgXCI0MlwiLCBcIjQzXCIsIFwiNDRcIiwgXCI0NVwiLCBcIjQ2XCIsIFwiNDdcIiwgXCI0OFwiLCBcIjQ5XCIsIFwiNGFcIiwgXCI0YlwiLCBcIjRjXCIsIFwiNGRcIiwgXCI0ZVwiLCBcIjRmXCIsIFwiNTBcIiwgXCI1MVwiLCBcIjUyXCIsIFwiNTNcIiwgXCI1NFwiLCBcIjU1XCIsIFwiNTZcIiwgXCI1N1wiLCBcIjU4XCIsIFwiNTlcIiwgXCI1YVwiLCBcIjViXCIsIFwiNWNcIiwgXCI1ZFwiLCBcIjVlXCIsIFwiNWZcIiwgXCI2MFwiLCBcIjYxXCIsIFwiNjJcIiwgXCI2M1wiLCBcIjY0XCIsIFwiNjVcIiwgXCI2NlwiLCBcIjY3XCIsIFwiNjhcIiwgXCI2OVwiLCBcIjZhXCIsIFwiNmJcIiwgXCI2Y1wiLCBcIjZkXCIsIFwiNmVcIiwgXCI2ZlwiLCBcIjcwXCIsIFwiNzFcIiwgXCI3MlwiLCBcIjczXCIsIFwiNzRcIiwgXCI3NVwiLCBcIjc2XCIsIFwiNzdcIiwgXCI3OFwiLCBcIjc5XCIsIFwiN2FcIiwgXCI3YlwiLCBcIjdjXCIsIFwiN2RcIiwgXCI3ZVwiLCBcIjdmXCIsIFwiODBcIiwgXCI4MVwiLCBcIjgyXCIsIFwiODNcIiwgXCI4NFwiLCBcIjg1XCIsIFwiODZcIiwgXCI4N1wiLCBcIjg4XCIsIFwiODlcIiwgXCI4YVwiLCBcIjhiXCIsIFwiOGNcIiwgXCI4ZFwiLCBcIjhlXCIsIFwiOGZcIiwgXCI5MFwiLCBcIjkxXCIsIFwiOTJcIiwgXCI5M1wiLCBcIjk0XCIsIFwiOTVcIiwgXCI5NlwiLCBcIjk3XCIsIFwiOThcIiwgXCI5OVwiLCBcIjlhXCIsIFwiOWJcIiwgXCI5Y1wiLCBcIjlkXCIsIFwiOWVcIiwgXCI5ZlwiLCBcImEwXCIsIFwiYTFcIiwgXCJhMlwiLCBcImEzXCIsIFwiYTRcIiwgXCJhNVwiLCBcImE2XCIsIFwiYTdcIiwgXCJhOFwiLCBcImE5XCIsIFwiYWFcIiwgXCJhYlwiLCBcImFjXCIsIFwiYWRcIiwgXCJhZVwiLCBcImFmXCIsIFwiYjBcIiwgXCJiMVwiLCBcImIyXCIsIFwiYjNcIiwgXCJiNFwiLCBcImI1XCIsIFwiYjZcIiwgXCJiN1wiLCBcImI4XCIsIFwiYjlcIiwgXCJiYVwiLCBcImJiXCIsIFwiYmNcIiwgXCJiZFwiLCBcImJlXCIsIFwiYmZcIiwgXCJjMFwiLCBcImMxXCIsIFwiYzJcIiwgXCJjM1wiLCBcImM0XCIsIFwiYzVcIiwgXCJjNlwiLCBcImM3XCIsIFwiYzhcIiwgXCJjOVwiLCBcImNhXCIsIFwiY2JcIiwgXCJjY1wiLCBcImNkXCIsIFwiY2VcIiwgXCJjZlwiLCBcImQwXCIsIFwiZDFcIiwgXCJkMlwiLCBcImQzXCIsIFwiZDRcIiwgXCJkNVwiLCBcImQ2XCIsIFwiZDdcIiwgXCJkOFwiLCBcImQ5XCIsIFwiZGFcIiwgXCJkYlwiLCBcImRjXCIsIFwiZGRcIiwgXCJkZVwiLCBcImRmXCIsIFwiZTBcIiwgXCJlMVwiLCBcImUyXCIsIFwiZTNcIiwgXCJlNFwiLCBcImU1XCIsIFwiZTZcIiwgXCJlN1wiLCBcImU4XCIsIFwiZTlcIiwgXCJlYVwiLCBcImViXCIsIFwiZWNcIiwgXCJlZFwiLCBcImVlXCIsIFwiZWZcIiwgXCJmMFwiLCBcImYxXCIsIFwiZjJcIiwgXCJmM1wiLCBcImY0XCIsIFwiZjVcIiwgXCJmNlwiLCBcImY3XCIsIFwiZjhcIiwgXCJmOVwiLCBcImZhXCIsIFwiZmJcIiwgXCJmY1wiLCBcImZkXCIsIFwiZmVcIiwgXCJmZlwiXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGZyb21IZXhDaGFyID0gYnl0ZSA9PiB7XG4gIC8vICcwJyA8PSBieXRlICYmIGJ5dGUgPD0gJzknXG4gIGlmICg0OCA8PSBieXRlICYmIGJ5dGUgPD0gNTcpIHtcbiAgICByZXR1cm4gYnl0ZSAtIDQ4O1xuICB9XG4gIC8vICdhJyA8PSBieXRlICYmIGJ5dGUgPD0gJ2YnXG4gIGlmICg5NyA8PSBieXRlICYmIGJ5dGUgPD0gMTAyKSB7XG4gICAgcmV0dXJuIGJ5dGUgLSA5NyArIDEwO1xuICB9XG4gIC8vICdBJyA8PSBieXRlICYmIGJ5dGUgPD0gJ0YnXG4gIGlmICg2NSA8PSBieXRlICYmIGJ5dGUgPD0gNzApIHtcbiAgICByZXR1cm4gYnl0ZSAtIDY1ICsgMTA7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXRcIik7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBugErrorMessage: () => (/* binding */ getBugErrorMessage)\n/* harmony export */ });\n/**\n * @since 2.0.0\n */\n/** @internal */\nconst getBugErrorMessage = message => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4Q0FBOEMsU0FBUztBQUM5RCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lcnJvcnMuanM/NzZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZ2V0QnVnRXJyb3JNZXNzYWdlID0gbWVzc2FnZSA9PiBgQlVHOiAke21lc3NhZ2V9IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNgO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js":
/*!*****************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/opCodes/effect.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OP_ASYNC: () => (/* binding */ OP_ASYNC),\n/* harmony export */   OP_COMMIT: () => (/* binding */ OP_COMMIT),\n/* harmony export */   OP_FAILURE: () => (/* binding */ OP_FAILURE),\n/* harmony export */   OP_ON_FAILURE: () => (/* binding */ OP_ON_FAILURE),\n/* harmony export */   OP_ON_SUCCESS: () => (/* binding */ OP_ON_SUCCESS),\n/* harmony export */   OP_ON_SUCCESS_AND_FAILURE: () => (/* binding */ OP_ON_SUCCESS_AND_FAILURE),\n/* harmony export */   OP_REVERT_FLAGS: () => (/* binding */ OP_REVERT_FLAGS),\n/* harmony export */   OP_SUCCESS: () => (/* binding */ OP_SUCCESS),\n/* harmony export */   OP_SYNC: () => (/* binding */ OP_SYNC),\n/* harmony export */   OP_TAG: () => (/* binding */ OP_TAG),\n/* harmony export */   OP_UPDATE_RUNTIME_FLAGS: () => (/* binding */ OP_UPDATE_RUNTIME_FLAGS),\n/* harmony export */   OP_WHILE: () => (/* binding */ OP_WHILE),\n/* harmony export */   OP_WITH_RUNTIME: () => (/* binding */ OP_WITH_RUNTIME),\n/* harmony export */   OP_YIELD: () => (/* binding */ OP_YIELD)\n/* harmony export */ });\n/** @internal */\nconst OP_ASYNC = \"Async\";\n/** @internal */\nconst OP_COMMIT = \"Commit\";\n/** @internal */\nconst OP_FAILURE = \"Failure\";\n/** @internal */\nconst OP_ON_FAILURE = \"OnFailure\";\n/** @internal */\nconst OP_ON_SUCCESS = \"OnSuccess\";\n/** @internal */\nconst OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n/** @internal */\nconst OP_SUCCESS = \"Success\";\n/** @internal */\nconst OP_SYNC = \"Sync\";\n/** @internal */\nconst OP_TAG = \"Tag\";\n/** @internal */\nconst OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n/** @internal */\nconst OP_WHILE = \"While\";\n/** @internal */\nconst OP_WITH_RUNTIME = \"WithRuntime\";\n/** @internal */\nconst OP_YIELD = \"Yield\";\n/** @internal */\nconst OP_REVERT_FLAGS = \"RevertFlags\";\n//# sourceMappingURL=effect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wQ29kZXMvZWZmZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9vcENvZGVzL2VmZmVjdC5qcz80NDlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9BU1lOQyA9IFwiQXN5bmNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9DT01NSVQgPSBcIkNvbW1pdFwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX0ZBSUxVUkUgPSBcIkZhaWx1cmVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9PTl9GQUlMVVJFID0gXCJPbkZhaWx1cmVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9PTl9TVUNDRVNTID0gXCJPblN1Y2Nlc3NcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9PTl9TVUNDRVNTX0FORF9GQUlMVVJFID0gXCJPblN1Y2Nlc3NBbmRGYWlsdXJlXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfU1VDQ0VTUyA9IFwiU3VjY2Vzc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX1NZTkMgPSBcIlN5bmNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9UQUcgPSBcIlRhZ1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX1VQREFURV9SVU5USU1FX0ZMQUdTID0gXCJVcGRhdGVSdW50aW1lRmxhZ3NcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9XSElMRSA9IFwiV2hpbGVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9XSVRIX1JVTlRJTUUgPSBcIldpdGhSdW50aW1lXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfWUlFTEQgPSBcIllpZWxkXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfUkVWRVJUX0ZMQUdTID0gXCJSZXZlcnRGbGFnc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWZmZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/option.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/option.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isOption: () => (/* binding */ isOption),\n/* harmony export */   isSome: () => (/* binding */ isSome),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   some: () => (/* binding */ some)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/**\n * @since 2.0.0\n */\n\n\n\n\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\nconst CommonProto = {\n  ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n  [TypeId]: {\n    _A: _ => _\n  },\n  [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n  }\n};\nconst SomeProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Some\",\n  _op: \"Some\",\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol](that) {\n    return isOption(that) && isSome(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.value, that.value);\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol]() {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.value)));\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag,\n      value: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.value)\n    };\n  }\n});\nconst NoneHash = /*#__PURE__*/_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(\"None\");\nconst NoneProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"None\",\n  _op: \"None\",\n  [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol](that) {\n    return isOption(that) && isNone(that);\n  },\n  [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol]() {\n    return NoneHash;\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag\n    };\n  }\n});\n/** @internal */\nconst isOption = input => (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(input, TypeId);\n/** @internal */\nconst isNone = fa => fa._tag === \"None\";\n/** @internal */\nconst isSome = fa => fa._tag === \"Some\";\n/** @internal */\nconst none = /*#__PURE__*/Object.create(NoneProto);\n/** @internal */\nconst some = value => {\n  const a = Object.create(SomeProto);\n  a.value = value;\n  return a;\n};\n//# sourceMappingURL=option.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3FDO0FBQ0Y7QUFDbUM7QUFDeEI7QUFDSTtBQUNsRDtBQUNBO0FBQ0EsS0FBSywyREFBZTtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcsOERBQWlCO0FBQ3BCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyx1REFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBWTtBQUNmLDZDQUE2Qyw2Q0FBWTtBQUN6RCxHQUFHO0FBQ0gsR0FBRyw0Q0FBVztBQUNkLFdBQVcsNENBQVcsT0FBTyw2Q0FBWSxDQUFDLDBDQUFTLGFBQWEsMENBQVM7QUFDekUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBTTtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QiwwQ0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHLDZDQUFZO0FBQ2Y7QUFDQSxHQUFHO0FBQ0gsR0FBRyw0Q0FBVztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLDBCQUEwQiwwREFBVztBQUM1QztBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2UtbGVhcm5pbmctd2ViYXBwbGljYXRpb24tbG1zLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9vcHRpb24uanM/Y2UyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgKiBhcyBFcXVhbCBmcm9tIFwiLi4vRXF1YWwuanNcIjtcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSBcIi4uL0hhc2guanNcIjtcbmltcG9ydCB7IGZvcm1hdCwgTm9kZUluc3BlY3RTeW1ib2wsIHRvSlNPTiB9IGZyb20gXCIuLi9JbnNwZWN0YWJsZS5qc1wiO1xuaW1wb3J0IHsgaGFzUHJvcGVydHkgfSBmcm9tIFwiLi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgeyBFZmZlY3RQcm90b3R5cGUgfSBmcm9tIFwiLi9lZmZlY3RhYmxlLmpzXCI7XG5jb25zdCBUeXBlSWQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9PcHRpb25cIik7XG5jb25zdCBDb21tb25Qcm90byA9IHtcbiAgLi4uRWZmZWN0UHJvdG90eXBlLFxuICBbVHlwZUlkXToge1xuICAgIF9BOiBfID0+IF9cbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufTtcbmNvbnN0IFNvbWVQcm90byA9IC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKCAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShDb21tb25Qcm90byksIHtcbiAgX3RhZzogXCJTb21lXCIsXG4gIF9vcDogXCJTb21lXCIsXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICByZXR1cm4gaXNPcHRpb24odGhhdCkgJiYgaXNTb21lKHRoYXQpICYmIEVxdWFsLmVxdWFscyh0aGlzLnZhbHVlLCB0aGF0LnZhbHVlKTtcbiAgfSxcbiAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICByZXR1cm4gSGFzaC5jYWNoZWQodGhpcywgSGFzaC5jb21iaW5lKEhhc2guaGFzaCh0aGlzLl90YWcpKShIYXNoLmhhc2godGhpcy52YWx1ZSkpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiT3B0aW9uXCIsXG4gICAgICBfdGFnOiB0aGlzLl90YWcsXG4gICAgICB2YWx1ZTogdG9KU09OKHRoaXMudmFsdWUpXG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBOb25lSGFzaCA9IC8qI19fUFVSRV9fKi9IYXNoLmhhc2goXCJOb25lXCIpO1xuY29uc3QgTm9uZVByb3RvID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oIC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKENvbW1vblByb3RvKSwge1xuICBfdGFnOiBcIk5vbmVcIixcbiAgX29wOiBcIk5vbmVcIixcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIHJldHVybiBpc09wdGlvbih0aGF0KSAmJiBpc05vbmUodGhhdCk7XG4gIH0sXG4gIFtIYXNoLnN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIE5vbmVIYXNoO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJPcHRpb25cIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZ1xuICAgIH07XG4gIH1cbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGlzT3B0aW9uID0gaW5wdXQgPT4gaGFzUHJvcGVydHkoaW5wdXQsIFR5cGVJZCk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNOb25lID0gZmEgPT4gZmEuX3RhZyA9PT0gXCJOb25lXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNTb21lID0gZmEgPT4gZmEuX3RhZyA9PT0gXCJTb21lXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3Qgbm9uZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKE5vbmVQcm90byk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3Qgc29tZSA9IHZhbHVlID0+IHtcbiAgY29uc3QgYSA9IE9iamVjdC5jcmVhdGUoU29tZVByb3RvKTtcbiAgYS52YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gYTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/option.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/singleShotGen.js":
/*!****************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/singleShotGen.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SingleShotGen: () => (/* binding */ SingleShotGen)\n/* harmony export */ });\n/** @internal */\nclass SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n//# sourceMappingURL=singleShotGen.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3NpbmdsZVNob3RHZW4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvc2luZ2xlU2hvdEdlbi5qcz9hMjFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTaW5nbGVTaG90R2VuIHtcbiAgc2VsZjtcbiAgY2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICB9XG4gIG5leHQoYSkge1xuICAgIHJldHVybiB0aGlzLmNhbGxlZCA/IHtcbiAgICAgIHZhbHVlOiBhLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH0gOiAodGhpcy5jYWxsZWQgPSB0cnVlLCB7XG4gICAgICB2YWx1ZTogdGhpcy5zZWxmLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4oYSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYSxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG4gIHRocm93KGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgU2luZ2xlU2hvdEdlbih0aGlzLnNlbGYpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW5nbGVTaG90R2VuLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/singleShotGen.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentVersion: () => (/* binding */ getCurrentVersion),\n/* harmony export */   setCurrentVersion: () => (/* binding */ setCurrentVersion)\n/* harmony export */ });\nlet moduleVersion = \"3.7.2\";\nconst getCurrentVersion = () => moduleVersion;\nconst setCurrentVersion = version => {\n  moduleVersion = version;\n};\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lLWxlYXJuaW5nLXdlYmFwcGxpY2F0aW9uLWxtcy8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvdmVyc2lvbi5qcz82MTFhIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBtb2R1bGVWZXJzaW9uID0gXCIzLjcuMlwiO1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRWZXJzaW9uID0gKCkgPT4gbW9kdWxlVmVyc2lvbjtcbmV4cG9ydCBjb25zdCBzZXRDdXJyZW50VmVyc2lvbiA9IHZlcnNpb24gPT4ge1xuICBtb2R1bGVWZXJzaW9uID0gdmVyc2lvbjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/version.js\n");

/***/ })

};
;